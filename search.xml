<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[记百度 Java 实习第二面]]></title>
    <url>%2F2018%2F04%2F18%2F%E8%AE%B0%E7%99%BE%E5%BA%A6-Java-%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%BA%8C%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[我看好自己的认真！ 前言突如其来哦，毫无防备…… 面试内容1、HashMap的存储结构 2、HashMap扩容过程旧数据如何处理？位置还是原来位置吗？ 3、HashMap对key有什么要求吗？一般用String作为key，问我能否用int或者其他Object类型 4、Object作为HashMap的key的话，对Object有什么要求吗？ 5、Object若不重写hashCode()的话，hashCode()如何计算出来的？ 6、hashCode()和equals()方法有什么联系？ 7、若对一个类不重写，它的equals()方法是如何比较的？ 8、==比较的是什么？ 9、hashCode()和equals()方法有什么要求吗？ 10、简单算法题：将一个二维数组顺时针旋转90度，说一下思路。 11、简单算法题：将一个int类型数字、负数逆序输出，须返回一个int类型数字。即反转 12、String能继承吗？就说到了用final修饰 13、final怎么用？分别说了修饰变量、方法、类 14、ConcurrentHashMap的分段锁原理 15、Java中有几种方式启动一个线程？（说了个start()、线程池不知道对否） 16、线程池有什么好处？ 17、Java中有几种线程池？ 18、TCP的三次握手 19、TCP如何保证可靠传输？ 20、框架用过哪些？说刚入门Spring、经典三层MVC 21、项目 22、Servlet是线程安全的吗？（一脸懵逼） 后记完了就说，嗯好了解了，那我们今天先到这里。加油]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 线程池的原理]]></title>
    <url>%2F2018%2F04%2F18%2FJava-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[我看好自己的认真！ 前言本篇博文将解决三个问题： 为什么要使用线程池 线程池的实现原理 如何使用线程池 首先解决第一个问题，我们为什么要使用线程池？线程池，顾名思义，就是用来管理线程的创建，销毁的。具体原因可分为以下三点： （1）、降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 （2）、提高响应速度：当任务到达时，任务可以不需要等到线程创建就能立即执行。 （3）、提高线程的可管理性：线程是稀缺资源，若无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。但是，要做到合理利用线程池，必须对其实现原理了如指掌。 线程池的实现原理当一个任务被提交到线程池后，这个任务会是怎样被处理的呢？在正式介绍之前，先来了解几个概念： 核心线程池：任务提交到首先考虑使用这个线程池中的线程。 工作队列：存储等待线程的任务的一个队列。 一般线程池：当工作队列里存储任务满时，则将任务提交到一般线程池。 下面我们通过这幅图来了解一下一个任务的处理流程： ​ [ 线程池的主要处理流程] 主要三个流程： （1）、线程池判断核心线程池中线程是否都在执行任务。若不是，则创建一个新的工作线程来执行任务。若核心线程池中线程都在执行任务，则将其任务进入下一个流程。 （2）、线程池判断工作队列是否已满。未满，将新提交任务存储其中；已满，进入下一个流程。 （3）、线程池判断一般线程池中线程是否都处于工作状态。不是，创建一个新线程执行任务；是，提交给饱和策略来处理这个任务。 线程池的使用 线程池的创建1new ThreadPoolExecutor(corePoolSize,maximumPoolSize,keepAliveTime,milliseconds,runnableTaskQueue,handler); 那么创建线程时的这几参数是和意义？ corePoolSize(线程池的基本大小)：当提交一个任务到线程池时，即使还有其他空闲的核心线程，线程池会创建一个线程来执行任务，直到核心线程等于corePoolSize时，就会将新提交的任务放入队列或创建新的工作线程。我们可以通过调用线程池的prestartAllCoreThreads（)方法来提前创建并启动所有的核心线程。 runnableTaskQueue(任务队列)：用于保存等待执行的任务的阻塞队列。可以选择ArrayBolckingQueue、LinkedBlockingQueue、SynchronousQueue、PriorityBlockingQueue等阻塞队列。 maximumPoolSize(线程池最大数量)：如果队列已满，并且已创建的线程数小于maximumPoolSize，则线程池会创建新的线程执行任务。如果使用了无界队列，则此参数无效果。 ThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。 RejectedExecutionHandler(饱和策略)：如果队列已满，且已创建的线程数等于maximumPoolSize，则采取饱和策略处理新提交的任务。有以下4种策略： AbortPolicy:直接抛出异常。 CallerRunsPolicy:使用调用者线程来执行任务。 DiscardOldestPolicy:丢弃队列里最近的一个任务，并执行当前任务。 DiscardPolicy:不处理，直接丢弃任务。 我们也可以实现RejectedExecutionHandler接口来自定义饱和策略，如记录日志或持久化存储等。 keepAliveTime(线程保持活动时间)：线程池中空闲的线程存活时间。 TimeUnit(线程保活时间的单位)：可选的单位有天、小时、分钟、毫秒、微妙和纳秒。 向线程池提交任务记住两种方法：execute()和submit()方法 这两种方法都可以向线程池提交任务，但也有区别如下： execute()方法用于提交不需要返回值的任务，所以无法判断任务的执行状态。 submit()方法用于提交需要返回值的任务。线程池会返回一个Future类型的对象，通过此对象，我们可以判断任务是否执行成功，并通过get()方法阻塞当前线程直到任务完成并返回返回值。 关闭线程通过调用线程池的shutdown或shutdownNow方法来关闭线程池。其原理是遍历线程池中的工作线程，然后依次调用线程的interrupt方法中断线程。两者的区别是shutdownNow方法会立即中断所有的工作线程，而shutdown方法只会中断未开始的任务线程并等待正在执行任务的线程执行完毕。可以调用isShutDown方法和isTerminaed方法来检查线程池及线程池中的工作线程关闭状态。 合理地分配线程池要想合理的配置线程池，就必须首先分析任务特性，可以从以下几个角度分析。 任务的性质：CPU密集型任务、IO密集型任务和混合型任务。 任务的优先级：高、中和低。 任务的执行时间：长、中和短。 任务的依赖性：是否依赖其他系统资源，如数据库连接。性质不同的任务可以用不同规模的线程池分开处理。CPU密集型任务应配置尽可能小的线程，如cpu个数+1个线程。而IO密集型任务应配置尽可能多的线程，如cpu数量*2个线程。因为IO密集型任务线程并不是一直在执行任务，可能被IO阻塞等，如果线程太少，则会导致无法及时处理新提交的任务。 线程池的监控如果在系统中大量使用线程池，则有必要对线程池进行监控，方便在出现问题时，快速定位问题。可以通过线程池提供的以下参数进行监控： taskCount：线程池需要执行的任务数量。 completedTaskCount：线程池在运行过程中已完成的任务数量，小于或等于taskCount。 largestPoolSize：线程池里增加创建过的最大线程数量。通过这个数据可以知道线程池是否曾经满过。 getPoolSize：线程池的线程数量。 getActiveCount：获取活动的线程数。也可以通过继承线程池来自定义线程池，重写线程池的beforeExecute、afterExecute和terminate方法，在任务执行前、执行后和线程池关闭前执行一些代码进行监控。 总结小记主要讲解了线程池的使用原理，在概念上进行了解。]]></content>
      <categories>
        <category>Java 并发编程的艺术</category>
      </categories>
      <tags>
        <tag>ThreadPool</tag>
        <tag>Java线程池原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记百度 Java 实习第一面]]></title>
    <url>%2F2018%2F04%2F16%2F%E8%AE%B0%E7%99%BE%E5%BA%A6-Java-%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[我看好自己的认真！ 前言几天前，百度方面就打来了电话，和我确定了面试时间，没错，就是今天下午二点。我一点半就午休起来等待电话铃声的响起，过了两点后，还没有来，我的内心更慌了，过了十分后铃声突然响起，响了几秒钟就接了，哈哈。 面试内容这次把面试的主要内容简单介一下，有些问题回答的不太好，需要再仔细琢磨，主要内容如下： 1、简单自我介绍，（西电大二，自学Java，想找实习，balabala）….. 2、简要介绍简历上项目：网上图书商城，主要功能有哪些？用到哪些技术栈？说到了经典MVC三层框架，简单介绍 3、看我正在学习Spring，让简要说一下spring Ioc 4、问我是否用过spring+springMVC？ 5、有没有学过数据结构——&gt;引出数组和链表的区别？说到了数组和链表增删速度以及为什么？ 6、给了我10亿条散乱、无序的数据，让我找出1000个最大的数，问我有什么想法吗？（傻傻的说到了排序，递归，面试官自言到：用递归吗？凉了。。。一看我胡说，就再没有问） 7、Java 递归栈最深能递归多少次（说10个数据的话，递归肯定会溢出。这个我，没说上） 8、排序（和10亿数据有关，没回答上，让我下去了解一下） 9、JVM内存区域、类加载过程 10、类卸载发生到什么时候？ 11、JVM 垃圾对象回收相关（引用计数法、可达性分析算法判断对象死活；常用垃圾回收算法G1(JDK1.7以上)） 12、垃圾回收算法（标记清除，标记整理，复制算法） 13、什么时候会触发新生代、老年代垃圾回收？ 14、Java 内存模型 15、锁机制：volatile（内存可见性、禁止指令重排序），sychronized（monitorenter和monitorexit）在内存方面进行解释。同一时间，两个线程访问一个被sychronized修饰的方法块，JVM是如何阻止另外一个线程访问的？（面试官说回答的差不多） 16、数据库索引，索引如何做到快速查询？（不了解） 17、HTTP协议：问到后端给前端传递一条数据，HTTP是如何进行传递的？消息体里有哪些？后端传递的数据放在了HTTP哪里？（消息体这儿答得不太好，即数据内容怎么存放的？） 18、问我大一时参加的星火杯是什么？ 19、问我有没有什么展示我代码功底的：说到了Github 20、面试官问我有什么要问她的？（对，面试官是小姐姐诶），问了部门业务——大数据，部门人数—1000到2000 21、问我什么时候能去实习？ 后记然后就完了，对，完了。面试官说今天就聊这儿吧。所以还会有明天吗？挂了之后就想起来怎么没有问会有面试结果通知吗，嘎嘎嘎嘎嘎嘎。。。 总体感觉回答的还可以，也有答得不好的地方，要去努力了！]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发机制的底层实现原理]]></title>
    <url>%2F2018%2F04%2F15%2FJava-%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[前言]]></content>
      <categories>
        <category>Java 并发编程的艺术</category>
      </categories>
      <tags>
        <tag>synchronized</tag>
        <tag>volatile</tag>
        <tag>原子操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发容器之看清 ConcurrentHashMap 构造]]></title>
    <url>%2F2018%2F04%2F15%2FJava-%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8B%E7%9C%8B%E6%B8%85-ConcurrentHashMap-%E6%9E%84%E9%80%A0%2F</url>
    <content type="text"><![CDATA[前言Java 中的集合框架HashMap 和 ConcurrentHashMap在我几次面试中，都问到了，可见其在考察基础知识中的重要性。今天就要看清它的庐山真面目，看看它到底是个什么鬼，为何如此受青睐。 先看ConcurrentHashMap的实现原理ConcurrentHashMap 是线程安全且高效的HashMap。我们即将知道他是如何在保证线程安全的前提下又保证高效的呢？ 为什么要用ConcurrentHashMap在并发编程中使用HashMap可能导致程序死循环。而使用线程安全的HashTable效率又低下，基于以上两个原因，便有了ConcurrentHashMap的登场机会 在说此之前，我们不得不先来看看常用的但又线程不安全的HashMap 线程不安全的HashMap在多线程环境下，使用HashMap进行put操作会引起死循环，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap。所以我们来看一段会引起死循环的代码： 12345678910111213141516171819202122232425262728293031323334package stormwangxhu.algorithm;import java.util.HashMap;import java.util.UUID;public class Main &#123; public static void main(String[] args) &#123; new Main().MapTest(); &#125; public void MapTest()&#123; final HashMap&lt;String,String&gt; map=new HashMap&lt;String, String&gt;(); Thread thread=new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt;10000 ; i++) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; map.put(UUID.randomUUID().toString(),""); &#125; &#125;,"FTF"+i).start(); &#125; &#125; &#125;,"FTF"); thread.start(); try &#123; thread.join(); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; HashMap在并发执行put操作时会引起死循环，是因为多线程会导致HashMap的Entry链表形成环形数据结构，一旦形成环形数据结构，Entry的next节点永远不会为空，就会产生死循环获取Entry。 下面再看看在多线程环境下效率低下的HashTable 效率低下的HashTableHashTable 容器使用关键字sychronized 来保证线程安全，但在线程竞争激烈的情况下HashTable 的效率就会非常低下。因为当一个线程访问HashTable的同步方法，其他线程也会访问HashTable的同步方法时，就会进入阻塞或轮询状态。若线程1使用put进行元素添加，线程2不但不能使用put方法进行添加元素，就会连get方法来获取元素也不能使用，所以线程竞争越激烈效率就越低！ 现在来看看ConcurentHashMap是如何即保证线程安全又获得高效率呢？ ConcurrentHashMap到底底层使用什么法宝呢？是不是很期待？厉害了！它是用的是一种锁分段技术来有效提升并发访问效率。那么问题来了，什么是锁分段技术？ 什么是锁分段技术HashTable 容器在竞争激烈的并发环境中表现出效率低下的原因是：所有访问HashTable的线程都必须竞争同一把锁，假如容器里有很多把锁，每一把锁用于锁容器其中的一部分数据，那么多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术。 锁分段技术：首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。 现在知道了这个技术后，我们就应该来看看他是怎么实现的了，即他的实现原理是什么？请接着往下看： 看清ConcurrentHashMap 的结构先来看看ConcurrentHashMap 的结构图： 再看看ConcurrentHashMap的类图： 看完上面两幅图后，我们来进行深入剖析： ConcurrentHashMap = Segment数组结构 + HashEntry数组结构组成。 Segment数组结构扮演锁的角色。 HashEntry则用于存储键值对数据。 一个ConcurrentHashMap包含一个 Segment数组结构和 HashEntry数组结构。 Segment数组结构：它是一种可重入锁（ReentranLock），在ConcurrentHashMap里扮演者锁的角色。它和HashMap类似，是一种数据加链表结构。 在我前面的博文中，《深入理解Java虚拟机》中，关于Segment进行了简单的介绍，下面也回顾一下： ReentranLock，即可重入锁，它是java.util.concurrent包下的，它可以来实现同步，在基本用法上，ReentranLock和sychronized很相似，他们都具备一样的线程重入特性，只是代码写法上有点区别。 ReentranLock和sychronized区别： ReentranLock表现为API层面的互斥锁（Lock()和unLock()方法配合try/finally语句块来完成），而sychronized表现为原生层面的互斥锁。 注意此处：我说的是原生层面，什么意思？因为Java的线程是映射到操作系统的原生线程之上的，如果要阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态切换到核心态中，因而状态转换需要耗费很多处理器的时间。所以sychronized是Java语言中的一个重量级的操作。所以应该在确实有必要的情况下在使用这种操作。 那么关于ReentranLock和sychronized在性能上谁优谁不优怎么知道呢？在多线程环境下，sychronized的吞吐量下降的会非常严重，而ReentranLock则基本保持在同一个比较稳定的水平上。在JDK1.6发布之后，两者之间在性能上基本持平了。因此虚拟机在未来的性能改进中也会更加偏向于原生的sychronized，所以还是提倡在sychronized能实现需求的情况下，优先考虑sychronized来进行同步。 好了，说完了两者区别后，我们继续前面的话题： 一个Segment里包含一个HashEntry数组，每一个HashEntry数组是一个链表结构的元素，每一个Segment守护者一个HashEntry数组里的元素。当对HashEntry数组进行修改时，必须先获得与它对应的Segment锁 上面这句话的意思可以用下面这幅图来解释： 总结一下：Segment组成： 数组+链表 HashEntry组成： 链表 两者关系：每个segment里包含一个HashEntry数组。 再来看一下HashMap和ConcurrentHashMap在语句上的理解：HashMap它是一个数组+链表，它整个数组上有一个锁，在多线程中会存在锁资源的争夺，但是ConcurrentHashMap它的Segment他是一个数组，每个数组元素空间就是一把锁空间，这个锁空间里存放着HashEntry，而HashEntry则在锁空间里来存放键值对数组。对，就是这样。 ConcurrentHashMap的初始化ConcurrentHashMap初始化方法是通过initCapacity，loadFactor和concurrencyLevel等几个参数来初始化segment数组、段偏移量segmentShift、段掩码segmentMask和每一个segment里的HashEntry数组来实现。 初始化segments数组让我们来看一下segment数组的源代码： 1234567891011if(concurrentLevel&gt;MAX_SEGMENT) concurrentLevel = MAX_SEGMENT;int sshift=0;int ssize=1; //segment数组长度，也即为容器中锁的个数while(ssize&lt;concurrencyLevel)&#123; ++sshift; ssize &lt;&lt;= 1;&#125;segmentShift = 32 - sshift;segmentMask = ssize - 1;this.segment = Segment.newArray(ssize); 从上面代码可知，segments数组的长度ssize是通过concurrencyLevel计算出来的。为了能通过按位与的散列算法来定位segments数组的索引，必须保证segments数组的长度是2的N次方，所以必须计算出一个大于或等于concurrencyLevel的最小的2的N次方值来作为segments的数组的长度。假如concurrencyLevel等于14，15或者16，ssize都会等于16，即容器里锁的个数也是16。 初始化segmentShift和segmentMask解释一下这两个全局变量： sshift：等于ssize从1向左移位的次数。在默认情况下，concurrencyLevel=16，需要1向左移位4次，即sshift=4。 segmentShift：用于定位参与散列运算的位数。 segmentShift = 32-sshift=28；因为ConcurrentHashMap里的hash()方法输出的最大数为32位。 segmentMask：是运算散列码运算的掩码。segmentMask=ssize - 1，即15，掩码的二进制各个位的值都是1。因为ssize的最大长度是65536，所以segmentShift最大值为16，segmentMask最大值为65535，对应的二进制是16位，每个位都是1。 初始化每个segment 输入参数initCapacity是ConcurrentHashMap的初始容量，loadFactor是每个segment的负载因子，在构造方法里需要通过这两个参数来初始化数组中的每一个segment。 12345678910if(initCapacity &gt; MAXIMUM_CAPACITY)&#123; initCapacity = MAXIMUM_CAPACITY; int c=initialCapacity/ssize; if(c * ssize &lt;initCapacity ) ++c; while(cap &lt; c) cap &lt;&lt; 1; for(int i =0;i&lt;this.segments.length;i++) this.segment[i]=new Segment&lt;K,V&gt;(cap,loadFactor)&#125; 上面代码中的变量cap就是segment里的HashEntry数组的长度，它等于initCapacity除以ssize的倍数c，若c大于1，就是取大于等于c的2的N次方值，所以cap不是1，就是2的N次方。 segment的容量threshold=(int) cap * loadFactor，默认情况下initCapacity=16，loadFactor=0.75,通过运算cap等于1，threshold=0。 定位Segment再看ConcurrentHashMap的使用]]></content>
      <categories>
        <category>Java 并发编程的艺术</category>
      </categories>
      <tags>
        <tag>分段锁技术</tag>
        <tag>synchronized</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拿 递归 来说事儿]]></title>
    <url>%2F2018%2F04%2F13%2F%E6%8B%BF%20%E9%80%92%E5%BD%92%20%E6%9D%A5%E8%AF%B4%E4%BA%8B%E5%84%BF%2F</url>
    <content type="text"><![CDATA[前言递归，以我目前知道的知识来说，其重要性不言而喻，它在求解最大、最小、最多、最长、最优等动态规划题中应用最为广泛吧。动态规划的精髓就是在递归和加缓存上。那么，今天就初步了解一下递归，到底递的是什么归（“鬼”）~。 递归是什么递归的定义：它是什么？ 在书上其定义是这样的：通过简化问题规模来解决问题的方法称为递归。简化规模到底是怎么简化的，后文中将会说到。在数学中，递归定义是这样的： 120!=1 (n=0) //基本公式n!=n*(n-1)! (n&gt;0) //递归公式 ，也叫一般公式 即当n是一个大于0的整数时，我们先计算(n-1)! ，再将其与n 相乘。要计算出(n-1)! ，应该就再应用一次定义，以此类推。 一个递归如上面所示，有一个基本公式和一个递归公式，他们有以下的关系： 每个递归定义都必须包含一个或多个基本公式。 一般公式最后必须简化为基本公式。 基本公式可结束递归。 再看几个概念： 递归算法： 通过将问题简化为比自身更小的形式来得到问题的解的算法称为递归算法。递归算法使用递归方法来实现。 递归方法： 调用自身的方法称为递归方法。首先来一个阶乘的例子： 1234567public static int fact(int num)&#123; if (num==0)&#123; return 1; &#125;else &#123; return num*fact(num-1); &#125; &#125; 那么在递归方法执行的过程中，有什么注意点呢？ 在逻辑上，递归方法可以无限的调用自身。 每个递归方法的调用—–也就是每一个递归调用——都有自己的代码、参数和局部变量。 在完成一个递归调用后，控制权会返回前一个调用的调用环境。当前（递归）调用必须在控制权返回上一个调用前执行完毕。前一个调用在递归调用返回后立即执行。 知道了递归的这些知识后，我们便可以利用递归来解决一些问题，这些问题使用递归都有套路。也就说，递归要解决的问题，在使用递归时，有套路或者模板可循。 使用递归解决问题求数组中的最大元素我们给定一个数组，求该数组中的最大或最小元素，那么这个问题便可以用递归来解决。 1int[] list=&#123;11,32,54,98,45&#125;; 假如有以上数组，要求改数组中的最大元素。我们可以这样来考虑：在数组中元素等于1时，即为最大元素。当数组元素大小大于1时，我们先取出第一个元素，在剩余的list[1]到list[4]中进行比较，比较出最大元素，再与list[0] 进行比较，返回最大元素。依次类推。在每次使用上面的公式在子表中寻找最大元素后，下一个调用中的子表长度就会减1。最后的子表长度会变为1，即子表只包含一个元素，这个元素也就是子表中最大的元素。从此再向前，通过递归调用原路返回。 我们设计一个方法，有三个参数，第一个参数为要比较的数组，第二个参数为数组第一个元素位置参数，第三个元素为数组最后一个元素位置。 1234567891011public static int maxNumber(int[] nums, int lowerIndex, int upperIndex) &#123; int max; if (lowerIndex == upperIndex) &#123;//数组中只有一个元素，也就是最大值了 return nums[lowerIndex]; &#125; else &#123; max = maxNumber(nums, lowerIndex + 1, upperIndex);//递归调用 if (nums[lowerIndex] &gt;= max) //寻找最大值 return nums[lowerIndex]; return max; &#125; &#125; 没错，就是上面这个方法。 12345678910111213141516171819202122/** * 递归解决数组中求最大元素。 */public class Solution&#123; public static void main(String[] args) &#123; int[] nums = &#123;11,32,54,98,45&#125;; int max = maxNumber(nums, 0, nums.length-1); System.out.println(max); //System.out.println(fact(5)); &#125; public static int maxNumber(int[] nums, int lowerIndex, int upperIndex) &#123; int max; if (lowerIndex == upperIndex) &#123; return nums[lowerIndex]; &#125; else &#123; max = maxNumber(nums, lowerIndex + 1, upperIndex); if (nums[lowerIndex] &gt;= max) return nums[lowerIndex]; return max; &#125; &#125;&#125; 我们来看一下输出结果： 198]]></content>
      <categories>
        <category>（第二部分）数据结构和设计模式</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初解 HashMap 源码（二）]]></title>
    <url>%2F2018%2F04%2F11%2F%E5%88%9D%E8%A7%A3-HashMap-%E6%BA%90%E7%A0%81%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[你的努力终将会有回报，路漫漫其修远兮，吾将上下而求索！ 前言]]></content>
      <categories>
        <category>打怪升级之源码解析系列</category>
      </categories>
      <tags>
        <tag>HashMap源码</tag>
        <tag>集合框架源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 开源]]></title>
    <url>%2F2018%2F04%2F11%2FJava-%E5%BC%80%E6%BA%90%2F</url>
    <content type="text"></content>
      <categories>
        <category>（第四部分）Java 开源</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[初解 HashMap 源码准备（一）]]></title>
    <url>%2F2018%2F04%2F11%2F%E5%88%9D%E8%A7%A3-HashMap-%E6%BA%90%E7%A0%81%E5%87%86%E5%A4%87%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[你的努力终将会有回报，路漫漫其修远兮，吾将上下而求索！ 前言经过了头条 和阿里巴巴 的两次面试后,虽然两次都挂在了一面,但对于大二的我也非常有收获。每次面试都对自己有了更清晰的认识，对要学的东西也变的更清楚。比如现在还停留在 Java 这门语言的层面，还有数据结构、算法、计算机原理、操作系统等知识都还没有学习，记得阿里面试官问我，还有哪些技能吗？我想了想，也只能说现在在学习语言，其他的还没有开始学习。说完后，也略觉尴尬。还有便是基础的重要性了，一面大都会问基础知识，基础知识掌握不牢固，感觉即使后面的知识学的可以，也有可能被挡在一面这道门槛上。所以下定决心回头看基础，从两次都问到的HashMap源码阅读开始。只希望我们都可以知其然，知其所以然。 本篇博客，作为初试HashMap 源码阅读的开端章。将介绍一下相关概念。 Map相关Map接口及其实现 从上图可以看出，HashMap 它继承类AbstractMap ，实现了3个接口Map ，Serializable ,Cloneable ，我们也可以从源码中看： 1234public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; //...暂时省略源码&#125; 现在我们只需要知道接口它分别提供了什么功能即可：Serializable 接口提供序列化、Cloneable 提供克隆方法、Map 提供关于Map 集合一些操作的方法，如：get、put 方法等。其中类AbstractMap 它实现了一些Map 接口中的一些方法，自己也提供了一些方法。 散列与散列码hashCode()和equlas()方法解读初看HashMap性能因子容量容量：即表中的桶位数。 初始容量初始容量：表在创建时所拥有的桶位数，HashMap和HashSet都具有允许你指定初始容量的构造器。 尺寸尺寸：表中当前存储的项数。 负载因子负载因子：记住这个公式：负载因子=尺寸/容量 。空表的负载因子为0，半满表的负载因子是0.5，以此类推。负载轻的表产生冲突的可能性小，因此对于插入和查找都是最理想的（但是会减慢使用迭代器进行遍历的过程）。HashMap和HashSet都具有允许你指定负载因子的构造器，表示当负载因子情况达到该负载因子的水平时，容器将会自动增加其容量（桶位数），实现方式是使容量大致加倍，并重新将现有对象分布到新的桶位集中（这被称为再散列）。 若知道将要在HashMap中存储多少项，那么创建一个具有恰当大小的初始容量将可以避免再散列的开销。 数组简介数组？什么是数组，相信数组大家已经非常熟悉，那么在学习完了JVM运行时数据区域后，我们就应该载来认识一下数组在内存中是怎么样分配的？ 1int[] array = new int[3]; 当我们new 一个数组时，那么在Java运行时区域的堆内存中，便会分配出一块内存，并返回该对象的引用。 那么二维数组呢？ 1int [][] array = new int[3][]; 在大一时学习C语言的二维数组时说到其实二维数组也是一维数组。到底什么意思呢？ 123array[0] = new int[3];array[1] = new int[5];array[2] = new int[4]; 二维数组其实是这样的： 在Java中，数组也是一个对象，堆内存中怎样存放对象，也就怎么样存放数组。 1234567891011class A &#123; int x; int y;&#125;public void m1() &#123; int i = 0; m2();&#125;public void m2() &#123; A a = new A();&#125; 我们来看这段代码，首先执行方法m1() ,在上几篇博文中讲到：“虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行时都会创建一个栈帧（Stack Frame），用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。单线程下有错误时会抛出StackOverFlowError ，多线程下会抛出OutOfMemoryError 。” 详情：（二）初探JVM 内存解构 现在来看看上述代码执行都发生了什么？ 首先，在执行方法m1 时，就会在VM栈中创建一个栈帧，在局部变量表中存储变量i ,将其栈帧压入进栈中，然后执行m2 方法，又创建栈帧Frame-2 ，栈帧Frame-2 被创建并push 到栈中，在m2 方法中，一个新的对象A在堆中被创建，而它的引用则被put 到栈帧Frame-2 里； 单向链表简介 链表，是什么？链表是一组元素的集合，这些元素被称为节点（node），每个节点（除最后一个节点外）都包含了下一节点的地址。因此，链表中的每个节点都有两个字段：一个拿来存储相关信息，一个存储下一个节点的地址，称为链。链表中第一个节点的地址存储在一个单独的节点中，该节点称为头节点或首节点。 12345678910111213141516171819202122232425262728293031public class Node&lt;K, V&gt; &#123; private final K key; private V value; private Node&lt;K, V&gt; next;//存放地址 public Node(K key, V value, Node&lt;K, V&gt; next) &#123; this.key = key; this.value = value; this.next = next; &#125; public K getKey() &#123; return key; &#125; public V getValue() &#123; return value; &#125; public void setValue(V value) &#123; this.value = value; &#125; public Node&lt;K, V&gt; getNext() &#123; return next; &#125; public void setNext(Node&lt;K, V&gt; next) &#123; this.next = next; &#125; &#125; 红黑树简介R-B Tree，全称是Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。 红黑树特性（1）每个节点或者是黑色，或者是红色。（2）根节点是黑色。（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]（4）如果一个节点是红色的，则它的子节点必须是黑色的。（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。 示意图如下： 红黑树的应用比较广泛，主要是用它来存储有序的数据，它的时间复杂度是O(lgn)，效率非常之高。例如，Java集合中的TreeSet 和TreeMap ，C++ STL中的set、map，以及Linux虚拟内存的管理，都是通过红黑树去实现的。 总结主要学习了HashMap学习所需要的一些常识知识，因为在后面博文中我们会用到这些知识？HashMap内部到底有着怎么样的秘密？很期待~~~。]]></content>
      <categories>
        <category>打怪升级之源码解析系列</category>
      </categories>
      <tags>
        <tag>HashMap源码</tag>
        <tag>集合框架源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统、数据库、网络]]></title>
    <url>%2F2018%2F04%2F11%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%81%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"></content>
      <categories>
        <category>（第三部分）操作系统、数据库、网络</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>数据库</tag>
        <tag>网路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 程序设计]]></title>
    <url>%2F2018%2F04%2F11%2FJava-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"></content>
      <categories>
        <category>（第一部分）Java 程序设计</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[记阿里巴巴 Java 实习第一面]]></title>
    <url>%2F2018%2F04%2F10%2F%E8%AE%B0%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4-Java-%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[我看好自己的认真！ 前言炎热的下午，刚在体育课上测完了一千米，嗓子要着火了，跑完后感觉要膨胀了，又测了50、身高、肺活量、体前屈。测完后就在树荫下休息，离下课还有10分钟的时候，口袋里的手机突然想起，拿起一看，阿里巴巴集团，当时就意识到可能是要和我商量面试时间，但接了后，却和其他公司不一样，面试官直接就问我，有时间吗？我们简单面试一下。我看了看体育老师，过去请了个假，就赶紧去一边面试了，不知道为什么声音很小，我有点儿听不清，好几次就请求面试官：“不好意思呢，刚才没听清，嘻嘻~”挺尴尬的。面试了34分钟。我到现在有的问题都忘了，大体内容如下： 面试内容1、自我介绍：balabala 2、现在都学习了些什么？balabala 3、HashMap底层实现原理，是否读过HashMap源码？ 4、HashMap和ConcurrentHashMap在线程安全上有何区别？如何实现？ 5、项目：小程序。问到遇到什么问题吗？在这里问了好多，还有业务逻辑，感觉答得都不是太好。 6、了解过哪些中间件？ 7、Java 的特性？ 8、Java 内存模型 9、JVM 类加载机制 10、双亲委派模型 11、Object都有哪些方法？ 12、高并发、高并发、高并发！重要的说三遍。如何解决？答得不太好，一脸懵逼！ 13、锁优化CAS 14、sychronized和volitile 15、反射的使用场景？很重要，我没怎么说上来。下来后回想感觉应该和框架（Spring）还有关系,以后学习得注意点。 16、还问了我的英语怎么样？考六级了吗 17、在Github上关注了什么开源项目了没？ 18、看了我的博客（挺开心的，感觉博客搭建上还是挺好的），问我是自学吗？一般怎么学？ 19、了解Linux吗？确实没咋用，就说了知道几个命令。 20、觉得自己是一个怎样的人？ 21、又想起来了，还问到了异常？并解释为什么？ 大概就这些吧，有些记不起来了，最后也没像头条面试官一样，问我有什么问题要问吗？就说那就今天先面试到这儿，我说了声谢谢。哦，对了，开头自我介绍前，还问我什么时候可以来实习，能实习多长时间？然后就没了，大厂面试就这样结束了。不知道结果会怎么样，以我现在的知识，估计也去不了，还得继续加油努力呢！路漫漫其修远兮，吾将上下而求索！]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（五）再看 JVM 的类加载机制]]></title>
    <url>%2F2018%2F04%2F09%2F%EF%BC%88%E4%BA%94%EF%BC%89%E5%86%8D%E7%9C%8B-JVM-%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[你的努力终将会有回报，路漫漫其修远兮，吾将上下而求索！ 前言在这篇中，我们再谈 JVM 的编译常量、ClassLoader 、和系统类加载器。通过代码实例来理解掌握三者的奥秘。请带上你的好奇心哦~ 编译常量和变量与初始化关于static和final变量对类的初始化到底有什么影响，他们的使用也是面试中经常的考点。首先来看一道程序： example1 1234567891011121314package stormwangxhu.example;class FianlTest&#123; //x是一个编译时常量 public static final int x =6/3; static &#123; System.out.println("FinalTest static block"); &#125;&#125;public class StaticAndFinalTest &#123; public static void main(String[] args) &#123; System.out.println(FianlTest.x);// x=2。static代码块没有执行。 &#125;&#125; example2 123456789101112131415161718package stormwangxhu.example;import java.util.Random;class FianlTest2&#123; //注意此处，x是编译时变量，即在运行时才能确定x的值。 public static final int x = new Random().nextInt(100);//产生一个0到99的随机数 static &#123; System.out.println("FinalTest2 static block"); &#125;&#125;public class StaticAndFianlTest2 &#123; public static void main(String[] args) &#123; System.out.println(FianlTest2.x); //FinalTest2 static block 先执行static代码块 //43(每次执行不一样) 后执行编译变量 &#125;&#125; 那么，程序的输出是不是出乎你的意料呢，当static和final 修饰的是一个编译时常量时，那么其在初始化阶段就已经确定。所以其初始化将按顺序进行初始化。而对于编译时变量，在初始化阶段并不能确定其具体的值，所以初始化阶段会先初始化类变量，再在程序运行期间进行编译变量的执行。 再看类初始化初始化子类在第一篇博文中我很清楚自己这样写道：当Java 虚拟机初始化一个类时，要求其父类必须先被初始化，但是这条规则不适用于接口。那么对于这句话我们来看一个实例： 123456789101112131415161718192021222324package stormwangxhu.example;class Parent&#123; static int a =3 ; static &#123; System.out.println("Parent static block"); &#125;&#125;class Child extends Parent&#123; static int b =4 ; static &#123; System.out.println("Child static block"); &#125;&#125;public class StaticTest1 &#123; static &#123; System.out.println("StaticTest1 static block"); &#125; public static void main(String[] args) &#123; System.out.println(Child.b); &#125;&#125; 那么这道题的答案是多少呢？若你理解了那句话，答案会很快知晓： 1234StaticTest1 static blockParent static blockChild static block4 还有，当一个类的父类被同一个加载器加载过后，便不会再去加载这个类。 1234567891011121314151617181920212223242526package stormwangxhu.example;class Parent&#123; static int a =3 ; static &#123; System.out.println("Parent static block"); &#125;&#125;class Child extends Parent&#123; static int b =4 ; static &#123; System.out.println("Child static block"); &#125;&#125;public class StaticTest1 &#123; static &#123; System.out.println("StaticTest1 static block"); &#125; public static void main(String[] args) &#123; System.out.println("-----------------------------------------"); System.out.println(Parent.a); System.out.println(Child.b); &#125;&#125; 那么，这样又会输出什么呢？ 123456StaticTest1 static block-----------------------------------------Parent static block3Child static block4 为什么会输出这样呢？因为同一个类加载器对加载过的父类若已经加载过，则不再进行加载。但是若是两个不同的类加载器则依旧会执行。 因此我们得出结论：程序中对子类的主动使用，会导致父类被初始化；但对父类的主动使用并不会导致子类初始化。一个最简单明了的例子就是：不可能说生成一个Object 对象就导致系统中所有子类都会被初始化。 再谈类的主动使用首先我们说明结论：只有当程序访问的静态变量或静态方法确实在当前类或当前接口中定义时，才可以认为是对类或接口的主动使用。 什么意思呢？我们来看代码： 12345678910111213141516171819202122232425262728293031package stormwangxhu.example;class Parent&#123; //静态变量 static int a =3 ; static &#123; System.out.println("Parent static block"); &#125; //静态方法 static void doSomething()&#123; System.out.println("do something"); &#125;&#125;class Child extends Parent&#123; static int b =4 ; static &#123; System.out.println("Child static block"); &#125;&#125;public class StaticTest1 &#123; static &#123; System.out.println("StaticTest1 static block"); &#125; public static void main(String[] args) &#123; System.out.println(Child.a); Child.doSomething(); &#125;&#125; 来看结果： 1234StaticTest1 static blockParent static block3do something 从结果可以看出，根本就没执行Child ，也就意外根本没有初始化。我们再来理解给出的结论，类变量a 它是在类中定义的，静态方法doSometing() 也是在父类中定义的，所以用子类打印出a 的值，就不是对子类的一个主动使用，而是对父类的一个主动使用。 再谈类加载ClassLoader结论：调用ClassLoader类的loadClass方法加载一个类，并不是对类的主动使用，不会导致类的初始化。 1234567891011121314151617181920package stormwangxhu.example;class CL&#123; static &#123; System.out.println("Class CL"); &#125;&#125;public class ClassLoaderTest1 &#123; public static void main(String[] args) &#123; ClassLoader classLoader=ClassLoader.getSystemClassLoader(); try &#123; Class&lt;?&gt; clazz=classLoader.loadClass("stormwangxhu.example.CL");//不会导致初始化 System.out.println("------------------------------------"); clazz=Class.forName("stormwangxhu.example.CL");//反射，会导致类的初始化 &#125; catch (ClassNotFoundException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 再看结果： 12------------------------------------Class CL 也就是主动使用除了6种情况下会导致类的主动使用而被初始化，其他的都不会导致类的初始化。 深解双亲委托机制 根类加载器该加载器无父类加载器，实现依赖于底层操作系统，属于虚拟机的一部分，并没有继承java.lang.ClassLoader 。负责加载虚拟机的核心类库，如java.lang.*等。 拓展类加载器加载拓展API 系统类加载器加载CLASSPATH路径下定义的Class。 ClassLoader加载流程所以一个程序启动时，是怎么加载的呢？我们一起来看看： 当运行一个Java程序的时候，JVM 启动，运行启动类加载器，该加载器（ClassLoader）加载核心的API（拓展类加载器和系统类加载器也在此时被加载），然后调用拓展类加载器加载拓展API，最后系统类加载器加载CLASSPATH目录下定义的Class。以上就是一个程序最基本的加载流程。 再看代码： 12345678910111213141516171819202122protected synchronized Class loadClass(String name ,boolean resolve)&#123; //首先检查该name指定的class是否被加载 Class c=findLoadedClass(name); if (c==null)&#123;//c为空，说明该类没有被加载过 try &#123; if (parent!=null)&#123; //若parent不为null，则调用parent的loadClass进行加载 c=parent.laodClass(name,false); &#125;else &#123; //parent为null，则调用启动类加载器进行加载 c=findBootstarpClass0(name); &#125; &#125;catch (ClassNotFoundException e)&#123; //若仍然无法加载成功，则调用自身的findClass进行加载 c=findClass(name); &#125; &#125; if (resolve)&#123; resolveClass(c); &#125; return c; &#125; 以上可以看出一个类的加载使用了双亲委托模式。 为什么要使用双亲委托模型我们为什么要使用双亲委托模型呢？记得阿里第一面就问我，我当时表达不出来。 原因一：可以避免重复加载，当父类已经加载了该类的时候，就没有必要子ClassLoader 再加载一次 原因二：考虑到安全因素，若不使用这种委托模式，那么可以随时用自定义得String 来动态替代Java核心API 中定义的类型，这样会存在非常大的隐患，而父类委托的方式就可以避免这种情况，因为String 已经在启动时被加载，所以， 用户自定义是无法加载一个自定义的ClassLoader ClassLoader一些重要方法loadClass方法ClassLoader.loadClass() 是ClassLoader 的入口点。定义如下： 1Class loadClass(String name,boolean resolve); 1、name 是JVM需要的类的名称，如：java.lang.Object 。 2、resolve 参数告诉方法是否需要解析类。在准备执行该类前，应该考虑解析。注意：并不总是需要解析，如果JVM只需要知道该类是否存在或找出该类的超类，那就不需要解析。 findClass方法loadClass 默认实现调用这个新方法。findClass的用途包含ClassLoader 的所有特殊代码，而不须复制其他代码（例如：当专门的方法失败时，调用系统的ClassLoader） 目的是：从本地文件系统使用实现的类加载器加载一个类。为了创建自己的类加载器，应该拓展ClassLoader类，这是一个抽象类。可以创建一个FileClassLoader extends ClassLoader，然后覆盖ClassLoader中的findClass(String name)方法，这个方法通过类名得到一个Class对象。 1234public Class findClass()&#123; byte[] date =loadClassData(name); return defineClass(name,data,0,data.length);&#125; defineClass方法defineClass方法接受由原始字节组成的数组，并把它转换成Class对象。原始数组包含从文件系统或网络装入的数据。defineClass管理JVM的许多复杂的实现层面——它把字节码分析成运行时数据结构。检验有效行等。因为defineClass方法被标记为final，所以不能覆盖它。 forName方法Class类中有一个静态方forName，这个方法和ClassLoader中的loadClass方法目的一样，都是用来加载class的，但是两者在作用上有所区别。 先来看看看forName()方法： 1Class clazz = Class.forName("something"); 或者： 12ClassLoader c1 =Thread.currentThread().getContextClassLoader();Class clazz= c1.loadClass("something"); Class.forName()调用Class.forName(name,initialize,loader); 也就是Class.forName(&quot;something&quot;) 等同于Class.forName(&quot;something&quot;,true,CALLCLASS.class.getClassLoader()); 。 解释： 第二个参数”true”，用于设置加载类时是否连接该类，即加载中的连接阶段，true就连接，否则就不连接。 再看看loadClass()方法： loadClass方法定义是protected，也就是说，该方法是被保护的，而用户使用的方法是一个参数，一个参数的loadClass方法实际上就时调用了两个参数，第二个参数默认是false。因此，在这里可以看出通过loadClass加载类实际上就是加载的时候并不对该类解析 因此不会初始化该类。而Class的forName方法则相反，使用forName加载的时候就会将Class进行解析和初始化。 你知道JVM 使用什么字符吗？答案是：Unicode characters java开发者必须牢记：在java中字符只以一种形式存在，那就是Unicode（不选则任何特定的编码，直接使用它们在字符集中的编号，这就是统一的唯一的方式）。 那么“在java中”到底是指哪里呢？是指在JVM中、在内存中、在我们写的代码里声明的每一个char、String类型的变量中。 JVM 这种的约定使得一个字符分为两部分：JVM 内部和OS 的文件系统。在JVM 内部，统一使用Unicode表示，当这个字符被从JVM 内部移动到外部（即保存为文件系统中的一个文件内容时），就进行了编码转换，使用了具体的编码方案。因此可以说，所有的编码转换只发生在边界的地方，JVM 和 OS的交界处，也就是各种输入/输出流（或者Reader，Writer类）起作用的地方。 Windows中默认字符是GBK，在面向字符流时，Reader和Writer只会使用这个默认的编码来转换，而不能为一个Reader和Writer指定转换时使用的编码。这意外着，若使用中文版Windows系统，其中存放了一个UTF-8编码的文件，当采用Reader类读入的时候，他还会使用GBK来转换，转换后内容当然不对！所以在需要GBK以外的编码时，就必须采用编码转换：一个字符与字节之间的转换。因此I/O系统中能够指定转换编码的地方，也就是字符和字节转换的地方。那就是InputStreamReader 和OutputStreamWriter。这两个类是字节流和字符流之间的适配器，他们承担着编码转换的地方。]]></content>
      <categories>
        <category>深入理解Java虚拟机</category>
      </categories>
      <tags>
        <tag>JVM 类加载机制</tag>
        <tag>ClassLoader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（四）初探 JVM 垃圾收集器和内存分配策略]]></title>
    <url>%2F2018%2F04%2F08%2F%EF%BC%88%E5%9B%9B%EF%BC%89%E5%88%9D%E6%8E%A2-JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[你的努力终将会有回报，路漫漫其修远兮，吾将上下而求索！ 前言 Java 与 C++ 之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人想出来。 本篇博文主要输出JVM的常见垃圾回收算法（也就是面试官长问到的GC），以及在 JVM 虚拟机中，JVM 是如何判断对象的有效性、对象在内存中是按照什么规则存放的，请带上你的好奇心慢慢往下读。 在JVM内存区域中，属于线程私有的程序计数器、虚拟机栈和本地方法栈这个3个区域随着线程而生而死。栈中的栈帧随着方法的进入和退出而有条不紊的执行着出栈和入栈操作。每一个栈帧要分配多少内存基本在类结构基本确定下来时已经确定。因此这几个区域的内存分配和回收都具有确定性，无需过多考虑回收问题，因为方法或者线程结束时，内存自然就跟着回收了。 其实，我们关心的是JVM 中的线程共享数据区：Java 堆和方法区。这部分的内存分配和回收都是动态的，而垃圾收集器所关注的就是这部分内存。那么在这两个区域中，JVM 是如何进行内存分配和回收的呢？我也很好奇~。 我们先看堆中，再看方法区！ 我们知道，在Java堆中，存放着Java世界几乎所有的对象实例，垃圾回收器在对堆进行回收之前，第一件事情就是需要知道这些对象“死”还是“活”着，如何知道，JVM 使用引用计数法、可达性分析算法进行判断。 看”堆”中判断对象生死法宝首先，无论是现在要说的引用计数算法，还是后文的可达性分析算法，都和对象的引用有关，该算法的目标对象就是引用。说该算法前，就不得不说引用了。 再谈引用其实，判定对象的存活都与引用有关，在Jdk 1.2 之后，Java对引用扩充如下：分位强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）。这4种引用强度依次逐渐减弱。 强引用：程序代码中普遍存在的引用，只要该引用存在，垃圾收集器永远不会回收掉被引用的对象。 1Object obj=new Object(); 软引用：描述有用但非必需的对象。对于软引用关联着的对象，在系统将要发生OOM异常之前，将会把这些对象列进回收范围之中进行第二次回收，如果这次回收后还没有足够的内存，才会抛出OOM异常。 弱引用：是用来描述非必须对象的，强度比软引用更弱，被弱引用关联的对象只能生存到下一次GC发生之前。当垃圾回收器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。 虚引用：也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。 引用计数算法什么是引用计数法？很多人这样说到：每一个对象中都添加一个引用计数器，当该引用被一个地方引用一次，就+1；引用失效时，就-1。当计数器为0时，说明该对象不可能再被使用。 客观说，引用计数算法，实现简单、效率高，大部分情况下很不错，如微软COM技术等在应用。但Java虚拟机里却没有选用该算法，最主要原因是：很难解决对象之间相互循环引用问题。即两个引用引用着对方的实例对象。 可达性分析算法主流程序语言：Java、C# 都使用可达性分析算法来判断对象是否存活。这就很牛逼了，到底是什么样的算法，竟然被Java用来判断对象是否存活了。 可达性分析算法基本思路：通过一系列的称为GC Roots 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链 （Reference Chain）,当一个对象到GC Roots 没有任何引用链相连（即GC Roots到这个对象不可达）时，则证明此对象是不可用的； 从下图来看：对象object5,6,7虽然相互关联，但是他们到GC Roots是不可达的，所以它们将会被判定为是可回收对象。 那么，可作为GC Roots对象有哪些？一般从栈和方法区去思考： 栈： 虚拟机栈（栈帧中的本地变量表）中引用对象。 本地方法栈中JNI（一般来说的Native方法）引用的对象。 方法区： 类静态属性引用的对象。 常量引用的对象。 再来对比看一下，熟记他们。下图所示： 以上就是堆中关于JVM判断对象是否存活的两个算法，和我说一遍：引用计数算法——可达性分析算法。 再看”方法区”垃圾收集方法区中垃圾回收对象主要为两个：废弃常量和无用的类。 废弃常量与堆中回收对象非常类似（简单）。但判断是否无用类即比较苛刻。 判定一个类是否是无用的类条件相对苛刻： 该类所有实例都已被回收，即Java堆中不存在该类的任何实例； 加载该类的ClassLoader已经被回收； 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该方法。 在方法区中进行垃圾收集的性价比一般比较低；而在Heap中，尤其是在新生代，常规应用进行一次垃圾收集一般回收70%~95%的空间，而永久代的垃圾收集效率远低于此； 常见GC算法你了解吗垃圾收集算法实现设计大量细节，各个平台操作虚拟机内存方法不一样，所以只说算法思想。 标记-清除 算法如同其名字一样，该算法（最基础收集算法）分两步：标记——&gt;清除。 标记：标记的是什么？其实标记的是所有需要回收对象。 清除：清除什么？清除上一步被标记的需要回收对象。 从上图可以看出：被标记的对象被清除了。但也发现了两个不足：效率问题、空间问题。 效率问题：标记、清除连个过程效率都不高。 空间问题：清除后产生大量不连续内存碎片。如若分配较大对象时，则无法找到足够连续内存而不得不提前触发另外一次垃圾回收动作。 复制 算法为了解决 标记-清除 算法带来的效率问题，复制算法应用而生。 算法思想：将可用内存按容量划分为大小相等两块，每次只使用其中一块。 复制：复制什么？一块内存用完后，复制其中存活对象到另一块。复制存活~复制存活~复制存活~ 优点：每次对整个半区进行回收，内存分配时不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效； 不足：提高效率的代价是将内存缩小到原来的一半。 现代商业虚拟机都采用这种收集算法来回收新生代。HotSpot虚拟机将内存划分为Eden 和2个Survivor 空间，比例8:1:1。每次只是用Eden 和一个Survivor 空间。回收时，将Eden 和Survivor 中还存活对象复制到另外一块Survivor 空间中。当Survivor 空间不足时，需要依赖其他内存（老年代）进行分配担保（Handle Promotion），让对象进入老年代。分配担保机制后文中会说到。 标记-整理 算法标记整理算法，也是一样，分2个过程。标记——整理 标记：标记什么？标记需要被回收对象。 整理：此处不像清除，将其清除掉，而是让所有存活对象都向一端移动，然后清理掉端边界以外内存。 所以，标记清除算法和标记整理算法可以比较吗？试试： 分代收集 算法分代收集算法并没有什么心思想，只是根据对向存活周期不同，将内存划分为几块。一般讲 Java 堆分为新生代和老年代。 新生代和老年代有什么特点呢？ 新生代：对象大批会死去，少量存活。 老年代：对象存活率高。因此对于新生代和老年代特点可采用不同回收算法。 新生代：复制算法。复制少量存活对象 老年代：标记-清理 或 标记-整理 算法。标记需回收对象。 如果你有耐心读到此处，恭喜你，已经从理论层面了解了3个垃圾回收算法。我们一起回顾一下其名称： 标记-清除 算法，复制 算法，标记-整理 算法。 那么接下来，在知道了垃圾回收算法后，就要从应用层面去了解垃圾回收算法的应用 （垃圾回收器）。所以，一起看看常见垃圾收集器有什么？:kissing: 常见垃圾收集器异同你说上来吗 如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。此次讨论Jdk 7之后 HotSpot 虚拟机包含的几个收集器。 Serial 收集器 新生代收集器，使用停止复制算法，使用一个线程进行GC，串行，其它工作线程暂停。 使用-XX:+UseSerialGC可以使用Serial+Serial Old模式运行进行内存回收（这也是虚拟机在Client模式下运行的默认值） ​ ​ ParNew 收集器 新生代收集器，使用停止复制算法，Serial收集器的多线程版，用多个线程进行GC，并行，其它工作线程暂停，关注缩短垃圾收集时间。 使用-XX:+UseParNewGC开关来控制使用ParNew+Serial Old收集器组合收集内存；使用-XX:ParallelGCThreads来设置执行内存回收的线程数。 Parallel Scavenge 收集器 新生代收集器，使用停止复制算法，关注CPU吞吐量，即运行用户代码的时间/总时间，比如：JVM运行100分钟，其中运行用户代码99分钟，垃圾收集1分钟，则吞吐量是99%， 这种收集器能最高效率的利用CPU，适合运行后台运算（关注缩短垃圾收集时间的收集器，如CMS，等待时间很少，所以适 合用户交互，提高用户体验）。 使用-XX:+UseParallelGC开关控制使用Parallel Scavenge+Serial Old收集器组合回收垃圾（这也是在Server模式下的默认值）； 使用-XX:GCTimeRatio来设置用户执行时间占总时间的比例，默认99，即1%的时间用来进行垃圾回收。 使用-XX:MaxGCPauseMillis设置GC的最大停顿时间（这个参数只对Parallel Scavenge有效）， 用开关参数-XX:+UseAdaptiveSizePolicy可以进行动态控制，如自动调整Eden/Survivor比例，老年代对象年龄，新生代大小等，这个参数在ParNew下没有。 Serial Old 收集器 老年代收集器，单线程收集器，串行， 使用标记整理（整理的方法是Sweep（清理）和Compact（压缩），清理是将废弃的对象干掉，只留幸存的对象，压缩是将移动对象，将空间填满保证内存分为2块，一块全是对象，一块空闲）算法， 使用单线程进行GC，其它工作线程暂停（注意，在老年代中进行标记整理算法清理，也需要暂停其它线程）， 在JDK1.5之前，Serial Old收集器与ParallelScavenge搭配使用。 CMS 收集器 老年代收集器，致力于获取最短回收停顿时间（即缩短垃圾回收的时间），使用标记清除算法，多线程，优点是并发收集（用户线程可以和GC线程同时工作），停顿小。 使用-XX:+UseConcMarkSweepGC进行ParNew+CMS+Serial Old进行内存回收， 优先使用ParNew+CMS，当用户线程内存不足时，采用备用方案Serial Old收集。 CMS收集的执行过程是：初始标记(CMS-initial-mark) -&gt; 并发标记(CMS-concurrent-mark) –&gt;预清理(CMS-concurrent-preclean)–&gt;可控预清理(CMS-concurrent-abortable-preclean)-&gt; 重新标记(CMS-remark) -&gt; 并发清除(CMS-concurrent-sweep) -&gt;并发重设状态等待下次CMS的触发(CMS-concurrent-reset) 在CMS清理过程中，只有初始标记和重新标记需要短暂停顿，并发标记和并发清除都不需要暂停用户线程，因此效率很高，很适合高交互的场合。 CMS也有缺点，它需要消耗额外的CPU和内存资源，在CPU和内存资源紧张，CPU较少时，会加重系统负担（CMS默认启动线程数为(CPU数量+3)/4）。 在并发收集过程中，用户线程仍然在运行，仍然产生内存垃圾，所以可能产生“浮动垃圾”，本次无法清理，只能下一次Full GC才清理，因此在GC期间，需要预留足够的内存给用户线程使用。 使用CMS的收集器并不是老年代满了才触发Full GC，而是在使用了一大半（默认68%，即2/3，使用-XX:CMSInitiatingOccupancyFraction来设置）的时候就要进行Full GC，如果用户线程消耗内存不是特别大，可以适当调高-XX:CMSInitiatingOccupancyFraction以降低GC次数，提高性能，如果预留的用户线程内存不够，则会触发Concurrent Mode Failure，此时，将触发备用方案：使用Serial Old 收集器进行收集，但这样停顿时间就长了，因此-XX:CMSInitiatingOccupancyFraction不宜设的过大。 CMS采用的是标记清除算法，会导致内存碎片的产生，可以使用-XX：+UseCMSCompactAtFullCollection来设置是否在Full GC之后进行碎片整理，用-XX：CMSFullGCsBeforeCompaction来设置在执行多少次不压缩的Full GC之后，来一次带压缩的Full GC。 G1 收集器G1 收集器是一款面向服务器端应用的垃圾收集器，计划未来替代CMS收集器。相比其他GC收集器，G1 具备如下特点： 并行与并发：能充分利用多CPU、多核环境下的硬件优势； 可以并行来缩短”Stop The World”停顿时间； 也可以并发让垃圾收集与用户程序同时进行； ​分代收集：收集范围包括新生代和老年代 ， 能独立管理整个GC堆（新生代和老年代），而不需要与其他收集器搭配；能够采用不同方式处理不同时期的对象； 虽然保留分代概念，但Java堆的内存布局有很大差别； 将整个堆划分为多个大小相等的独立区域（Region）； 新生代和老年代不再是物理隔离，它们都是一部分Region（不需要连续）的集合。 空间整合：结合多种垃圾收集算法，空间整合，不产生碎片。从整体看，是基于标记-整理算法； ​ 从局部（两个Region间）看，是基于复制算法； 这是一种类似火车算法的实现； 都不会产生内存碎片，有利于长时间运行； ​可预测的停顿：低停顿的同时实现高吞吐量， G1除了追求低停顿处，还能建立可预测的停顿时间模型； 可以明确指定M毫秒时间片内，垃圾收集消耗的时间不超过N毫秒； ​ G1 收集器运作大致可划分为如下几个步骤： 初始标记 并发标记 最终标记 筛选回收 应用场景：面向服务端应用，针对具有大内存、多处理器的机器；最主要的应用是为需要低GC延迟，并具有大堆的应用程序提供解决方案；如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒； 在下面的情况时，使用G1可能比CMS好：​ （1）、超过50％的Java堆被活动数据占用；​ （2）、对象分配频率或年代提升频率变化很大；​ （3）、GC停顿时间过长（长于0.5至1秒）。​ 是否一定采用G1呢？也未必：​ 如果现在采用的收集器没有出现问题，不用急着去选择G1；如果应用程序追求低停顿，可以尝试选择G1； 是否代替CMS需要实际场景测试才知道。 内存分配与回收策略你知道吗Java 体系中所提倡的自动内存管理最终可以总结为自动化解决两个问题： 给对象分配内存以及回收分配给对象的内存。 内存回收上面已经讲述，下面一起看看关于对象分配内存的那点事儿。 对象的内存分配，大方向说，就是往堆上分配，对象主要分配到1新生代的Eden区上，若启动本地线程分配缓冲，将按线程优先在TLAB 上分配。少数情况下也可能会直接分配到老年代中。 对象优先在Eden分配大多数情况下，对象在新生代Eden区中分配。当Eden区中没有足够空间进行分配时，虚拟机将进行一次Minor GC。 此处，我们先来了解一下常说的 Minor GC 和 Full GC 有什么不一样吗？ 新生代GC （Minor GC：速度快）：指发生在新生代的垃圾收集动作，因Java 对象大多数都具备招生夕灭特性，所以Minor GC 会非常频繁，一般回收速度也比较快。 老年代GC （Major GC/Full GC：速度慢）：指发生在老年代的GC ，出现了 Major GC，经常会伴随至少一次的Minor GC（但非绝对），Major GC 速度一般比Minor GC 慢10倍以上。 大对象直接进入老年代大对象，大对象，什么标准才是大对象？大对象是指：需要大量连续内存空间的Java对象。最典型大对象是：很长的字符串和数组。大对象对虚拟机来说是一个坏消息，因为出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够连续空间“安置”他们。 长期存活的对象将进入老年代虚拟机给每个对象定义了一个对象年龄计数器。那么对象的年龄是怎么计算的呢？ 计算方法：对象在Eden 出生并经过第一次Minor GC后仍然存活，并且能被Survivor 容纳的话，并被移动到Survivor 空间中，则对象年龄设置为1.对象每在Survivor “熬过” 一次Minor GC，年龄+1岁，当他年龄增加到一定程度（默认15岁），就会晋升到老年代中。 动态对象年龄判定如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。关于这句话的理解，请多读两遍就理解了~~~。 空间分配担保在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC,尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC. 总结哇哦，读到此处，是不是有点儿心累，其实我也心累，但相比于此处你获得的知识，是不是感觉一下又阳光明媚了。我们在此处再闭眼回想一下，我们学到的东西： （1）理论层面： 判断对象死活算法：引用计数算法——-可达性分析算法。 垃圾收集算法：标记-清除 算法、复制 算法、标记-整理 算法。 （2）应用层面： 垃圾收集器：balabalabala~~~~。相信你已经知道了。 （3）对象进入内寸分配策略： 首先：Eden区优先 然后：大对象去哪儿？——直接进入老年代。 最后：长期存活对象去哪儿？——先长大到默认年龄15岁，再进入老年代。 到此，我们的学习就结束了，在博文中出现的错误或疑问，欢迎和我交流。 GitHub]]></content>
      <categories>
        <category>深入理解Java虚拟机</category>
      </categories>
      <tags>
        <tag>GC</tag>
        <tag>JVM 垃圾收集器</tag>
        <tag>内存分配策略</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（三）初探 Java 的内存模型]]></title>
    <url>%2F2018%2F04%2F07%2F%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%9D%E6%8E%A2-Java-%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[你的努力终将会有回报，路漫漫其修远兮，吾将上下而求索！ 前言上一篇博文中叙述了JVM的内存区域，而与之相似的是Java内存模型。其实JVM与JMM两者之间并不是同一个层次的划分，这两者基本是没有关系的。 但硬要说出点关系，则从变量、主内存、工作内存定义看，对应关系如下： 主内存 ——-&gt; Java堆中对象实例数据部分 工作内存 ——–&gt; 虚拟机栈中部分区域 从更低层次说，对应关系如下： 主内存 ——-&gt; 物理硬件内存 工作内存 ——–&gt; 优先存储于寄存器和高速缓存中（程序运行时主要访问读写的是工作内存） 计算机硬件效率与一致性 ​ 处理器、高速缓存、主内存之间关系 Java 内存模型Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model,JMM）来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。在此之前，主流程序语言（如C/C++等）直接使用物理硬件和操作系统的内存模型，因此，会由于不同平台上内存模型的差异，有可能导致程序在一套平台上并发完全正常，而在另外一套平台上并发访问却经常出错，因此在某些场景就必须针对不同的平台来编写程序。 定义Java内存模型并非一件容易的事情，这个模型必须定义得足够严谨，才能让Java的并发内存访问操作不会产生歧义；但是，也必须定义得足够宽松，使得虚拟机的实现有足够的自由空间去利用硬件的各种特性（寄存器、高速缓存和指令集中某些特有的指令）来获取更好的执行速度。经过长时间的验证和修补，在JDK 1.5（实现了JSR-133[2]）发布后，Java内存模型已经成熟和完善起来了。 主内存和工作内存Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量（Variables）与Java编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。为了获得较好的执行效能，Java内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器进行调整代码执行顺序这类优化措施。 Java内存模型规定了所有的变量都存储在主内存（Main Memory）中（此处的主内存与介绍物理硬件时的主内存名字一样，两者也可以互相类比，但此处仅是虚拟机内存的一部分）。每条线程还有自己的工作内存（Working Memory，可与前面讲的处理器高速缓存类比），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的交互关系如图所示： ​ 线程、主内存、工作内存三者的交互关系 内存间交互操作关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了以下8种操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许有例外，这个问题后文会讲）。 lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。 unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。 read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。 load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。 use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。 assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。 write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。 如果要把一个变量从主内存复制到工作内存，那就要顺序地执行read和load操作。 如果要把变量从工作内存同步回主内存，就要顺序地执行store和write操作。 注意，Java内存模型只要求上述两个操作必须按顺序执行，而没有保证是连续执行。也就是说，read与load之间、store与write之间是可插入其他指令的，如对主内存中的变量a、b进行访问时，一种可能出现顺序是read a、read b、load b、load a。除此之外，Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则： 不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。 不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。 不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。 一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说，就是对一个变量实施use、store操作之前，必须先执行过了assign和load操作。 一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。 如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量。 对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）。 这8种内存访问操作以及上述规则限定，再加上稍后介绍的对volatile的一些特殊规定，就已经完全确定了Java程序中哪些内存访问操作在并发下是安全的。由于这种定义相当严谨但又十分烦琐，实践起来很麻烦，所以在后文将介绍这种定义的一个等效判断原则——先行发生原则，用来确定一个访问在并发环境下是否安全。 注：基于理解难度和严谨性考虑，最新的JSR-133文档中，已经放弃采用这8种操作去定义Java内存模型的访问协议了（仅是描述方式改变了，Java内存模型并没有改变）。 对于volatile型变量的特殊规则关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制，但是它并不容易完全被正确、完整地理解，以至于许多程序员都习惯不去使用它，遇到需要处理多线程数据竞争问题的时候一律使用 synchronized来进行同步。了解volatile变量的语义对后面了解多线程操作的其他特性很有意义，在本节中我们将多花费一些时间去弄清楚volatile的语义到底是什么。 Java内存模型对volatile专门定义了一些特殊的访问规则，在介绍这些比较拗口的规则定义之前，先用不那么正式但通俗易懂的语言来介绍一下这个关键字的作用。 当一个变量定义为volatile之后，它将具备两种特性 （可见性、禁止指令重排序）。 （1）、保证此变量对所有线程的可见性。 这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量不能做到这一点，普通变量的值在线程间传递均需要通过主内存来完成，例如，线程A修改一个普通变量的值，然后向主内存进行回写，另外一条线程B在线程A回写完成了之后再从主内存进行读取操作，新变量值才会对线程B可见。 关于volatile变量的可见性，经常会被开发人员误解，认为以下描述成立：“volatile变量对所有线程是立即可见的，对volatile变量所有的写操作都能立刻反应到其他线程之中，换句话说，volatile变量在各个线程中是一致的，所以基于volatile变量的运算在并发下是安全的”。这句话的论据部分并没有错，但是其论据并不能得出“基于volatile变量的运算在并发下是安全的”这个结论。volatile变量在各个线程的工作内存中不存在一致性问题（在各个线程的工作内存中，volatile变量也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题），但是Java里面的运算并非原子操作，导致volatile变量的运算在并发下一样是不安全的，我们可以通过一段简单的演示来说明原因。 12345678910111213141516171819202122232425262728293031public class VolatileTest &#123; public static volatile int race = 0; public static void increase() &#123; race++; &#125; private static final int THREADS_COUNT = 20; public static void main(String[] args) &#123; Thread[] threads = new Thread[THREADS_COUNT]; for (int i = 0; i &lt; THREADS_COUNT; i++) &#123; threads[i] = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10000; i++) &#123; increase(); &#125; &#125; &#125;); threads[i].start(); &#125; // 等待所有累加线程都结束 while (Thread.activeCount() &gt; 1) Thread.yield(); System.out.println(race); &#125;&#125; 这段代码发起了20个线程，每个线程对race变量进行10000次自增操作，如果这段代码能够正确并发的话，最后输出的结果应该是200000。读者运行完这段代码之后，并不会获得期望的结果，而且会发现每次运行程序，输出的结果都不一样，都是一个小于200000的数字，这是为什么呢？ 问题就出现在自增运算race++ 之中，我们用Javap反编译这段代码后会得到代码，发现只有一行代码的increase（） 方法在Class文件中是由4条字节码指令构成的（return指令不是由race++产生的，这条指令可以不计算），从字节码层面上很容易就分析出并发失败的原因了：当getstatic 指令把race的值取到操作栈顶时，volatile关键字保证了race的值在此时是正确的，但是在执行iconst_1、iadd这些指令的时候，其他线程可能已经把race的值加大了，而在操作栈顶的值就变成了过期的数据，所以putstatic 指令执行后就可能把较小的race值同步回主内存之中。 1234567891011public static void increase（）；Code：Stack=2，Locals=0，Args_size=00：getstatic#13；//Field race：I3：iconst_14：iadd5：putstatic#13；//Field race：I8：returnLineNumberTable：line 14：0line 15：8 客观地说，笔者在此使用字节码来分析并发问题，仍然是不严谨的，因为即使编译出来只有一条字节码指令，也并不意味执行这条指令就是一个原子操作。一条字节码指令在解释执行时，解释器将要运行许多行代码才能实现它的语义，如果是编译执行，一条字节码指令也可能转化成若干条本地机器码指令，此处使用-XX：+PrintAssembly参数输出反汇编来分析会更加严谨一些，但考虑到读者阅读的方便，并且字节码已经能说明问题，所以此处使用字节码来分析。 由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁（使用synchronized或java.util.concurrent中的原子类）来保证原子性。 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。 变量不需要与其他的状态变量共同参与不变约束。 而在像如下的代码清单所示的这类场景就很适合使用volatile变量来控制并发，当shutdown（）方法被调用时，能保证所有线程中执行的doWork（）方法都立即停下来。 123456789volatile boolean shutdownRequested；public void shutdown（）&#123; shutdownRequested=true；&#125;public void doWork（）&#123; while（！shutdownRequested）&#123; //do stuff &#125;&#125; 注：上面这段话到底怎样理解呢？我是这样理解的：其实，Java 内存模型通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖于主内存作为传递媒介方式实现可见性。即volitile关键字保证可见性是通过以主内存为媒介进行传递的。 （2）、禁止指令重排序优化。 普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。因为在一个线程的方法执行过程中无法感知到这点，这也就是Java内存模型中描述的所谓的“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics）。 上面的描述仍然不太容易理解，我们还是继续通过一个例子来看看为何指令重排序会干扰程序的并发执行，演示程序如代码清单: 1234567891011121314151617Map configOptions；char[]configText；//此变量必须定义为volatilevolatile boolean initialized=false；//假设以下代码在线程A中执行//模拟读取配置信息，当读取完成后将initialized设置为true以通知其他线程配置可用configOptions=new HashMap（）；configText=readConfigFile（fileName）；processConfigOptions（configText,configOptions）；initialized=true；//假设以下代码在线程B中执行//等待initialized为true，代表线程A已经把配置信息初始化完成while（！initialized）&#123; sleep（）；&#125;//使用线程A中初始化好的配置信息doSomethingWithConfig（）； 上述程序是一段伪代码，其中描述的场景十分常见，只是我们在处理配置文件时一般不会出现并发而已。如果定义initialized 变量时没有使用volatile修饰，就可能会由于指令重排序的优化，导致位于线程A中最后一句的代码initialized=true” 被提前执行（这里虽然使用Java作为伪代码，但所指的重排序优化是机器级的优化操作，提前执行是指这句话对应的汇编代码被提前执行），这样在线程B中使用配置信息的代码就可能出现错误，而volatile关键字则可以避免此类情况的发生。 指令重排序是并发编程中最容易让开发人员产生疑惑的地方，除了上面伪代码的例子之外，笔者再举一个可以实际操作运行的例子来分析volatile关键字是如何禁止指令重排序优化的。 12345678910111213141516171819public class Singleton &#123; private volatile static Singleton instance; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125; public static void main(String[] args) &#123; Singleton.getInstance(); &#125;&#125; 编译后，这段代码对instance变量赋值部分如代码清单 1234567890x01a3de0f：mov$0x3375cdb0，%esi ；……beb0cd75 33 ；&#123;oop（'Singleton'）&#125;0x01a3de14：mov%eax，0x150（%esi） ；……89865001 00000x01a3de1a：shr$0x9，%esi ；……c1ee090x01a3de1d：movb$0x0，0x1104800（%esi） ；……c6860048 1001000x01a3de24：lock addl$0x0，（%esp） ；……f0830424 00 ；*putstatic instance ；-Singleton：getInstance@24 通过对比就会发现，关键变化在于有volatile修饰的变量，赋值后（前面mov%eax，0x150（%esi）这句便是赋值操作）多执行了一个lock addl ＄0x0，（%esp） 操作，这个操作相当于一个内存屏障（Memory Barrier或Memory Fence，指重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；但如果有两个或更多CPU访问同一块内存，且其中有一个在观测另一个，就需要内存屏障来保证一致性了。这句指令中的addl ＄0x0，（%esp） （把ESP寄存器的值加0）显然是一个空操作（采用这个空操作而不是空操作指令nop是因为IA32手册规定lock 前缀不允许配合nop指令使用），关键在于lock前缀，查询IA32手册，它的作用是所以通过这样一个空操作，可让前面volatile变量的修改对其他CPU立即可见。 那为何说它禁止指令重排序呢？从硬件架构上讲，指令重排序是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理。但并不是说指令任意重排，CPU需要能正确处理指令依赖情况以保障程序能得出正确的执行结果。譬如指令1把地址A中的值加10，指令2把地址A中的值乘以2，指令3把地址B中的值减去3，这时指令1和指令2是有依赖的，它们之间的顺序不能重排——（A+10）2与A2+10显然不相等，但指令3可以重排到指令1、2之前或者中间，只要保证CPU执行后面依赖到A、B值的操作时能获取到正确的A和B值即可。所以在本内CPU中，重排序看起来依然是有序的。因此，lock addl＄0x0，（%esp） 指令把修改同步到内存时，意味着所有之前的操作都已经执行完成，这样便形成了“指令重排序无法越过内存屏障”的效果。 解决了volatile的语义问题，再来看看在众多保障并发安全的工具中选用volatile的意义——它能让我们的代码比使用其他的同步工具更快吗？在某些情况下，volatile的同步机制的性能确实要优于锁（使用synchronized关键字或java.util.concurrent包里面的锁），但是由于虚拟机对锁实行的许多消除和优化，使得我们很难量化地认为volatile就会比synchronized快多少。 如果让volatile自己与自己比较，那可以确定一个原则：volatile变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能会慢一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。不过即便如此，大多数场景下volatile的总开销仍然要比锁低，我们在volatile与锁之中选择的唯一依据仅仅是volatile的语义能否满足使用场景的需求。 注：上面这段话又怎样理解？volitile关键字它也有使用场景，它的读操作相比于普通变量无区别。但写操作会慢，因为它需要插入许多内存屏障禁止指令重排序。 注：volatile屏蔽指令重排序的语义在JDK 1.5中才被完全修复，此前的JDK中即使将变量声明为volatile也仍然不能完全避免重排序所导致的问题（主要是volatile变量前后的代码仍然存在重排序问题），这点也是在JDK 1.5之前的Java中无法安全地使用DCL（双锁检测）来实现单例模式的原因。 对于 long 和 double 型变量的特殊规则Java 内存模型对64位数据类型（long 和 double） ：允许虚拟机将没有被volitile关键字修饰的64位数据类型读写操作分两次32位操作来进行。这就是所谓的long和double的非原子性协定 。 再看 Java 内存模型的3个特征 原子性 可见性 有序性 原子性Java 内存模型中尽管虚拟机未把lock和unlock操作直接开放给用户使用，但是却提供更高层次字节码指令monitorenter 和 monitorexit 来隐式使用，这两个字节码指令反应到java代码就是—–synchronized关键字，因此在synchronized块之间的操作也具有原子性。 可见性什么是可见性？即一个线程修改了共享变量值，其他线程能够立即得知这个修改。 如何实现？当然是通过volitile 关键字保证新值能立即同步到主内存，以及每次使用前立即从主内存刷新。这也是volitile 变量与普通变量的区别所在！ 还有2个关键字能实现可见性：synchronized 和 final 。 实现机制又是怎样的？简单总结： （1） synchronized （同步块的可见性）：对一个变量进行unlock（多线程操作共享变量，每个线程须lock，unlock该变量。）操作之前，必须先把此变量同步回主内存中（执行store 、write 操作）。 （2） final ：被final 关键字修饰的字段在构造器中一旦初始化完成，且没有把 this 引用传递出去，那么其他线程就能看见final 字段的值。 有序性Java 内存模型有序性 在前面讲解volitile关键字已详细讲解。Java 中天然的有序性可以总结为一句话：如果在本地线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。 前半句指：线程内表现为串行的语义。后半句指：”指令重排序“现象和”工作内存和主内存同步延迟“现象。 Java 语言用volitile和synchronized两个关键字保证线程之间操作有序性。volitile 关键字本身就包含了禁止指令重排序语义，而synchronized则是由“一个变量在同一时刻只允许一条线程对其进行lock操作”这条规则获得。 介绍完3种特性后是不是发现，synchronized关键字是“万能”的。但是越“万能”的并发控制，通常会伴随着越大的性能影响。在后续博文会说。 总结前面说了这么多，就以下内容： 1、Java 内存模型是怎样的一个工作原理？ 2、内存间是怎么样交互进行信息传递的？ 3、volitile 关键字到底是如何保证一个共享变量的可见性、又如何做到禁止指令重排序，从而保证代码在多线程条件下顺序执行？ 基于以上三个问题，我们做了长篇幅的解释，大体原理可说明说下：1、Java 内存模型原理： 2、共享变量通过以主内存作为媒介，在多线程间进行交互。 3、 （1） 保证可见性：lock 前缀，将使得本CPU的Cache（高速缓存）写入了内存，该写入动作也会引起别的CPU或者别的内核 无效化 （Invalidate）其Cache，这种操作相当于对Cache中的变量做了一次前面介绍Java内存模式中所说的“store和write”操作。 （2）、禁止指令重排序：增加内存屏障。（lock前缀 ）]]></content>
      <categories>
        <category>深入理解Java虚拟机</category>
      </categories>
      <tags>
        <tag>Java 内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（二）初探 JVM 的内存结构]]></title>
    <url>%2F2018%2F04%2F06%2F%EF%BC%88%E4%BA%8C%EF%BC%89%E5%88%9D%E6%8E%A2-JVM-%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[@Date:2018/04/05 @Author: StormWangxhu 你的努力终将会有回报，路漫漫其修远兮，吾将上下而求索！ 前言 Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人想出来。 本文也将参考周志明老师的书《深入理解Java虚拟机》，在概念上初探JVM的内存结构的各个区域，讲解这些区域的作用、服务对象以及其中可能产生的问题，这是翻越虚拟机内存管理这堵围墙的第一步。 得到首先先仰起头来整体看一下JVM内存结构的宏观图： 然后再看以线程私有和共享区分: 完了就具体来看看各个内存区域的作用。 程序计数器程序技术器（Program Counter Register）是一块较小的内存空间，他可以看做是当前线程所执行的字节码的行号指示器。 由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各个线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 程序计数器不同场景下记录的命令： 线程执行Java方法时：记录正在执行虚拟机字节码指令地址。 线程执行Native方法：计数器值为空（Undefined）。 此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError 情况的区域。 Java虚拟机栈与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。 虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行时都会创建一个栈帧（Stack Frame），用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。单线程下有错误时会抛出StackOverFlowError ，多线程下会抛出OutOfMemoryError 。 那么栈帧所存储的局部变量表、操作数栈、动态链接、方法出口信息等具体是什么意思： 局部变量表: 局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量，其中存放的数据的类型是编译期可知的各种基本数据类型、对象引用(reference)和(returnAddress)类型（它指向了一条字节码指令的地址）。局部变量表所需的内存空间在编译期间完成计算的，即在Java程序被编译成Class文件时，就确定了所需分配的最大局部变量表的容量。当进入一个方法时，这个方法需要在栈中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。 操作数栈: 操作数栈又常被称为操作栈，操作数栈的最大深度也是在编译的时候就确定了。32位数据类型所占的栈容量为1, 64位数据类型所占的栈容量为2。当一个方法开始执行时，它的操作栈是空的，在方法的执行过程中，会有各种字节码指令（比如：加操作、赋值元算等）向操作栈中写入和提取内容，也就是入栈和出栈操作。Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈。因此我们也称Java虚拟机是基于栈的，这点不同于Android虚拟机，Android虚拟机是基于寄存器的。基于栈的指令集最主要的优点是可移植性强，主要的缺点是执行速度相对会慢些；而由于寄存器由硬件直接提供，所以基于寄存器指令集最主要的优点是执行速度快，主要的缺点是可移植性差 动态链接: 每个栈帧都包含一个指向运行时常量池（在方法区中，后面介绍）中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。Class 文件的常量池中存在有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用，一部分会在类加载阶段或第一次使用的时候转化为直接引用（如 final、static 域等），称为静态解析，另一部分将在每一次的运行期间转化为直接引用，这部分称为动态连接。 方法返回地址: 当一个方法被执行后，有两种方式退出该方法：执行引擎遇到了任意一个方法返回的字节码指令或遇到了异常，并且该异常没有在方法体内得到处理。无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行。方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者的PC计数器的值就可以作为返回地址，栈帧中很可能保存了这个计数器值，而方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息。方法退出的过程实际上等同于把当前栈帧出站，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，如果有返回值，则把它压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令。 在Java虚拟机规范中，对这个区域规定了两种异常情况：若线程请求栈深度大于虚拟机所允许的深度，将抛出StackOverFlowError ；若虚拟机可以动态拓展，若拓展时无法申请到足够的内存，就会抛出OutOfMemoryError 异常。 本地方法栈本地方法栈（Native Method Stack）与虚拟机所发挥的作用是非常相似的，他们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。 与虚拟机栈一样，本地方法栈也会抛出StackOverFlowError 和OutOfMemoryError 异常。 Java堆Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块区域，由虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。但随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配。标量替换优化技术将会导致一些微妙的变化发生，所有对象都分配到堆上也渐渐变的不是那么”绝对“了。 Java堆是垃圾收集器管理的主要区域，很多时候也被叫做Java“GC堆”（Garbage Collected Heap）。 从内存回角度来看，由于现在收集器基本采用分代收集算法，所以Java堆又细分为：新生代、老年代。 再细致一点有：Eden空间、From Survivor空间、To Survivor空间等。 从内存分配角度来看，线程共享的Java堆可划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer,TLAB）。不过无论如何划分，无论哪个区域，存储的都是对象实例，进一步划分目的是为了更好回收内存，或更快分配内存。具体分配我在后面文章再具体详说。 Java虚拟机规范规定：Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，如我们磁盘空间一样。 Meta-Area 这块区域也是线程共享的区域，它主要存储jvm加载类的类信息，类变量，常量(这个在meta-area的常量区)，即时编译器编译后的代码等数据。 运行时常量区 这个区域是Meta-Area的一部分，用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。 来看一个实例： 123public void test() &#123; Object obj = new Object();&#125; 对于这段代码会涉及Vm Stack、Java Heap、Meta-Area三个最重要的内存区域。 结合我们前面的例子，因为test()方法涉及到Vm Stack区，我想你应该明白，obj会存放在局部变量表中，new Object()，我们前面说过我们大部分的对象都会存储在Java Heap这个区域，所以，Java Heap存储了这个实例对象！那么你会很好奇，Meta-Area为啥会涉及到呢？ 我们知道Meta-Area存储了类的信息，类变量常量等等东西！因为我们实例化Object对应的时候，要用到Object这个类的信息，所以它会访问Meta-Area的Object.class这个Class对象来获得一些实例化对象需要的东西。 对了，作为补充，我想你还需要知道, obj引用怎么你能访问到Java Heap区的那个实例化对象 有两种方式，一种使用过句柄指针(学过c/c++对这些概念应该会很熟悉) 下图来自《深入理解Java虚拟机》一书。 还有一种就是通过指针直接访问: 方法区方法区与Java堆一样，是各个线程共享的内存区域，他用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机把Java堆描述为堆逻辑的一部分，但是它有一个别名，叫做Non-Heap（非堆），目的该是与Java堆区分开来。 方法区，很多人又愿意叫做“永久代”，Java虚拟机对方法区的限制非常宽松，除了和Java堆一样，不需要连续的内存和可以选择固定大小或者可拓展外，还可以选择不实现垃圾收集。相对而言，垃圾收集在这块区域是比较少出现，但并非数据进入方法区就如永久代名字一样“永久”存在了。 Java虚拟机规范，当方法区无法满足内存分配需求时，将抛出OutOfMemoyError 异常。 运行时常量池运行时常量池是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载进入方法区的运行时常量池中存放。 总结依旧来总结一下这方面的面试题： JVM运行内存分类 程序计数器：当前线程所执行的字节码的行号指示器，用于记录下一条要运行的指令，线程私有 注：如果正在执行的是Native方法，计数器值则为空 Java虚拟栈：存放基本数据类型、对象的引用、方法出口等，线程私有 Native方法栈：和虚拟栈相似，只不过它服务于Native方法，线程私有 Java堆：java内存最大的一块，所有对象实例、数组都存放在java堆，GC回收的地方，线程共享 方法区：存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码数据等。（即永久带），回收目标主要是常量池的回收和类型的卸载，各线程共享 Java内存堆栈的区别 栈内存用来存储基本类型的变量和对象的引用变量，堆内存用来存储Java中的对象，无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中 栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存，堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问 如果栈内存没有可用的空间存储方法调用和局部变量，JVM会抛出java.lang.StackOverFlowError，如果是堆内存没有可用的空间存储生成的对象，JVM会抛出java.lang.OutOfMemoryError 栈的内存要远远小于堆内存，如果你使用递归的话，那么你的栈很快就会充满，-Xss选项设置栈内存的大小。-Xms选项可以设置堆的开始时的大小。 Java的四个引用 强引用（StrongReference） 强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题 软引用（SoftReference） ​如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，软引用可以和一个引 用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中 弱引用（WeakReference） ​弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中 虚引用（PhantomReference） 虚引用在任何时候都可能被垃圾回收器回收，主要用来跟踪对象被垃圾回收器回收的活动，被回收时会收到一个系统通知。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中 结尾 图来自bryan学长总结，其中Java内存模型应改为JVM内存区域。已向博主反应！ 概念上初探JVM的内存结构的各个区域，本文达到了开头所说的目的。如若有什么错误或疑问，欢迎指正！]]></content>
      <categories>
        <category>深入理解Java虚拟机</category>
      </categories>
      <tags>
        <tag>JVM 内存结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（一）一道题看清 JVM 的类加载机制]]></title>
    <url>%2F2018%2F04%2F05%2F%EF%BC%88%E4%B8%80%EF%BC%89%E4%B8%80%E9%81%93%E9%A2%98%E7%9C%8B%E6%B8%85-JVM-%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[你的努力终将会有回报，路漫漫其修远兮，吾将上下而求索！ 前言首先，我说的是一道题要看清JVM的类加载机制，所以，我们得先有题呀，一起来看一道经典的面试题： 123456789101112131415161718192021222324252627282930313233343536373839404142class Singleton&#123; private static Singleton singleton = new Singleton(); public static int value1; public static int value2 = 0; private Singleton()&#123; value1++; value2++; &#125; public static Singleton getInstance()&#123; return singleton; &#125; public static void main(String[] args) &#123; //注意此处位置 Singleton singleton = Singleton.getInstance(); System.out.println("Singleton1 value1:" + singleton.value1); System.out.println("Singleton1 value2:" + singleton.value2); Singleton2 singleton2 = Singleton2.getInstance2(); System.out.println("Singleton2 value1:" + singleton2.value1); System.out.println("Singleton2 value2:" + singleton2.value2); &#125;&#125;class Singleton2&#123; public static int value1; public static int value2 = 0; //注意此处位置 private static Singleton2 singleton2 = new Singleton2(); private Singleton2()&#123; value1++; value2++; &#125; public static Singleton2 getInstance2()&#123; return singleton2; &#125;&#125; 这道题，看似没有什么差别，但其实，差之毫厘谬以千里，结果会完全不同，但结果究竟是怎么样的呢？我现在还暂时不能告诉你，除非你自己在编译器上运行一下。跟着我一起来看看JVM的类加载机制吧，看完后，你一定会自己说出正确的答案，而且理解其所以然，真真的一道题看清JVM的来世今生！来吧！ 类加载的过程概念虚拟机把描述类的数据文件（字节码）加载到内存，并对数据进行验证、准备、解析以及类初始化，最终形成可以被虚拟机直接使用的java类型（java.lang.Class对象） 类的生命周期关于类的生命周期，请记住这句话：加载–&gt;连接–&gt;初始化。 一个类从出生到卸载完会经历以下的生命周期： 类从被加载到虚拟机内存中开始，到卸载为止，整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）、卸载（UnLoading）7个阶段。其中，验证、准备、解析三个阶段又统称为连接（Linking）。可总结为：加载、连接、初始化！ 下面看看这7个过程中（5个阶段）虚拟机进行了哪些动作？ 加载阶段通过一个类的全限定名来获取定义此类的二进制字节流，将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。在内存中(方法区)生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口； 上面这句话是什么意思呢？其实很简单，就是将一个.class 文件通过类加载器，加载到内存中，在方法区保存其类的数据结构，然后在堆中创建该类的对象。该对象又作为访问方法区中该类数据结构（即各种数据）的访问入口。即访问入口是该对象。 即：查找并加载类的二进制数据文件。 连接阶段 验证： 为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，文件格式验证、元数据验证、字节码验证、符号引用验证 即：确保被加载类的正确性 准备： 正式为类变量（即static修饰的变量，包括静态代码块）分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配 即：为类的静态变量分配内存，并将其初始化为默认值 解析： 虚拟机将常量池内的符号引用替换为直接引用的过程。符号引用是二进制数据中引用，直接引用相当于运行期间的指针，指向方法区内存位置。 即：把类的符号引用转换为直接引用 初始化阶段类初始化阶段是类加载过程的最后一步。前面的类加载过程中，除了在加载阶段用户可以使用自定义的类加载器参与外，其余动作完全由虚拟机主导和控制！初始化阶段就是执行类构造器()方法的过程。到了初始化阶段，才真正开始执行类中定义的Java代码（或者说是字节码）！ 静态变量初始化有两种路径： （1）、在静态变量声明处初始化。 （2）、在静态代码块中初始化。 使用阶段开始使用类。 卸载阶段使用完后，卸载类。 关于类加载加载主要是将.class 文件（并不一定是.class。可以是ZIP包，网络中获取）中的二进制字节流读入到JVM中。 其中获取.class 文件主要有以下几种方式： ZIP jar（这也是为什么我们在开发中可以使用别人的jar包原因，也是常见加载.class 文件方式） 网络下载 类加载需要完成的三件事情：在加载阶段，JVM需要完成3件事：经历过程如下： 即获取字节流——&gt;方法区——-&gt;Java堆中。 通过类的全限定名获取该类的二进制字节流（即包名+类名）； 将字节流所代表的静态存储结构转化为方法区的运行时数据结构（即将类的数据结构存储于方法区中）； 在堆中生成一个该类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。 注：何时会触发类的加载过程，Java虚拟机规范中并没有进行强制约束，而是交给虚拟机的具体实现来自由把握。即然知道了类加载需要完成三件事情，接下来就得知道类加载器是干什么的了。 类加载器虚拟机设计团队把类的加载阶段中的“通过一个类的全限定名来获取此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己去决定如何获取所需要的类而实现这个动作的模块称为“类加载器”。 类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类的加载阶段。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。更通俗的说，也就是：即使两个类来源于同一个Class文件，只要加载它们的类加载器不同，那这两个类就必定不相等。这里的“相等”包括了代表类的Class对象的equals()、isAssignableFrom()、isInstance()等方法的返回结果，也包括了使用instanceof关键字对对象所属关系的判定结果。 下面我们用代码来解释一下： 1234567891011121314151617181920212223242526272829303132333435363738394041package stormwangxhu.example;import java.io.IOException;import java.io.InputStream;/** * @author stormwangxhu * @date 2018/04/06 */public class ClassLoaderTest &#123; public static void main(String[] args) &#123; ClassLoader myClassLoader = new ClassLoader() &#123; @Override public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123; try &#123; String filename = name.substring(name.lastIndexOf(".") + 1) + ".class"; InputStream inputStream = getClass().getResourceAsStream(filename); if (inputStream == null) &#123; return super.loadClass(name); &#125; byte[] bytes = new byte[inputStream.available()]; inputStream.read(bytes); return defineClass(name, bytes, 0, bytes.length); &#125; catch (Exception e) &#123; throw new ClassNotFoundException(name); &#125; &#125; &#125;; try &#123; Object object=myClassLoader.loadClass("stormwangxhu.example.ClassLoaderTest").newInstance(); System.out.println(object.getClass());//class stormwangxhu.example.ClassLoaderTest System.out.println(object instanceof stormwangxhu.example.ClassLoaderTest);//false &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 我们解释一下上述结果产生的原因： 因为虚拟机种存在了两个ClassLoaderTest的类，一个由系统应用程序类加载器加载的，另外一个是由我们自定义的类加载器加载的，虽然都来自同一个Class文件，但依然是两个独立的类，做对象所属类型检查时结果自然返回false。 若从JVM的角度来看，类加载器可以分为： 启动类加载器(Bootstrap ClassLoader，它负责加载存放在$JAVA_HOME/jre/lib下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如 rt.jar）。启动类加载器是无法被Java程序直接引用的。很容易可以验证，执行System.out.println(String.class.getClassLoader())打印结果为null) 扩展类加载器(Extension ClassLoader, 该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载$JAVA_HOME/jre/lib/ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库(如javax.*开头的类)，开发者可以直接使用扩展类加载器。在jdk1.9中类加载器有所变化！1.9中jdk.internal.loader.ClassLoaders$PlatformClassLoader，称为平台类加载器) 应用程序加载器（系统应用程序类加载器）(Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径ClassPath所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。注意在jdk1.9中，应用程序加载器由jdk.internal.loader.ClassLoaders$AppClassLoader实现) 我们的应用程序都是由这3种类加载器相互配合进行加载的，若有必要，可以加入我们自己定义的类加载器。其中 启动类加载器是由C++语言编写的，其他两个由Java编写。 这些类加载器之间的关系又引出双亲委托机制。 借此机会，我们来看看什么是双亲委托机制！ 双亲委派模型类加载器之间的关系如图所示： 上图所展示的类加载器之间的层次关系，称为类加载器的双亲委派模型。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承关系来实现，而是都使用组合关系来复用父加载器代码。该模型在JDK1.2期间被引入并广泛应用于之后几乎所有的Java程序中，但它并不是一个强制性的约束模型，而是Java设计者们推荐给开发者的一种类的加载器实现方式。 双亲委派模型工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。 使用双亲委派模型来组织类加载器之间的关系，有一个很明显的好处，就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，这对于保证Java程序的稳定运作很重要。例如：类java.lang.Object类存放在$JAVA_HOME/jre/lib下的rt.jar之中，因此无论是哪个类加载器要加载此类，最终都会委派给启动类加载器进行加载，这便保证了Object类在程序中的各种类加载器中都是同一个类。相反：若没有使用双亲委派魔性，由各个类加载器自行去加载的话，若用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也无法得到保证，应用程序也将会一片混乱。 此处，我们看看ClassLoader 这个抽象类的双亲委派机制的实现了！该代码都集中在java.lang.ClassLoader 的loadClass 方法之中。 12345678910111213141516171819202122232425262728293031323334353637protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; synchronized (getClassLoadingLock(name)) &#123; // First, check if the class has already been loaded，首先，检查请求的类是否已经被加载过了 Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; if (parent != null) &#123; c = parent.loadClass(name, false); &#125; else &#123; c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // 若父加载器抛出ClassNotFoundException，说明父类加载器无法完成加载该类请求 // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; // 在父类加载器无法加载的时候， // 再调用自身的findClass来进行类的加载 // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); c = findClass(name); // this is the defining class loader; record the stats PerfCounter.getParentDelegationTime().addTime(t1 - t0); PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125; &#125; 对照我们上面的测试代码自定义的那个类加载器，如果是实现findClass()而没有实现loadClass()方法，那么加载时候先开始判断它的父类加载器(自定义类加载器的上一级是应用程序类加载器，然后根据双亲委托机制一步一步进行判断加载。最后加载都不成功就会调用findClass()方法来加载，jdk1.2之后官方不提倡实现loadClass()！上面的例子，为了测试两个Class对象不相等，强制实现了loadClass()，因为如果只实现findClass(), 就会被应用类加载器所加载。 注：一般由启动类加载器加载的对象以返回null 来表示该类是由根类加载器加载的。若非根类，则会打印出相关信息。 关于验证验证是连接阶段的第一步，主要确保加载进来的字节流符合JVM规范。虚拟机如果不检查输入的字节流，对齐完全信任的话，很可能会因为载入了有害的字节流而导致系统崩溃，所以验证是虚拟机对自身保护的一项重要工作。验证阶段会完成以下4个阶段的检验动作： 文件格式验证 ：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的三个验证都是基于方法区的存储结构进行的。 元数据验证(是否符合Java语言规范) ：对类的元数据信息进行语义校验（其实就是对类中的各数据类型进行语法校验），保证不存在不符合Java语法规范的元数据信息。 字节码验证（确定程序语义合法，符合逻辑） ：该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。 符号引用验证（确保下一步的解析能正常执行）：这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，后面会有讲解），主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。 ​ 关于准备准备阶段是正式为类变量分配内存并设置初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这个阶段有两个容易混淆的概念，首先，进行内存分配的仅包括类变量(被static修饰的变量)，不包括实例变量，实例变量是在对象实例化的时候分配在Java堆中的。其次这里所说的初始值“通常情况”下是数据类型的零值。 那么问题来了，到底是什么意思呢？其实就是类变量系统为其设置的默认值，而不是程序员通过代码的初始值。 假如我们定义了一个类变量public static int value = 123; 那么，变量value 在准备阶段过后的初始值为0而不是123，因为这时候尚未开始执行任何Java方法，而把value 赋值为123的putstatic 指令是在程序被编译后，存放于类构造器&lt;clinit&gt;() 方法之中，所以把value 赋值为123的动作将在初始化阶段才会执行。 若有个多个静态变量，则依次按顺序分配空间并赋值。 关于各种类型的初始值： 上面说到，在”在通常情况”下初始值为零值，那么相对来说就会有一些“特殊情况”：若类字段的字段属性表中存在ConstantValue 属性，那么在准备阶段变量value 就会被初始化为ConstantValue 属性所指定的值，假设上面类变量定义为： public static final int value=123; 编译时Javac将会为value 生成ConstantValue 属性，在准备阶段虚拟机就会根据ConstantValue 的设置value 赋值为123。 关于解析解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程。在Class类文件结构一文中已经比较过了符号引用和直接引用的区别和关联，这里不再赘述。前面说解析阶段可能开始于初始化之前，也可能在初始化之后开始，虚拟机会根据需要来判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析（初始化之前），还是等到一个符号引用将要被使用前才去解析它（初始化之后）。 类或接口的解析：判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析。 字段解析：对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束。 对于解析和验证这一块，和读懂Class文件有着密不可分的关系，所以这一块的补充知识会在读懂Class文件字节码之后进行讲解！ 关于初始化初始化是类加载过程的最后一步，到了此阶段，才真正开始执行类中定义的Java程序代码。在准备阶段，类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序指定的主观计划去初始化类变量和其他资源。 或者可以从另一个角度来表达：初始化阶段是执行类构造器()方法的过程。 ()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中(static{})的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句中可以赋值，但是不能访问。 ()方法与实例构造器()方法（类的构造函数）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的()方法执行之前，父类的()方法已经执行完毕。因此，在虚拟机中第一个被执行的()方法的类肯定是java.lang.Object。 ()方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成()方法。 接口中不能使用静态语句块，但仍然有类变量（final static）初始化的赋值操作，因此接口与类一样会生成()方法。但是接口鱼类不同的是：执行接口的()方法不需要先执行父接口的()方法，只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的()方法。 虚拟机会保证一个类的()方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的()方法，其他线程都需要阻塞等待，直到活动线程执行()方法完毕。如果在一个类的()方法中有耗时很长的操作，那就可能造成多个线程阻塞，在实际应用中这种阻塞往往是很隐蔽的。 注：上面说了这么多，我们脑海中必须有个概念，类变量从加载到初始化被赋值了几次？读到这里，我们应该清楚的认识到，至此，类变量已经被赋值也只能被赋值两次了。 第一次是：连接阶段的准备，赋予类变量系统初始值。 第二次：初始化阶段，赋予程序员给其赋的值。 这里我们再说一下类变量初始化，类变量初始化时按其顺序执行，什么意思呢？看一段代码： 1234567891011121314package stormwangxhu.example;public class staticTest &#123; static int a=1; static &#123; a=2; &#125; static &#123; a=6; &#125; public static void main(String[] args) &#123; System.out.println("a = "+a); &#125;&#125; 这段代码输出结果会是什么呢？1 ？2？还是6。如果你毅然而然的回答了6，那么恭喜你，你真的很6，答案就是6。其原因就是类变量在准备阶段被赋予初始值后，在初始化阶段按其顺序依次向下执行。 类的初始化步骤 假如这个类还没有被加载和连接，那就先进行加载和连接。 假如类存在志杰的父类，且这个父类还没有被初始化，那就先初始化直接的父类。 假如类中存在初始化语句，那就依次执行这些初始化语句。 那么Java程序对类的使用主要有两种方式，对类的主动使用和被动使用。除了以下几种Java程序主动使用类时需要进行初始化，其余都为被动使用，不会导致类的初始化。 类得初始化时机（主动使用6种） 使用new 创建类的实例； 读取或设置类静态字段的时候（但被final修饰的字段，在编译器时就被放入常量池的静态字段除外static final）。 调用类的静态方法。 反射 Class.forName(“xxxx”)。 初始化一个类的子类。 有父类，先初始化父类（注：1. 接口除外，父接口在调用的时候才会被初始化；2.子类引用父类静态字段，只会引发父类初始化）； 注：当Java 虚拟机初始化一个类时，要求其父类必须先被初始化，但是这条规则不适用于接口。 （1）、在初始化一个类时，并不会 先初始化它所实现得接口。 （2）、在初始化一个接口时，并不会初始化它的父接口。 因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定接口的静态变量时，才会导致该接口的初始化。 被标明为启动类的类（即包含main()方法的类）要初始化； 当使用JDK1.7的动态语言支持时，如果一个java.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。 以上情况称为对一个类进行主动引用，且有且只要以上几种情况（主动使用）需要对类进行初始化。 此处，是时候去解释我们的那道经典面试题了! 面试题答案解析1234567891011121314151617181920212223242526272829303132333435363738394041class Singleton&#123; private static Singleton singleton = new Singleton(); public static int value1; public static int value2 = 0; private Singleton()&#123; value1++; value2++; &#125; public static Singleton getInstance()&#123; return singleton; &#125; public static void main(String[] args) &#123; Singleton singleton = Singleton.getInstance(); System.out.println("Singleton1 value1:" + singleton.value1); System.out.println("Singleton1 value2:" + singleton.value2); Singleton2 singleton2 = Singleton2.getInstance2(); System.out.println("Singleton2 value1:" + singleton2.value1); System.out.println("Singleton2 value2:" + singleton2.value2); &#125;&#125;class Singleton2&#123; public static int value1; public static int value2 = 0; private static Singleton2 singleton2 = new Singleton2(); private Singleton2()&#123; value1++; value2++; &#125; public static Singleton2 getInstance2()&#123; return singleton2; &#125;&#125; Singleton输出结果：1 0 原因： 1 、首先执行main中的Singleton singleton = Singleton.getInstance();2、 类的加载：加载类Singleton3、 类的验证4 、类的准备：为静态变量分配内存，设置默认值。这里为singleton(引用类型)设置为null,value1,value2（基本数据类型）设置默认值05、 类的初始化（按照赋值语句进行修改）：执行private static Singleton singleton = new Singleton();执行Singleton的构造器：value1++;value2++; 此时value1，value2均等于1执行public static int value1;public static int value2 = 0;此时value1=1，value2=0 Singleton2输出结果：1 1 原因： 1、 首先执行main中的Singleton2 singleton2 = Singleton2.getInstance2();2、 类的加载：加载类Singleton23、 类的验证4、 类的准备：为静态变量分配内存，设置默认值。这里为value1,value2（基本数据类型）设置默认值0,singleton2(引用类型)设置为null,5、 类的初始化（按照赋值语句进行修改）：执行public static int value2 = 0;此时value2=0(value1不变，依然是0);执行private static Singleton singleton = new Singleton();执行Singleton2的构造器：value1++;value2++;此时value1，value2均等于1,即为最后结果 总结上面说了这么多，如果你有耐心一句一句读完，相信你已经对JVM类加载机制有了一定的认识，那么在面试中，此处有什么考点呢？继续看总结。 JVM类加载机制常见面试问题类的生命周期加载—&gt;连接—&gt;初始化—&gt;使用—&gt;卸载 Java类加载器启动类加载器（C++）—&gt;拓展类加载器（Java）—&gt;应用程序类加载器（Java）—&gt;自定义类加载器 他们之间的关系为：双亲委托模型 双亲委派模型工作过程 首先会先查找当前ClassLoader是否加载过此类，有就返回； 如果没有，查询父ClassLoader是否已经加载过此类，如果已经加载过,就直接返回Parent加载的类； 如果整个类加载器体系上的ClassLoader都没有加载过，才由当前ClassLoader加载(调用findClass)，整个过程类似循环链表一样。 作用 共享功能，一些Framework层级的类一旦被顶层的ClassLoader加载过就缓存在内存里面，以后任何地方用到都不需要重新加载。 隔离功能，保证java/Android核心类库的纯净和安全，防止恶意加载。 打破双亲委托模型 双亲委派模型的逻辑都在loadClass()中，重写loadClass()，一般是重写findClass()的 系统自带的三个类加载器都加载特定目录下的类，如果我们自己的类加载器放在一个特殊的目录，那么系统的加载器就无法加载，也就是最终还是由我们自己的加载器加载 自定义类加载器方法 loadClass(String name,boolean resolve)：根据指定的二进制名称加载类 findClass(String name)： 根据二进制名称来查找类 直接使用或继承已有的ClassLoader实现：java.net.URLClassLoader、java.security.SecureClassLoader、 java.rmi.server.RMIClassLoader 在调用loadClass()，会先根据委派模型在父加载器中加载，如果加载失败，则会调用自己的findClass方法来完成加载 ​ 引起类加载操作的五个行为 遇到new、getstatic、putstatic或invokestatic这四条字节码指令 反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化 子类初始化的时候，如果其父类还没初始化，则需先触发其父类的初始化 虚拟机执行主类的时候(有 main(string[] args)) JDK1.7 动态语言支持 Java对象创建时机 使用new关键字创建对象 使用Class类的newInstance方法(反射机制) 使用Constructor类的newInstance方法(反射机制) 使用Clone方法创建对象 使用(反)序列化机制创建对象 结尾JVM的类加载机制，要我来说，也可能有的地方讲的不太正确，如若有疑问或建议，还请各位大佬私信：牛客用户（StormWangxhu)。 再次特意推荐大家去读周志明老师的《深入理解Java虚拟机》，确实不错。]]></content>
      <categories>
        <category>深入理解Java虚拟机</category>
      </categories>
      <tags>
        <tag>JVM 类加载机制</tag>
        <tag>ClassLoader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记头条 Java 实习第一面]]></title>
    <url>%2F2018%2F03%2F30%2F30--%E8%AE%B0%E5%A4%B4%E6%9D%A1Java%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[我看好自己的认真！ 人生第一次想要在暑假找一个实习来进行锻炼，奈何心有余力不足，技术学的不扎实，在头条第一面，没考算法的前提下，我顺利的挂了，说起来也是心酸。只好再去学了，我知道面试官只是安慰我，说我还有机会，但我也不会气馁！加油吧，少年！ 1.自我介绍 2.HTTP POST GET 区别(不错) 3.端口的作用(可以) 4.HashMap的实现原理(答得不错)，数据量大的时候查询是否影响效率，查询一个元素的时间复杂度(不行) 5.数据库MySQL索引(不行) 6.前后端数据如何传递 7.Ajax(说了了解过) 8.栈中查找最小元素以及栈结构(不行) 9.冒泡排序时间复杂度(不行) 10.问到了项目图书商城实现了哪些功能，怎么想到要做这个项目的。 11例题，实现一个函数，将一个Map分割出来。 面试总结:基础知识，如常见数据结构知识不够完备，基础知识不扎实。虽然第一面挂了，但是明白了要学习的方面。面试官说，头条里语言不管是哪一门都可以，一些常见的基础知识得掌握，评论我有短期目标，也有长期目标挺不错的。 HTTP 中GET POST请求的区别①get请求用来从服务器上获得资源，而post是用来向服务器提交数据； ②get将表单中数据按照name=value的形式，添加到action 所指向的URL 后面，并且两者使用”?”连接，而各个变量之间使用”&amp;”连接；post是将表单中的数据放在HTTP协议的请求头或消息体中，传递到action所指向URL； ③get传输的数据要受到URL长度限制（1024字节即256个字符）；而post可以传输大量的数据，上传文件通常要使用post方式； ④使用get时参数会显示在地址栏上，如果这些数据不是敏感数据，那么可以使用get；对于敏感数据还是应用使用post； ⑤get使用MIME类型application/x-www-form-urlencoded的URL编码（也叫百分号编码）文本的格式传递参数，保证被传送的参数由遵循规范的文本组成，例如一个空格的编码是”%20”。 补充：GET方式提交表单的典型应用是搜索引擎。GET方式就是被设计为查询用的。]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识 Spring AOP]]></title>
    <url>%2F2018%2F03%2F19%2F19--%E5%88%9D%E8%AF%86-Spring-AOP%2F</url>
    <content type="text"><![CDATA[今天初步学习一下Spring。 Spring AOP使用方式 Spring AOP—&gt;XML—&gt;Pointcut expression Spring AOP—&gt;注解方式—&gt;Pointcut expression 主要学习一下注解方式。 主要注解]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb 请求（request）和响应（response）]]></title>
    <url>%2F2018%2F03%2F01%2F01--JavaWeb-%E8%AF%B7%E6%B1%82%EF%BC%88request%EF%BC%89%E5%92%8C%E5%93%8D%E5%BA%94%EF%BC%88response%EF%BC%89%2F</url>
    <content type="text"><![CDATA[今天来看看关于JavaWeb中关于和请求和响应的知识！ ResponseResponse概述response是Servlet.service方法的一个参数，类型 为javax.servlet.http.HttpServletResponse。在客户端发出每个请求时，服务器都会创建一个response对象，并传入给Servlet.service()方法。response对象是用来对客户端进行响应的，这说明在service()方法中使用response对象可以完成对客户端的响应工作。 response对象的功能分为以下四种： 设置响应头信息； 发送状态码； 设置响应正文； 重定向； Response响应正文response是响应对象，向客户端输出响应正文（响应体）可以使用response的响应流，repsonse一共提供了两个响应流对象： PrintWriter out = response.getWriter()：获取字符流； ServletOutputStream out = response.getOutputStream()：获取字节流； 当然，如果响应正文内容为字符，那么使用response.getWriter()，如果响应内容是字节，例如下载时，那么可以使用response.getOutputStream()。 注意，在一个请求中，不能同时使用这两个流！也就是说，要么你使用repsonse.getWriter()，要么使用response.getOutputStream()，但不能同时使用这两个流。不然会抛出IllegalStateException异常。 字符响应流 字符编码 在使用response.getWriter()时需要注意默认字符编码为ISO-8859-1，如果希望设置字符流的字符编码为utf-8，可以使用response.setCharaceterEncoding(“utf-8”)来设置。这样可以保证输出给客户端的字符都是使用UTF-8编码的！ 但客户端浏览器并不知道响应数据是什么编码的！如果希望通知客户端使用UTF-8来解读响应数据，那么还是使用response.setContentType(“text/html;charset=utf-8”)方法比较好，因为这个方法不只会调用response.setCharaceterEncoding(“utf-8”)，还会设置content-type响应头，客户端浏览器会使用content-type头来解读响应数据。 缓冲区 response.getWriter()是PrintWriter类型，所以它有缓冲区，缓冲区的默认大小为8KB。也就是说，在响应数据没有输出8KB之前，数据都是存放在缓冲区中，而不会立刻发送到客户端。当Servlet执行结束后，服务器才会去刷新流，使缓冲区中的数据发送到客户端。 如果希望响应数据马上发送给客户端： 向流中写入大于8KB的数据； 调用response.flushBuffer()方法来手动刷新缓冲区； 设置响应头信息可以使用response对象的setHeader()方法来设置响应头！使用该方法设置的响应头最终会发送给客户端浏览器！ response.setHeader(“content-type”, “text/html;charset=utf-8”)：设置content-type响应头，该头的作用是告诉浏览器响应内容为html类型，编码为utf-8。而且同时会设置response的字符流编码为utf-8，即response.setCharaceterEncoding(“utf-8”)； response.setHeader(“Refresh”,”5; URL=http://www.baidu.com&quot;)：5秒后自动跳转到百度主页。 设置状态码及其他方法 response.setContentType(“text/html;charset=utf-8”)：等同与调用response.setHeader(“content-type”, “text/html;charset=utf-8”)； response.setCharacterEncoding(“utf-8”)：设置字符响应流的字符编码为utf-8； response.setStatus(200)：设置状态码； response.sendError(404, “您要查找的资源不存在”)：当发送错误状态码时，Tomcat会跳转到固定的错误页面去，但可以显示错误信息。 重定向什么是重定向当你访问http://www.sun.com时，你会发现浏览器地址栏中的URL会变成http://www.oracle.com/us/sun/index.htm，这就是重定向了。重定向是服务器通知浏览器去访问另一个地址，即再发出另一个请求。 完成重定向响应码为200表示响应成功，而响应码为302表示重定向。所以完成重定向的第一步就是设置响应码为302。因为重定向是通知浏览器再第二个请求，所以浏览器需要知道第二个请求的URL，所以完成重定向的第二步是设置Location头，指定第二个请求的URL地址。 1234567public class AServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setStatus(302);//设置响应码为302，表示重定向 response.setHeader("Location", "http://www.baidu.com");//设置新请求的URL &#125;&#125; 上面代码的作用是：当访问AServlet后，会通知浏览器重定向到传智主页。客户端浏览器解析到响应码为302后，就知道服务器让它重定向，所以它会马上获取响应头Location，然发出第二个请求。 便捷的重定向方式123456public class AServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.sendRedirect("http://www.itcast.cn"); &#125;&#125; response.sendRedirect()方法会设置响应头为302，以设置Location响应头。如果要重定向的URL是在同一个服务器内，那么可以使用相对路径，例如： 123456public class AServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.sendRedirect("/hello/BServlet"); &#125;&#125; 重定向的URL地址为：http://localhost:8080/hello/BServlet。 重定向小结 重定向是两次请求； 重定向的URL可以是其他应用，不局限于当前应用； 重定向的响应头为302，并且必须要有Location响应头； 重定向就不要再使用response.getWriter()或response.getOutputStream()输出数据，不然可能会出现异常； RequestRequest概述request是Servlet.service()方法的一个参数，类型为javax.servlet.http.HttpServletRequest。在客户端发出每个请求时，服务器都会创建一个request对象，并把请求数据封装到request中，然后在调用Servlet.service()方法时传递给service()方法，这说明在service()方法中可以通过request对象来获取请求数据。 request的功能可以分为以下几种： 封装了请求头数据； 封装了请求正文数据，如果是GET请求，那么就没有正文； request是一个域对象，可以把它当成Map来添加获取数据； request提供了请求转发和请求包含功能。 Request域方法request是域对象！在JavaWeb中一共四个域对象，其中ServletContext就是域对象，它在整个应用中只创建一个ServletContext对象。request其中一个，request可以在一个请求中共享数据。一个请求会创建一个request对象，如果在一个请求中经历了多个Servlet，那么多个Servlet就可以使用request来共享数据。现在我们还不知道如何在一个请求中经历之个Servlet，后面在学习请求转发和请求包含后就知道了。下面是request的域方法： void setAttribute(String name, Object value)：用来存储一个对象，也可以称之为存储一个域属性，例如：servletContext.setAttribute(“xxx”, “XXX”)，在request中保存了一个域属性，域属性名称为xxx，域属性的值为XXX。请注意，如果多次调用该方法，并且使用相同的name，那么会覆盖上一次的值，这一特性与Map相同； Object getAttribute(String name)：用来获取request中的数据，当前在获取之前需要先去存储才行，例如：String value = (String)request.getAttribute(“xxx”);，获取名为xxx的域属性； void removeAttribute(String name)：用来移除request中的域属性，如果参数name指定的域属性不存在，那么本方法什么都不做； Enumeration getAttributeNames()：获取所有域属性的名称； Resquest域获取请求头数据request与请求头相关的方法有： String getHeader(String name)：获取指定名称的请求头； Enumeration getHeaderNames()：获取所有请求头名称； int getIntHeader(String name)：获取值为int类型的请求头。 Request获取请求相关的其他方法equest中还提供了与请求相关的其他方法，有些方法是为了我们更加便捷的方法请求头数据而设计，有些是与请求URL相关的方法。 l int getContentLength()：获取请求体的字节数，GET请求没有请求体，没有请求体返回-1； l String getContentType()：获取请求类型，如果请求是GET，那么这个方法返回null；如果是POST请求，那么默认为application/x-www-form-urlencoded，表示请求体内容使用了URL编码； l String getMethod()：返回请求方法，例如：GET l Locale getLocale()：返回当前客户端浏览器的Locale。java.util.Locale表示国家和言语，这个东西在国际化中很有用； l String getCharacterEncoding()：获取请求编码，如果没有setCharacterEncoding()，那么返回null，表示使用ISO-8859-1编码； l void setCharacterEncoding(String code)：设置请求编码，只对请求体有效！注意，对于GET而言，没有请求体！！！所以此方法只能对POST请求中的参数有效！ String getContextPath()：返回上下文路径，例如：/hello String getQueryString()：返回请求URL中的参数，例如：name=zhangSan String getRequestURI()：返回请求URI路径，例如：/hello/oneServlet StringBuffer getRequestURL()：返回请求URL路径，例如：http://localhost/hello/oneServlet，即返回除了参数以外的路径信息； String getServletPath()：返回Servlet路径，例如：/oneServlet String getRemoteAddr()：返回当前客户端的IP地址； String getRemoteHost()：返回当前客户端的主机名，但这个方法的实现还是获取IP地址； String getScheme()：返回请求协议，例如：http； String getServerName()：返回主机名，例如：localhost int getServerPort()：返回服务器端口号，例如：8080 12345678910111213141516System.out.println("request.getContentLength(): " + request.getContentLength());System.out.println("request.getContentType(): " + request.getContentType());System.out.println("request.getContextPath(): " + request.getContextPath());System.out.println("request.getMethod(): " + request.getMethod());System.out.println("request.getLocale(): " + request.getLocale()); System.out.println("request.getQueryString(): " + request.getQueryString());System.out.println("request.getRequestURI(): " + request.getRequestURI());System.out.println("request.getRequestURL(): " + request.getRequestURL());System.out.println("request.getServletPath(): " + request.getServletPath());System.out.println("request.getRemoteAddr(): " + request.getRemoteAddr());System.out.println("request.getRemoteHost(): " + request.getRemoteHost());System.out.println("request.getRemotePort(): " + request.getRemotePort());System.out.println("request.getScheme(): " + request.getScheme());System.out.println("request.getServerName(): " + request.getServerName());System.out.println("request.getServerPort(): " + request.getServerPort()); 案例：4.1 案例：request.getRemoteAddr()：封IP可以使用request.getRemoteAddr()方法获取客户端的IP地址，然后判断IP是否为禁用IP。 1234567String ip = request.getRemoteAddr(); System.out.println(ip); if(ip.equals("127.0.0.1")) &#123; response. getWriter().print("您的IP已被禁止！"); &#125; else &#123; response.getWriter().print("Hello!"); &#125; Request获取请求参数最为常见的客户端传递参数方式有两种： 浏览器地址栏直接输入：一定是GET请求； 超链接：一定是GET请求； 表单：可以是GET，也可以是POST，这取决与的method属性值； GET请求和POST请求的区别： GET请求： ** 请求参数会在浏览器的地址栏中显示，所以不安全； ** 请求参数长度限制长度在1K之内； ** GET请求没有请求体，无法通过request.setCharacterEncoding()来设置参数的编码； POST请求： ** 请求参数不会显示浏览器的地址栏，相对安全； ** 请求参数长度没有限制； 下面是使用request获取请求参数的API： String getParameter(String name)：通过指定名称获取参数值； 1234567891011121314public void doGet[点击超链接是GET请求，所以会执行doGet()方法](HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String v1 = request.getParameter("p1"); String v2 = request.getParameter("p2"); System.out.println("p1=" + v1); System.out.println("p2=" + v2); &#125; public void doPost[提交表单是POST请求，所以会调用doPost()方法](HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String v1 = request.getParameter("p1"); String v2 = request.getParameter("p2"); System.out.println("p1=" + v1); System.out.println("p2=" + v2); String[] getParameterValues(String name)：当多个参数名称相同时，可以使用方法来获取； 123456&lt;a href="/hello/ParamServlet?name=zhangSan&amp;name=liSi[多个名为name的参数]"&gt;超链接&lt;/a&gt; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String[] names = request.getParameterValues("name");//获取所有名为name的参数值 System.out.println(Arrays.toString(names));//打印数组，输出结果为：[zhangSan, liSi]] &#125; Enumeration getParameterNames()：获取所有参数的名字。 123456789101112 &lt;form action="/hello/ParamServlet" method="post"&gt; 参数1：&lt;input type="text" name="p1"/&gt;&lt;br/&gt; 参数2：&lt;input type="text" name="p2"/&gt;&lt;br/&gt; &lt;input type="submit" value="提交"/&gt; &lt;/form&gt;public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; Enumeration names = request.getParameterNames()[获取所有参数名称，输出结果为：p1和p2]; while(names.hasMoreElements()) &#123; System.out.println(names.nextElement()); &#125;&#125; Map getParameterMap()：获取所有参数封装到Map中，其中key为参数名，value为参数值，因为一个参数名称可能有多个值，所以参数值是String[]，而不是String。 12345678&lt;a href="/day05_1/ParamServlet?p1=v1&amp;p1=vv1&amp;p2=v2&amp;p2=vv2"&gt;超链接&lt;/a&gt; Map&lt;String,String[]&gt; paramMap = request.getParameterMap(); for(String name : paramMap.keySet()) &#123; String[] values = paramMap.get(name); System.out.println(name + ": " + Arrays.toString(values)); &#125;p2: [v2, vv2]p1: [v1, vv1] 请求转发和请求包含无论是请求转发还是请求包含，都表示由多个Servlet共同来处理一个请求。例如Servlet1来处理请求，然后Servlet1又转发给Servlet2来继续处理这个请求。 请求转发在AServlet中，把请求转发到BServlet： 12345678910111213141516 public class AServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println("AServlet"); RequestDispatcher rd = request.getRequestDispatcher("/BServlet");//获取“调度器”，其中参数为BServlet绑定的URL，即BServlet的&lt;url-pattern&gt;值。] rd.forward(request, response)//调用“调度器”的转发方法，该方法等同与告诉服务器，去调用BServlet的service()方法一样。]; &#125;&#125;public class BServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println("BServlet"); &#125;&#125;AservletBServlet 请求包含在AServlet中，把请求包含到BServlet： 12345678910111213141516public class AServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println("AServlet"); RequestDispatcher rd = request.getRequestDispatcher("/BServlet"); rd.include[请求包含](request, response); &#125;&#125;public class BServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println("BServlet"); &#125;&#125;AservletBServlet 请求转发和请求包含比较 如果在AServlet中请求转发到BServlet，那么在AServlet中就不允许再输出响应体，即不能再使用response.getWriter()和response.getOutputStream()向客户端输出，这一工作应该由BServlet来完成；如果是使用请求包含，那么没有这个限制； 请求转发虽然不能输出响应体，但还是可以设置响应头的，例如：response.setContentType(”text/html;charset=utf-8”); 请求包含大多是应用在JSP页面中，完成多页面的合并； 请求请求大多是应用在Servlet中，转发目标大多是JSP页面； 请求转发与重定向比较 请求转发是一个请求，而重定向是两个请求； 请求转发后浏览器地址栏不会有变化，而重定向会有变化，因为重定向是两个请求； 请求转发的目标只能是本应用中的资源，重定向的目标可以是其他应用； 请求转发对AServlet和BServlet的请求方法是相同的，即要么都是GET，要么都是POST，因为请求转发是一个请求； 重定向的第二个请求一定是GET 路径与路径相关的操作 超链接 表单 转发 包含 重定向 ServletContext获取资源 Class获取资源 ClassLoader获取资源 客户端路径超链接、表单、重定向都是客户端路径，客户端路径可以分为三种方式： 绝对路径； 以“/”开头的相对路径； 不以“/”开头的相对路径； 例如：http://localhost:8080/hello1/pages/a.html中的超链接和表单如下： 12345678910111213141516绝对路径：&lt;a href="http://localhost:8080/hello2/index.html"&gt;链接1&lt;/a&gt;客户端路径：&lt;a href="/hello3/pages/index.html"&gt;链接2&lt;/a&gt;相对路径：&lt;a href="index.html"&gt;链接3&lt;/a&gt;&lt;hr/&gt;绝对路径：&lt;form action="http://localhost:8080/hello2/index.html"&gt; &lt;input type="submit" value="表单1"/&gt;&lt;/form&gt;客户端路径：&lt;form action="/hello2/index.html"&gt; &lt;input type="submit" value="表单2"/&gt;&lt;/form&gt;相对路径：&lt;form action="index.html"&gt; &lt;input type="submit" value="表单3"/&gt;&lt;/form&gt; 链接1和表单1：没什么可说的，它使用绝对路径； 链接2和表单2：以“/”开头，相对主机，与当前a.html的主机相同，即最终访问的页面为http://localhost:8080/hello2/index.html； 链接3和表单3：不以“/”开头，相对当前页面的路径，即a.html所有路径，即最终访问的路径为：http://localhost:8080/hello1/pages/index.html； 重定向1： 123456public class AServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.sendRedirect("/hello/index.html"); &#125;&#125; 假设访问AServlet的路径为：http://localhost:8080/hello/servlet/AServlet 因为路径以“/”开头，所以相对当前主机，即http://localhost:8080/hello/index.html。 重定向2： 123456public class AServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.sendRedirect("index.html"); &#125;&#125; 假设访问AServlet的路径为：http://localhost:8080/hello/servlet/AServlet 因为路径不以“/”开头，所以相对当前路径，即http://localhost:8080/hello/servlet/index.html 建议使用“/”强烈建议使用“/”开头的路径，这说明在页面中的超链接和表单都要以“/”开头，后面是当前应用的名称，再是访问路径： 12345&lt;form action="/hello/servlet/AServlet"&gt;&lt;/form&gt;&lt;a href="/hello/b.html"&gt;链接&lt;/a&gt; 其中/hello是当前应用名称，这也说明如果将来修改了应用名称，那么页面中的所有路径也要修改，这一点确实是个问题。这一问题的处理方案会在学习了JSP之后讲解！在Servlet中的重定向也建议使用“/”开头。同理，也要给出应用的名称！例如： 1response.sendRedirect("/hello/BServlet"); 其中/hello是当前应用名，如果将来修改了应用名称，那么也要修改所有重定向的路径，这一问题的处理方案是使用request.getContextPath()来获取应用名称。 1response.sendRedirect(request.getContextPath() + "/BServlet"); 服务器端路径服务器端路径必须是相对路径，不能是绝对路径。但相对路径有两种形式： 以“/”开头； 不以“/”开头； 其中请求转发、请求包含都是服务器端路径，服务器端路径与客户端路径的区别是： 客户端路径以“/”开头：相对当前主机； 服务器端路径以“/”开头：相对当前应用； 转发1： 123456public class AServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.getRequestDispatcher("/BServlet").forward(request, response); &#125;&#125; 假设访问AServlet的路径为：http://localhost:8080/hello/servlet/AServlet 因为路径以“/”开头，所以相对当前应用，即http://localhost:8080/hello/BServlet。 转发2： 123456public class AServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.getRequestDispatcher("BServlet").forward(request, response); &#125;&#125; 假设访问AServlet的路径为：http://localhost:8080/hello/servlet/AServlet 因为路径不以“/”开头，所以相对当前应用，即http://localhost:8080/hello/servlet/BServlet。 路径必须使用“/”开头，并且相对的是当前应用. ServletContext获取资源Class 获取资源必须是相对路径，可以“/”开头，也可以不使用“/”开头，但无论是否使用“/”开头都是相对当前应用路径。例如在AServlet中获取资源，AServlet的路径路径为：http://localhost:8080/hello/servlet/AServlet： 123456789public class AServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String path1 = this.getServletContext().getRealPath("a.txt"); String path2 = this.getServletContext().getRealPath("/a.txt"); System.out.println(path1); System.out.println(path2); &#125;&#125; path1和path2是相同的结果：http://localhost:8080/hello/a.txt Class获取资源Class获取资源也必须是相对路径，可以“/”开头，也可以不使用“/”开头。 12345678910111213package cn.itcast;import java.io.InputStream;public class Demo &#123; public void fun1() &#123; InputStream in = Demo.class.getResourceAsStream("/a.txt"); &#125; public void fun2() &#123; InputStream in = Demo.class.getResourceAsStream("a.txt"); &#125;&#125; 其中fun1()方法获取资源时以“/”开头，那么相对的是当前类路径，即/hello/WEB-INF/classes/a.txt文件；其中fun2()方法获取资源时没有以“/”开头，那么相对当前Demo.class所在路径，因为Demo类在cn.itcast包下，所以资源路径为：/hello/WEB-INF/classes/cn/itcast/a.txt。 ClassLoader获取资源ClassLoader获取资源也必须是相对路径，可以“/”开头，也可以不使用“/”开头。但无论是否以“/”开头，资源都是相对当前类路径. 123456789public class Demo &#123; public void fun1() &#123; InputStream in = Demo.class.getClassLoader().getResourceAsStream("/a.txt"); &#125; public void fun2() &#123; InputStream in = Demo.class.getClassLoader().getResourceAsStream("a.txt"); &#125;&#125; fun1()和fun2()方法的资源都是相对类路径，即classes目录，即/hello/WEB-INF/classes/a.txt 编码请求编码直接在地址栏中给出中文请求数据是由客户端浏览器发送服务器的，请求数据的编码是由浏览器决定的。例如在浏览器地址栏中给出：http://localhost:8080/hello/AServlet?name=传智，那么其中“传智”是什么编码的呢？不同浏览器使用不同的编码，所以这是不确定的！ IE：使用GB2312； FireFox：使用GB2312； Chrome：使用UTF-8； 通常没有哪个应用要求用户在浏览器地址栏中输入请求数据的，所以大家只需了解一下即可。 在页面中发出请求通常向服务器发送请求数据都需要先请求一个页面，然后用户在页面中输入数据。页面中有超链接和表单，通过超链接和表单就可以向服务器发送数据了。因为页面是服务器发送到客户端浏览器的，所以这个页面本身的编码由服务器决定。而用户在页面中输入的数据也是由页面本身的编码决定的。 index.html 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;index.html&lt;/title&gt; &lt;meta http-equiv="content-type" content="text/html; charset=UTF-8"&gt;[这就相当于给客户端发送了响应头content-type，指定当前页面的编码为utf-8] &lt;/head&gt; &lt;body&gt;&lt;form action="/hello/servlet/AServlet"&gt; 名称:&lt;input type="text" name="name"/&gt; &lt;input type="submit" value="提交"/&gt;&lt;/form&gt;&lt;a href="/hello/servlet/AServlet?name=传智"&gt;链接&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 当用户在index.html页面中输入数据时，都是UTF-8列表的。因为这个页面本身就是UTF-8编码的！ 页面的编译就是页面中输入数据的编码。 GET请求解读编码当客户端通过GET请求发送数据给服务器时，使用request.getParameter()获取的数据是被服务器误认为ISO-8859-1编码的，也就是说客户端发送过来的数据无论是UTF-8还是GBK，服务器都认为是ISO-8859-1，这就说明我们需要在使用request.getParameter()获取数据后，再转发成正确的编码。 例如客户端以UTF-8发送的数据，使用如下转码方式： String name = request.getParameter(“name”); name = new String(name.getBytes(“iso-8859-1”), “utf-8”); POST请求解读编码 当客户端通过POST请求发送数据给服务器时，可以在使用request.getParameter()获取请求参数之前先通过request.setCharacterEncoding()来指定编码，然后再使用reuqest.getParameter()方法来获取请求参数，那么就是用指定的编码来读取了。 也就是说，如果是POST请求，服务器可以指定编码！但如果没有指定编码，那么默认还是使用ISO-8859-1来解读。 request.setCharacterEncoding(“utf-8”); String name = request.getParameter(“name”); 响应编码响应：服务器发送给客户端数据！响应是由response对象来完成，如果响应的数据不是字符数据，那么就无需去考虑编码问题。当然，如果响应的数据是字符数据，那么就一定要考虑编码的问题了。 response.getWriter().print(“传智”); 上面代码因为没有设置repsonse.getWriter()字符流的编码，所以服务器使用默认的编码（ISO-8859-1）来处理，因为ISO-8859-1不支持中文，所以一定会出现编码的。 所以在使用response.getWriter()发送数据之前，一定要设置response.getWriter()的编码，这需要使用response.setCharacterEncoding()方法： response.setCharacterEncoding(“utf-8”); response.getWriter().print(“传智”); 上面代码因为在使用response.getWriter()输出之前已经设置了编码，所以输出的数据为utf-8编码。但是，因为没有告诉浏览器使用什么编码来读取响应数据，所以很可能浏览器会出现错误的解读，那么还是会出现乱码的。当然，通常浏览器都支持来设置当前页面的编码，如果用户在看到编码时，去设置浏览器的编码，如果设置的正确那么乱码就会消失。但是我们不能让用户总去自己设置编码，而且应该直接通知浏览器，服务器发送过来的数据是什么编码，这样浏览器就直接使用服务器告诉他的编码来解读！这需要使用content-type响应头。 12response.setContentType(“text/html;charset=utf-8”);response.getWriter().print(“传智”); 上面代码使用setContentType()方法设置了响应头content-type编码为utf-8，这不只是在响应中添加了响应头，还等于调用了一次response.setCharacterEncoding(“utf-8”)，也就是说，通过我们只需要调用一次response.setContentType(“text/html;charset=utf-8”)即可，而无需再去调用response.setCharacterEncoding(“utf-8”)了。 在静态页面中，使用来设置content-type响应头，例如： 1&lt;meta http-equiv="content-type" content="text/html; charset=UTF-8"&gt; URL编码通过页面传输数据给服务器时，如果包含了一些特殊字符是无法发送的。这时就需要先把要发送的数据转换成URL编码格式，再发送给服务器。 其实需要我们自己动手给数据转换成URL编码的只有GET超链接，因为表单发送数据会默认使用URL编码，也就是说，不用我们自己来编码。 例如：“传智”这两个字通过URL编码后得到的是：“%E4%BC%A0%E6%99%BA”。URL编码是先需要把“传智”转换成字节，例如我们现在使用UTF-8把“传智”转换成字符，得到的结果是：“[-28, -68, -96, -26, -103, -70]”，然后再把所有负数加上256，得到[228, 188, 160, 230, 153, 186]，再把每个int值转换成16进制，得到[E4, BC, A0, E6, 99, BA]，最后再每个16进制的整数前面加上“%”。 通过URL编码，把“传智”转换成了“%E4%BC%A0%E6%99%BA”，然后发送给服务器！服务器会自动识别出数据是使用URL编码过的，然后会自动把数据转换回来。 当然，在页面中我们不需要自己去通过上面的过程把“传智”转换成“%E4%BC%A0%E6%99%BA”，而是使用Javascript来完成即可。当后面我们学习了JSP后，就不用再使用Javascript了。 123456 &lt;script type="text/javascript"&gt; function _go() &#123; location = "/day05_2/AServlet?name=" + encodeURIComponent("传智+播客"); &#125; &lt;/script&gt;&lt;a href="javascript:_go();"&gt;链接&lt;/a&gt; 因为URL默认只支持ISO-8859-1，这说明在URL中出现中文和一些特殊字符可能无法发送到服务器。所以我们需要对包含中文或特殊字符的URL进行URL编码。 服务器会自动识别数据是否使用了URL编码，如果使用了服务器会自动把数据解码，无需我们自己动手解码。 本博客：参考传智播客。]]></content>
      <categories>
        <category>JavaWeb核心篇</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Request</tag>
        <tag>Response</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP 与 JavaBean 技术]]></title>
    <url>%2F2018%2F02%2F01%2F01--JSP-%E4%B8%8E-JavaBean-%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[主要学习以下知识点： 可重用组件：组件的概念和组件存在的意义。 JavaBean的定义规则和JSP使用JavaBeande用法和示例。 如何使用JavaBean封装数据库操作。 JSP+JavaBean实现分页查询以及两种分页实现形式。 可重用组件JavaBean简介什么是可重用组件定义：能够完成某种特定功能，并提供一个或多个访问接口的聚合模板程序。 最大特点：可重复使用。 最重要两类组件：JavaBean、EJB（Enterprise JavaBean） 主要学习JavaBean： 本质：JavaBean本质是一个普通Java类，但此类须符合一定的规则，即JavaBean规范。 JavaBean规范： 是一个公共类（public class） setXXX和getXXX方法：决定JavaBean的属性。 有一个公开的无参数的构造方法。 注意： JavaBean类一般会实现 java.io.Serializable接口，代表可序列化。虽不是必须，但有益于JavaBean对象的复制，比如：服务器集群时，若JavaBean保存在Session中，JavaBean就需要在网络中进行复制，此时，需要序列化。 属性：是JavaBean与外部程序通信的接口。 属性命名规范： set/get+属性名（属性名第一个字母须大写） 对于boolean类型属性，用is代替set、get。 属性不一定是成员变量，成员变量不一定是属性。 JSP使用JavaBeanJSP如何使用JavaBean一般来说，JSP完成一项特定功能，有3中实现方式。 在HTML代码中夹杂java语言写成jsp脚本，功能逻辑就在java语言中完成。缺点明显，代码可读性差，很难维护。 把功能包装在一个JavaBean内，然后在jsp脚本中，用new 操作符实例化这个JavaBean，再调用setXXX和getXXX()方法来完成特定功能。维护较好，可读性仍不好。 同样，把逻辑功能包装在JavaBean内，再利用jsp动作标签（）访问JavaBean的属性。这种方式比第二种耦合度进一步低一点。值得推荐！！！！！ 三个例子：功能很简单，每次请求返回用户名以及当前的日期和时间。 纯JSP实现Jsp脚本夹杂在HTML代码中间。 图片 Jsp用实例化的方式使用JavaBean图片 用Jsp动作标签访问JavaBean图片 JSP业务代码实现方式对比图片 JSP使用JavaBean的标签详解动作标签作用：分离显示代码和逻辑代码。讲一下、、 。标签属性值不同导致他们会有不同行为。 定义JavaBean动作标签标签作用：用于特定范围内查找或者实例化一个JavaBean,基本语法如下： 123456&lt;jsp:useBeanid ="唯一标识名字"scope=" page | request | session | application "type="父类型或已实现接口"class="实现类名"&gt; 下表对 属性和说明 图page160 动作标签的基本工作机制如下： 在制定范围内（scope）寻找是否已有名字为id属性指定的对象。 若存在，且指定type属性，则用该type属性做一次强制类型转换后再返回该对象的引用；若没有指定type属性，则直接返回该对象引用。 若不存在，则用class属性指定的类实例化一个新的对象并返回，并将该对象保存在scope内。 设置JavaBean属性动作标签 是为JavaBean的可写属性赋值，它既可以放在 中间，也可以单独使用。 基本语法： 123456&lt;jsp:setProperty name="与JavaBean的id属性相同" property="可写属性名" value="字面值" param="请求参数的名字"/&gt; 下表对 属性和说明： 图page160 用于设置JavaBean属性的值，这些值可以来源多种地方，下面几种是比较常用的属性赋值方法，按需选择： 1&lt;jsp:setProperty name="bean" property="prop" value="string contant"/&gt; //直接赋字面值 1&lt;jsp:setProperty name="bean" property="prop" param="paramName"/&gt; //赋指定请求参数的值 1&lt;jsp:setProperty name="bean" property="prop"/&gt; //赋同名的请求参数 1&lt;jsp:setProperty name="bean" property="*"/&gt; //将所有属性一一与请求参数按名匹配赋值。 1&lt;jsp:setProperty name="bean" property="prop" value="&lt;%=expression%&gt;"/&gt; //赋表达式的值。 技巧：当Bean需要从请求参数里获取值的话，第二条会经常用到。 获取JavaBean属性动作标签 是获取JavaBean的可读属性。既可以放在 中间。也可以单独使用，用法简单。 语法格式： 1234&lt;jsp:getProperty name="与JavaBean的id属性值相同" property="可读属性名"/&gt; 下表对&lt;jsp:useBean```性和说明]]></content>
      <categories>
        <category>JavaWeb核心篇</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件体系、Tomcat、Http协议]]></title>
    <url>%2F2018%2F02%2F01%2F01--%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E3%80%81Tomcat%E3%80%81Http%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[今天学习一些常识，但都很重要，总结的非常好，一起看一下,知识点如下： 软件体系结构 Tomcat 配置外部应用 Http协议 软件体系结构C/S：Client/Servlet，例如QQ就是CS结构需要编写服务器端程序和客户端程序。缺点：更新需要两端，总要求客户下载新的客户端程序优点：安全性比较好 B/S：Browser/Server缺点：安全性较差优点：只需要编写服务器端程序 Web资源 静态资源：html、css、javascript、图片等； 动态资源：javaweb的动态资源有jsp/servlet，其他web程序动态资源有asp、php等。 静态资源和动态资源的区别 客户端访问服务器静态资源，服务器直接响应； 客户端访问服务器动态资源，服务器需要先把动态资源转换成静态资源，再响应。 客户端通过浏览器访问服务器 http://主机名:端口号/路径，例如：http://www.itcast.cn:80/index.html Web服务器 Tomcat（Apache）：当前应用最广的JavaWeb服务器，支持servlet规则，不支持JavaEE规范； JBoss（Redhat红帽）：支持JavaEE规则； GlassFish（Orcale）：支持servlet规则，应用不是很广； Resin（Caucho）：支持JavaEE规则，应用越来越广； Weblogic（Orcale）：要钱的！支持JavaEE规则，适合大型项目； Websphere（IBM）：要钱的！支持JavaEE规则，适合大型项目； Tomcattomcat6支持servlet2.5tomcat7支持servlet3.0 启动关闭tomcat需要先配置JAVA_HOME 双击%CATALANA_HOME%\bin\startup.bat 双击%CATALANA_HOME%\bin\shutdown.bat 访问服务器：http://localhost:8080/index.jsp 因为服务器在本机上，所以主机名为localhost，表示本机 tomcat的默认端口为8080 index.jsp是主页 修改端口号 修改端口号，%CATALANA_HOME%\conf\server.xml，修改，把8080修改了即可。 http协议默认端口为80，也就是说http://localhost，等同与http://localhost:80 如果把Tomcat端口号修改成80，那么访问服务器就可以无需再给出端口号。 tomcat目录结构 bin：二进制可执行文件，例如startup.bat和shutdown.bat conf：配置文件，例如：server.xml、context.xml、web.xml、tomcatusers.xml lib：tomcat所需jar包 logs：日志文件 temp：存放tomcat运行时产生的临时文件，当tomcat关闭后，这个目录中的文件可以删除 webapps：这个目录下的每个文件夹对应一个JavaWeb应用程序 work：webapps下的应用程序在运行时会自动生成文件，就在work目录下。work目录删除了也没问题，但再次运行应用程序还要再生成work目录和文件。 创建JavaWeb目录：hello 在webapps目录下创建一个hello目录，hello目录就是项目目录了； 在hello目录下创建WEB-INF 在WEB-INF下创建web.xml 在WEB-INF下创建classes目录 在WEB-INF下创建lib目录 在hello目录下创建index.html 在web.xml文件中添加如下内容： 1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt;&lt;/web-app&gt; 在index.html中添加如下内容： 123456&lt;html&gt; &lt;head&gt;&lt;title&gt;index.html&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt; hello主页 &lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 启动tomcat，打开客户端访问http://localhost:8080/hello/index.html 配置外部应用外部应用既是把应用程序不放到Tomcat的wabapps目录下！而已放在外面，例如：F:/hello 在conf/server.xml下配置，指定外部应用的路径。1234&lt;Host name="localhost" appBase="webapps" unpackWARs="true" autoDeploy="true"&gt; &lt;Context path="itcast_hello" docBase="F:/hello"/&gt;&lt;/Host&gt; 在元素下添加元素，path为URL访问路径，docBase为外部应用的目录。 在浏览器地址栏中访问：http://localhost:8080/itcast_hello/index.html 在conf/catalana/localhost下添加配置文件，指定外部应用路径 在conf/catalana/localhost目录下创建itcast_hello.xml文件，其中itcast_hello就是URL访问路径 在itcast_hello.xml文件中添加：，docBase指定外部应用的目录。 缺省web应用 在webapps目录下有一个ROOT目录，它是缺省web应用，访问这个应用的路径：http://localhost:8080/index.jsp 如果把web应用的内部放到webapps/ROOT下，访问URL路径中不用给出应用名称。 配置虚拟主机希望：http://www.itcast.cn访问web应用。 这需要把域名http://www.itcast.cn映射成IP地址：127.0.0.1 需要把tomcat端口号修改为80 需要在server.xml中配置主机，并指定主机的应用目录 在应用目录中添加名为ROOT的web应用。 1). 找到C:\WINDOWS\system32\drivers\etc\hosts文件，添加127.0.0.1 http://www.itcast.cn2). 在conf/server.xml中修改端口为803). 在conf/server.xml中添加元素 12&lt;Host name="www.itcast.cn" appBase="F:/myapps" unpackWARs="true" autoDeploy="true"&gt;&lt;/Host&gt; name：指定该主机域名为www.itcast.cn appBase：指定该主机的应用目录为F:/myapps 4). 在F:/myapps下创建名为ROOT的web应用。 访问：http://www.itcast.cn/index.html其中www.itcast.cn在本机上会被解析为127.0.0.1，但其他电脑访问时无效。 Http协议http协议 即超文本传输协议。它规定了浏览器与服务器之间的通讯规则。 http是基于请求/响应模式的，所以分为请求协议和响应协议 =================================== 请求 请求内容就是客户端发送给服务器的数据！ 请求格式： 请求首行 请求头 空行 请求体（或称之为请求正文） 请求方法 常见请求方法有GET和POST 在浏览器地址栏中发送请求，以及点击超链接都是GET请求 提交表单可以发送GET请求，以及POST请求 GET请求没有请求体，但空行是存在的 POST请求是存在请求体的 使用HttpWatch获取请求信息 请求行：请求方法 请求路径 请求协议及版本，例如：GET /hello/index.jsp HTTP/1.1 请求头：请求头就是一些键值，格式为：头:值，例如：Host:localhost 空行：就是一个空行，用来与请求体分隔 请求体：GET方法没有请求体，POST才有请求体，请求体内容为：参数名=参数值&amp;参数名=参数值，其中参数值为中文，会使用URL编码。 常见请求头 Host：请求的服务器主机名 User-Agent：客户端浏览器与操作系统相关信息 Accept-Encoding：客户端支持的数据压缩格式 Connection：客户端支持的连接方式 Cookie：客户端发送给服务器的“小甜点”，它服务器寄存在客户端的。如果当前访问的服务器没有在客户端寄存东西，那么就不会存在它！ Content-Length：请求体的长度 Referer：当前发出请求的地址，例如在浏览器地址栏直接访问服务器，那么没有这个请求头。如果是在www.baidu.com页面上点击链接访问的服务器，那么这个头的值就是www.baidu.com 作用1：统计来源作用2：防盗链 Content-Type：如果是POST请求，会有这个头，默认值为application/x-www-form-urlencoded，表示请求体内容使用url编码。 =========================================================== 响应 响应就是服务器发送给客户端的数据！ 响应格式： 响应首行 响应头 空行 响应体（或称之为响应正文） 状态码 响应首行的结构：协议及版本 状态码 状态码说明，例如：HTTP/1.1 200 OK 200：请求成功 302：请求重定向 304：请求资源没有改变 404：请求资源不存在，属性客户端错误 500：服务器内部错误 响应头 Content-Type：响应正文的MIME类型，例如image/jpeg表示响应正文为jpg图片，例如text/html;charset=utf-8表示响应正文为html，并且编码为utf-8编码。浏览器会通过这一信息来显示响应数据 Content-Length：响应正文的长度 Set-Cookie：服务器寄存在客户端的“小甜点”，当客户端再次访问服务器时会把这个“小甜点”还给服务器 Date：响应时间，可能会有8小时的误差，因为中国的时区问题 通知客户端浏览器不要缓存页面的响应头： Expires:-1 Cache-Control: no-cache Pragma: no-cache 自动刷新响应头，浏览器会在3秒钟后自动重定向到传智主页 Refresh: 3;url=http://www.itcast.cn 状态码304 相关头信息 Last-Modified：响应头，表示当前资源的最后修改时间； If-Modified-Since：请求头，表示缓存的资源最后修改时间； 状态码304：表示访问的资源没有改变 客户端首次访问服务器的静态资源index.html，服务器会把index.html响应给客户端，而且还会添加一个名为Last-Modified的响应头，它说明了当前index.html的最后修改时间 客户端收到响应后，会把index.html缓存在客户端上，而且还会把Last-Modified缓存起来。 客户端第二次请求index.html时，会添加名为If-Modified-Since的请求头，它的值是上次服务器响应头Last-Modified，服务器获取到客户端保存的最后修改时间，以及当前资源的最后修改时间进行比较，如果相同，说明index.html没有改动过，那么服务器不会发送index.html，而是响应状态码304，即通知客户端资源没有改变，你可以使用自己的缓存。]]></content>
      <categories>
        <category>JavaWeb核心篇</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Tomcat</tag>
        <tag>Http协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb必修课之JSP语法]]></title>
    <url>%2F2018%2F01%2F28%2F28--JavaWeb%E5%BF%85%E4%BF%AE%E8%AF%BE%E4%B9%8BJSP%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[学习完了XML，再一起看看JSP。我知道这些都太浅薄了，但是可以知道他是个干啥的，权当做了解吧。主要有以下知识点： 了解JSP页面基本组成 使用JSP指令标识 使用JSP脚本 巧用注释 常用JSP动作标识 上机实践 应用Java程序片段动态生成表格 将页面转发到用户登陆页面 应用JavaBean保存图片信息 了解JSP页面基本构成JSP是基于Java语言的动态网页技术，以“.jsp”为拓展名。一个JSP页面主要由以下构成： 指令标识 HTML代码 JavaScript代码 嵌入的Java代码 注释 JSP动作标识 但以上内容并不是一个JSP页面所必须的。下面来看一个程序： 1234567891011121314151617181920&lt;%@ page language="java" contentType="text/html; charset=UTF-8%&gt;&lt;%@ page pageEncoding="UTF-8"%&gt;&lt;%@ page import="java.util.Date"%&gt;&lt;%@ page import="java.text.SimpleDateFormat"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;一个简单的 JSP 页面---显示系统时间&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;% Date date = new Date(); //获取日期对象 //设置日期时间格式 SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String today = sdf.format(date); %&gt; 当前时间: &lt;% =today %&gt; &lt;/body&gt;&lt;/html&gt; 接下来再看一下JSP文件在Web应用服务器中先后经历的4个关键（阶段）过程： 文字描述： 当浏览器向Web服务器请求一个JSP页面时，Web应用服务器转换为——Servlet文件（即一个.java文件） 将.java文件翻译为——字节码文件（即一个,class文件） 最后Web应用服务器加载转换后的Servlet实例，处理客户端的请求，并返回HTML格式的响应给客户端浏览器。 图片描述： 说明：Servlet定义在JavaEE API中，它实质是一个用Java语言编写的类，但能够接受以及回应Web请求。 使用JSP指令标识指令标识作用：设置整个JSP页面范围内有效的相关信息，标识会被服务器解释执行，但不会产生任何内容输出到网页中。 JSP包含3个指令标识，即：page、include、taglib。他们语法结构相同，定于方法如下： 1&lt;%@ 指令名 属性1="属性1值" 属性2="属性2值" ...%&gt; 说明： 指令名： 指定指令名，取值为：page、include、taglib指令。 属性：指定属性名称，指令不同属性不同。若在某指令中设置多个属性，属性间用逗号隔开。 属性值：指定属性值。 使用页面指令page页面指令page：JSP页面最常用指令，必须要用指令。 作用：定义与整个JSP页面相关的属性，如jsp页面编码、内容类型以及引用类型等。 当这些属性被服务器解析成Servlet时会被转换为相应的Java程序代码。 page指令语法格式： 1&lt;%@ page 属性1="属性值1" 属性2="属性值2" ...%&gt; 说明： page：声明指令为page指令。 属性：指定page指令中的属性。 属性值：指定属性值。 注意：指令名与@之间有一个空格。 page指令提供11个的属性： language：指定当前页面使用语言，目前只支持Java语言。属性默认值Java。 contentType设置jsp页面MIME类型和字符编码，浏览器根据属性指定的类型和编码解析网页内容。 比如：MIME=HTML文本，字符编码=UTF-8 1&lt;%@ page language="java" contentType="text/html; charseUTF-8 %&gt; pageEncoding：设置jsp页面编码格式，在jsp页面中所代码都使用该属性指定的字符集。中文编码有（GBK/GB2312/UTF-8）。 通常情况下，pageEncoding和contentType属性会同时存在。 前者作用：指定jsp页面编码格式。若为非支持中文的字符集，则不能编写中文字符，否则乱码。 后者作用：指定服务器处理请求完成后，回应给浏览器的内容的类型。如“text/html; charset=utf-8”，则说明回应的页面是html文档或文本内容，字符集为UTF-8。 import：导入jsp页面中的类包，导入后在jsp页面中可以通过嵌入java代码的方法使用这些类包。 1&lt;%@ page import="java.util.Date" %&gt; buffer：设置out对象使用的缓冲区大小，默认大小 8KB，且单位只能是KB。建议开发人员使用8的倍数作为该属性的值。 1&lt;%@ page buffer="16KB"%&gt; autoFlush：指定当缓冲区已满时，自动将缓冲区中内容输出到客户端。默认值为true。若为false，当缓冲区满时，抛JSP Buffer overflow异常。 如缓冲区满时，未自动将其内容输出到客户端代码： 1&lt;%@ page autoFlush="false"%&gt; isErrorPage：设置当前页面为错误页面，以处理另一个错误页面。只有为true时，才可以调用exception对象输出错误信息。 将当前页面设置为错误处理页面： 1&lt;%@ page isErrorPage="true" %&gt; errorPage：指定当前页面出现异常时调用的另一个页面（即错误处理页面），须指定isErrorPage=”true”。 如：指定当前页面出现异常时调用error.jsp。 1&lt;%@ page errorPage="error.jsp" %&gt; 但在error.jsp页面中须设置如下代码： 1&lt;%@ page isErrorPage="true" %&gt; 然后在error.jsp中即可通过以下代码输出错误信息。 1&lt;%=exception.getMessage()%&gt; session：指定当前页面是否支持session，默认值为true，即支持。 isELIgnored：指定是否禁用EL表达式，true表示页面将忽略EL表达式；否则将执行EL表达式。 isThreadSafe：指定JSP页面是否线程安全，true:表示jsp页面在同一时刻可以被多个线程访问，否则不可。 使用文件包含指令include作用：将一个JSP页面包含到另一个JSP页面中实现JSP页面的重用。包含过程如下： 此处放图片 说明： include指令为静态指令。被包含文件内容原样包含。但被包含文件内JSP代码，在包含时不会被编译执行。将两个页面组合在一起，最后返回结果页面。 include：最终只生成一个文件。所以包含和被包含文件中不能有相同变量。 语法格式： 12&lt;%@ include file="path"%&gt;只有一个file属性，指定被包含文件路径。路径可相对可绝对路径。 技巧： 通常情况下，网站页面头部（banner部分）、与底部（版权信息部分）都相同，可分别创建两个页面。然后通过include指令将其包含在其他页面中。 使用引用标签库指令taglib声明一个标签的引用，在JSP页面中声明哪个标签库的引用，即可在JSP页面中调用哪个标签。 语法如下： 1&lt;%@ taglib prefix=&quot;tagPrefix&quot; uri=&quot;tagURI&quot;%&gt; taglib：声明指令为taglib指令。 prefix：指定标签库的前缀。 uri：指定标签库文件位置， 如：引用JSTL中核心标签库可以使用下面代码： 1&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt; 使用 JSP脚本JSP之所以应用灵活，主要原因是JSP页面中可以很方便的调用Java或脚本代码实现所需功能。 JSP脚本标识： JSP表达式（Expression） 声明标识（Declaration） 脚本程序 通过上述标识，在JSP页面可以如Java程序一样来生声明变量，定义方法或执行各种表达式的运算。 在JSP中应用代码片段代码片段：在jsp中嵌入的Java或脚本代码。 Java代码作用：定义变量、流程控制等。 脚本代码作用：应用jsp的内置对象在页面输出内容、处理请求和响应并访问session对象。 执行时间：将在页面请求的处理期间被执行。 代码片段语法格式： 1&lt;% Java代码或脚本代码 %&gt; 使用方法：灵活，可以是Java代码，也可以是调用jsp提供的内置对象。 关键代码： 1234567&lt;% int num =1; for(int i=1;i&lt;10;i++)&#123; num*=i; &#125; out。print("10的阶乘是："+num); //out为jsp内置对象，输出到页面中。 %&gt; 使用JSP表达式jsp表达式作用：在页面中输出信息。 使用方式：可插入到网页的文本用于输出文本内容，也可以插入到HTML标记中用于动态设置属性。 jsp语法格式： 1234&lt;%= 表达式 %&gt;说明：* 表达式可以是任何Java语言的完整表达式，其最终运算结果将被转换为字符串。* &lt;%与=之间不能有空格，否则会出现编译错误，但=与其他后面表达式之间可以有空格。 如：使用jsp表达式输出用户相关信息： 123456&lt;% String name=&quot;adnim&quot;; //用户名 String sex=&quot;男&quot;; //性别%&gt;用户名：&lt;%=name %&gt;性别：&lt;%=sex%&gt; 上述代码将会形成如下HTML代码： 12用户名：admin性别：男 使用声明标识声明标识应用：定义全局成员变量以及成员方法。（遵循Java语法） 语法格式： 123&lt;%! 声明变量或方法的代码 %&gt;说明：* 由于声明标识生声明的变量的是全局的，所以在多个用户并发访问是会产生线程安全问题，此种方式应用很少。 如：应用jsp声明统计认人数。 123456789101112131415161718192021&lt;%@page contentType="text/html"%&gt;&lt;%@page pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;JSP Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;% int count=0; public int getCount()&#123; count++; return count ; &#125; %&gt; 您好，您是本站的第 &lt;%=getCount()%&gt; 位来访者。 &lt;/body&gt;&lt;/html&gt; 巧用注释基本HTML注释jsp页面同样可以使用HTML注释。 语法格式： 1&lt;!-- 注释内容--&gt; 可以在注释中加入由jsp表达式指定的动态代码： 12&lt;!-- 注释内容&lt;%= 表达式 %&gt;--&gt;&lt;!-- 当前时间：&lt;%= new java.util.Date().toLocalString()%&gt;--&gt; 注意： HTML注释并不是安全注释方式，可通过网页查看源代码方式查看编写的注释内容。 隐藏注释（安全性高）语法格式： 1&lt;%-- 注释内容 --%&gt; 代码片段中的注释与java注释相同。 单行注释： 1//注释内容 多行注释： 1/* 注释内容 */ JavaDoc注释： 123/**注释内容*/ 常用JSP动作标识使用包含动作标识1、作用： 动作标识用于包含其他页面，被包含页面可动态可静态页面。 2、原理：将被包含页面编译处理后将结果包含在页面中。 原理如图所示： 次处放图片。 文字描述：当浏览器第一次请求1个 包含其他页面时，Web容器首先会编译包含的页面。然后将编译处理的返回结果包含在页面中，之后编译包含页面，最后将两个页面组合的结果回应给浏览器。 说明：静态页面不需要编译即可被Web容器解析，所以若被包含页面为静态页面，将不会经历编译处理这一过程。 3、基本语法： 1&lt;jsp:include page="url" flush="false|true" /&gt; 或者： 123&lt;jsp:include page="url" flush="false|true"&gt; 子动作标识&lt;jsp:param&gt;&lt;/jsp:include&gt; page属性：指定文件的相对路径。 flush：可选，设置是否刷新缓冲区。默认false。若为true，表当前页面输出使用缓冲区的情况下首先刷新缓冲区，然后执行操作。 4、此处说一下include指令和 区别： include： include通过file属性来指定被包含的文件，且该属性不支持任何表达式； 动作标识通过page属性指定被包含的文件，且该属性支持jsp表达式。 include指令将被包含文件内容原封不动地插入到包含页面中，然后jsp编译器将合成后的文件最终编译为一个Java文件；使用 动作标识包含文件，当该标识被执行时，程序会将请求转发（注意是转发，非重定向）到被包含的页面并将执行结果输出到浏览器中，然后返回包含页继续执行后面的代码。因为服务器执行多个文件，所以jsp编译器会分别编译这些文件。 include指令包含文件时由于被包含文件最终会生成一个文件，所以在被包含文件和包含文件中不能有重名的变量或方法； 动作标识包含文件时，由于每个文件单独编译，所以被包含文件和包含文件中重名的变量和方法不冲突！ 使用请求转发的动作标识1、作用：将当前请求转发到其他Web资源（HTML、JSP页面和Servlet页面）。在执行请求转发之后当前页面将不再执行，而是执行该标识指定的目标页面。 2、基本流程如下图所示： 此处有图片 3、语法格式： 1&lt;jsp:forward page="url"/&gt; 或者： 123456&lt;jsp:forward page="url"&gt; 子动作标识&lt;jsp:param&gt;&lt;/jsp:forward&gt; 注意： 使用&lt;jsp:forward&gt;请求转发被转向到目标资源必须与当前JSP页面处于同一上下文应用环境中，否则会出现页面找不到错误。 page属性：指定请求转发的目标页面，该属性值可以是一个指定文件路径的字符串或标识文件路径的JSP表达式。 如：应用 动作标识将请求转发到用户登录界面login.jsp。 此页面是请求转发的目标页面，并没有实现用户登录的功能，表单action属性值为空。 关键代码： 12345678&lt;form action=""&gt;&lt;div&gt; &lt;ul&gt;&lt;li&gt;&lt;h3&gt;用户登录&lt;/h3&gt;&lt;/li&gt;&lt;/ul&gt; &lt;ul&gt;&lt;li&gt;用户名：&lt;input type="text" name="username"&gt;&lt;/li&gt;&lt;/ul&gt; &lt;ul&gt;&lt;li&gt;密码：&lt;input type="password" name="password"&gt;&lt;/li&gt;&lt;/ul&gt; &lt;ul&gt;&lt;li&gt;&lt;input type="button" value="登 录"&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/form&gt; 创建程序首页index.jsp.通过 动作标识请求转发到login.jsp。关键代码如下： 123&lt;body&gt;&lt;jsp:forward page="login.jsp"&gt;&lt;/jsp:forward&gt;&lt;/body&gt; 实例运行后，请求将被转发到用户登录页面。 使用子动作标识1、作用：用于为其他标识传递参数。 2、语法格式： 1&lt;jsp:param name=&quot;参数名&quot; value=&quot;参数值&quot; /&gt; name属性：指定参数名称。 value属性：设置对应参数值。 如：通过 标识为 标识指定参数，可以使用下面的代码： 123&lt;jsp:forward page="update.jsp"&gt; &lt;jsp:param name="userId" value="1"/&gt;&lt;/jsp:forward&gt; 上面代码实现在请求转发到update.jsp页面同时，传递参数userId，值为1。 使用动作标识 （重点）1、作用：可在JSP页面中创建一个Bean实例，并且通过属性设置可以将该实例保存在JSP页面的指定范围内。若指定的Bean实例在指定范围内已经存在，则使用该实例，而不会新建。通过 标识创建Bean实例可以在Scriptlet中应用。 2、语法格式： 12345678&lt;jsp:useBean&gt; id="变量名" scope="page|request|session|application" &#123; class="package.className"| type="数据类型"| beanName="package.className" type="数据类型" &#125;/&gt;&lt;/jsp:setProperty name="变量名" property=“*”/&gt; 也可以在标识体内嵌入子标识或其他内容。 123 &lt;jsp:useBean id="变量名" scope="page|request|session|application"&gt; &lt;jsp:setProperty name="变量名" property="*"/&gt;&lt;/jsp:useBean&gt; 下图为 标识中各属性用法。 ​ 图片 id属性：指定一个变量，在定义范围内或Scriptlet中将使用该变量来创建的Bean实例。该变量须符合Java变量命名规范。 type属性：用于设置由id属性指定的变量类型，它可以指定要创建实例的类本身、类的父类或者是一个接口。 使用type属性来设置变量类型语法格式如下： 1&lt;jsp:useBean id="us" type="com.Bean.UserInfo" scope="session"/&gt; 若在session范围内已经存在名为us的实例，则将该实例转换为type属性指定的UserInfo类型并复值给id属性指定的变量；若指定变量实例不存在，则抛出下面异常： 1bean us not found within scope scope属性：该属性指定创建Bean实例的取值范围，省略该属性时值为page。执行 标识首先会在scope属性指定的范围内来查找指定的Bean实例，若该实例存在，则引用这个Bean;否则重建，并将其保存在scope属性指定的范围内。 scope属性的可选值为： 1、page： 2、request：指定创建的Bean实例可以在请求范围内存取，在请求被转发至目标页面中可通过request对象的getAttribute（“id属性值”）方法获取创建的Bean实例。一个请求的生命周期是从客户端向服务器发出一个请求到服务器响应这个请求给用户后结束，请求结束后保存在Bean中实例失效。 3、session：指定创建Bean实例有效范围为session，session是当用户访问Web应用时，服务器为用户创建的一个对象，服务器通过session的id值来区分用户。对某一用户而言，在该范围内中的对象可以被多个页面共享。 可以使session对象的getAttribute（“id属性值”）方法获取创建的Bean实例。 4、application：指定创建的Bean实例的有效范围从服务器启动开始到服务器关闭结束。 application对象在服务器启动时创建，被多个用户共享。所以访问该对象的所有用户共享保存在该对象中的Bean实例。 class属性：该属性指定一个完整的类名，package表包名称，className表示类的文件名称。通过class属性指定的类不能是抽象的，须具有公共且没有参数的构造方法。在未设置type属性时，须设置class属性。 使用class属性定位一个类语法格式： 1&lt;jsp:useBean id="us"class="com.Bean.UserInfo"scope="session"&gt; 程序首先在session范围内查找是否存在us的UserInfo实例，若不存在，则会通过new操作符实例化UserInfo类来获取一个实例，并以us为实例名保存在session范围内。上述用法 标识转换为对应的Servlet代码： 1234567891011com.Bean.UserInfo us=null;synchronized(session)&#123; //获取sesssion范围内名为us的实例 us=(com.Bean.UserInfo) _jspx_page_content.getAttribute("us",PageContent.SESSION_SCOPE); if(us==null)&#123; //若实例不存在 us=new com.Bean.UserInfo(); //创建一个实例 _jspx_page_content.setAttribute("us",us,PageContext.SESSION_SCOPE); &#125;&#125;说明：代码中_jspx_page_context对象为jsp中pageContext内置对象。 class=”package.className” type=”数据类型” 格式如下： 1&lt;jsp:useBean id="us" class="com.Bean.UserInfo" type="com.Bean.UserBase" scope="session"/&gt; ​ beanName=”package.className” type=”数据类型” 语法格式： 1&lt;jsp:useBean id="us" beanName="com.Bean.UserInfo" type="com.Bean.UserBean"/&gt; 使用动作标识使用动作标识上机实践应用Java程序片段动态生成表格将页面转发到用户登陆页面应用JavaBean保存图片信息]]></content>
      <categories>
        <category>JavaWeb起步篇</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web客户端技术基础之CSS]]></title>
    <url>%2F2018%2F01%2F27%2F27--Web%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E4%B9%8BCSS%2F</url>
    <content type="text"><![CDATA[发现看了这两天书，效果还是有的，对Web初步有了一定的了解。边学边写博客，还是挺好的，希望自己可以坚持下去。 今晚学习Web客户端基础知识CSS。主要基础知识点如下三点： CSS概述 如何将CSS嵌入到网页 CSS的语法基础 CSS概述定义：CSS（层叠样式表），可以为HTML的各类元素设置丰富的样式。一个HTML元素可以由CSS设置多个样式，这些样式叠加起来产生综合的显示结果。 CSS优点 拥有丰富的表现力。 使得Web页面数据代码和样式代码分离开来。 HTML和CSS样式比对示例代码如下： 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;应用样式比对&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--使用表格进行布局--&gt; &lt;table border="1" align="center"&gt; &lt;caption&gt;文字成红色，斜体的样式&lt;/caption&gt;&gt; &lt;!--表头--&gt; &lt;tr&gt; &lt;th&gt;HTML标签应用样式&lt;/th&gt; &lt;th&gt;CSS标签应用样式&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;!--使用font标签，指定color属性为红色--&gt; &lt;font color="red"&gt; &lt;!--使用i标签，使得字体为斜体--&gt; &lt;i&gt;JavaWeb你好啊&lt;/i&gt; &lt;/font&gt; &lt;/td&gt; &lt;!--直接使用CSS样式：颜色为红色，字体为斜体样式--&gt; &lt;td style="color: red; font-style: italic;"&gt; JavaWeb你好啊 &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; 效果如下： 如何将CSS嵌入到网页一般有3中方式： HTML标签的style属性1&lt;div style="color: red;"&gt;Hello，2018&lt;/div&gt; 效果如下： 嵌入到style标签里在head头部标签里加入一个style标签，把CSS代码写入到该标签里，这些样式作用于整个页面。 1234567&lt;head&gt; &lt;style type="text/css"&gt; div&#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&gt; 单独写CSS文件，再用link 导入。这种情况HTML与CSS代码分离度最高，在HTML文档中，在HEAD标签里加入link标签，映入需要的CSS文件。 1&lt;link rel="stylesheet" type="text/css" href="test.css"&gt; CSS的语法基础首先说一下CSS的注释代码规则： 1/*...*/ CSS的基本原则是：首先找到目标元素，在设置若干样式。既有如下步骤： 第一步：找到需要应用的样式目标。如表格的行、图片或其他。 第二步：为目标元素设置一个或多个样式。样式涉及字体、颜色、边框、定位等各个方面。 为样式找目标将CSS应用于HTML，需要找到这个元素。找到该元素的是选择器（selector）。按照查找目标方式选择器不同。可分为如下5种： 类型选择器 ID选择器 类选择器 伪类选择器 通用选择器 为目标设置样式样式：字体、颜色、边框、定位等。 样式语法规则：“样式名:样式值” 中间冒号隔开，多个样式用分相隔。例如： 1color:red; 若将样式放在HTML标签的style属性里面，直接遵守以上规则即可。 举例：为段落文字应用红色、加粗样式： 1&lt;p style="color: red; font-weight: bold;"&gt;段落内容&lt;/p&gt; 效果如下： 若将CSS代码放在style标签里，或者单独一个CSS文件，则需要加上选择器和大括号。 有点儿小累，不抛弃不放弃。]]></content>
      <categories>
        <category>JavaWeb起步篇</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web 客户端技术基础之 JavaScript]]></title>
    <url>%2F2018%2F01%2F27%2F27--Web%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80%E4%B9%8BJavaScript%2F</url>
    <content type="text"><![CDATA[小睡了一会，又起来啦。感觉自己很勤奋啊，哈哈。此时此刻，外面下着鹅毛般大雪，父亲已经睡了，我在自己的房间里敲击着机械键盘，听着歌曲，沉迷于学习无法自拔，外面的世界都是远方。 今天简单了解一下JavaScript，知识点很简单。一起来看一下，主要有三点。 JavaScript概述 浏览器中得JavaScript对象模型 JavaScript的事件模型 HTML+CSS+JavaScript应用举例 常见面试题 JavaScript概述定义：JavaScript是一种基于对象的解释性脚本语言，主要在浏览器中运行。他可以直接嵌入到HTML代码中去，建立起一种HTML的对象模型，这种模型采用一种事件响应的模式。例如：单击一个按钮，能出发一个事件，当浏览器捕获到该事件以后，就可以执行相应的JavaScript代码。正是利用这一点，可以很好的与用户进行交互。 浏览器中的JavaScript对象模型浏览器解析HTML时，把浏览器窗口和HTML文档里地内容建立起一套javaScript的对象模型，以便于开发者使用这些对象进行JavaScript编程。下面来看看浏览器为HTML文档建立的对象模型。 长图码上： 来说明一下这些对象： window对象：代表整个浏览器窗口，是所有对象的顶层，在浏览器打开的时候就已经存在。 navigator对象：通过它，可读取到有关浏览器的信息，比如浏览器类型，版本信息。 screen对象：代表屏幕，通过它可获取到客户端屏幕的宽度和高度。 document对象：是整个HTML文档的模型顶端，可以获取到文档里各个元素及其内容，也是开发者使用最多的对象。 history对象：代表浏览器查看网页的历史，可以通过它来前进或后退。 location对象：代表浏览器的地址栏，一般通过它来跳转浏览器访问的地址。 JavaScript的事件模型 JavaScript在浏览器编程，离不开事件。事件是基础，总是由某种动作（如：用户单击按钮）触发事件，然后开始该事件，直到整个功能完成。 大多数HTML标签都可以添加事件。如：鼠标单击、双击。键盘按键灯。 标签的数字型值对应着JavaScript函数。浏览器可以在这些事件发生时执行该函数，从而完成一定的功能。 来一个简单的例子： 1&lt;input type="button" value="按钮" onclick="alert('hello world!')"&gt; 效果如下： HTML+CSS+JavaScript应用举例Web客户端开发的基础是：HTML+CSS+JavaScript。一般不会单独出现，而是糅合在一起使用。下面来看三个简单的应用实例。 二级联动菜单 表格背景变色 推拉式菜单 二级联动菜单表格背景变色推拉式菜单常见面试题1、表单form中常用的input有哪些类型？其区别是什么？ 常用包括： textflied、password、radio、checkbox、select、file、button、submit、 reset、hidden。 文本输入框textflied、password：用于文本的输入，密码输入框比较特殊，会以黑点遮蔽真实值。 选择性输入框radio、select、checkbox：它们都有预设好的值。 按钮button、submit、reset：submit会触发表单的提交，若需要在提交表单时做一些检查，最好是在button上加onclick方法。 隐藏输入框hidden：一般用于保存一些隐藏的参数。 2、一个HTML表格应该包含哪些标签结构？完整HTML表格包含：表格标题、表格头、表格行、表格项。 在table标签里： 表格标题：caption 表格行：tr 表个头：th 表格项：td 上面是对HTML/CSS/JavaScript的一些宏观了解和最基础的知识点。我想在后面的学习过程中，会更加深入的学习这些知识的。今天觉得有一句话很有道理：你所认真的事情，不论结果好坏与否，其过程的一点一滴已经融入了你的血肉！]]></content>
      <categories>
        <category>JavaWeb起步篇</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web客户端技术基础之HTML]]></title>
    <url>%2F2018%2F01%2F26%2F26--Web%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80HTML%2F</url>
    <content type="text"><![CDATA[今天学习Web客户端技术基础，知识量有点儿大，要加把劲儿了，哈哈！即HTML、CSS和JavaScript。知识点如下： 快速掌握HTML CSS基础知识 JavaScript基础知识 HTML+CSS+JavaScript应用举例 二级联动菜单实例 表格背景变色实例 推拉式菜单 小结 今天主要学习HTML基础知识。 快速掌握HTMLHTML概述Web是万维网（WWW,World Wide Web）的简称，它的最基本单位为Web页面（也称网页），本质上是一种文档格式，Web页面是由超文本语言（HTML）编写！ 网页结构、内容格式：HTML标签完成，标签是网页的基本组成单元。 标签构成：标签就是以一个小于号（&lt;）和一个大于号（&gt;）组成的字符串。 开始不以“/”开始，结束以“/“结束。 标签构成：标签名、属性、属性值、内容。 HTML标签形式（4种）1234*、无属性单标签，如：&lt;br&gt;*、有属性单标签，如：&lt;br color="red"&gt;*、有内容双标签，如：&lt;title&gt;我的第一个网页&lt;/title&gt;*、有内容、属性双标签，如：&lt;a href="index.html"&gt;Link&lt;/a&gt; 说明：HTML标签不区分大小写。与为相同标签。 第一个HTML页面先说一下一个最基本的HTML页面是怎样组成的。 文字说明： 1234*、以 &lt;html&gt; 开头，&lt;/html&gt; 结尾*、&lt;html&gt;标签里面嵌套的是：&lt;head&gt;、&lt;body&gt;标签。分别表示头信息、内容信息。*、&lt;head&gt;标签里面可以嵌套&lt;title&gt;标签：表示浏览器窗口标题。*、&lt;body&gt;标签： 表示文档内容。 图片详解如下： 控制段落和文本的标签1、注释标签先来一个特殊又常用的标签，即注释标签： 1&lt;!--这是一段注释。注释不会在浏览器中显示。--&gt; 2、段落相关标签123* &lt;p&gt;...&lt;/p&gt;：paragraph，创建一个段落。* &lt;br&gt;：line break，用于换行。* &lt;hr&gt;：horizontal rule,插入一条横线。可添加color属性设置横线颜色。如：&lt;hr color="red"&gt;。 3、文本相关标签1234567* &lt;center&gt;...&lt;/center&gt;：使放在开始标签和结束标签之间的文本内容居中现显示。* &lt;hn&gt;...&lt;/hn&gt;：标识一个标题。n代1~6，&lt;h1&gt;代表最大标题，以此类推。可添加align属性使得段落内容靠左、居中、靠右显示。如：&lt;h2 align="center"&gt;标题内容&lt;/h2&gt;。* &lt;font&gt;...&lt;/font&gt;： 设置文本字体格式 。一般添加color，size属性。 * size: 1~7整数，数字越大，字体越大。 * color: 可用颜色的英文表示。red,blue,...* &lt;b&gt;...&lt;/b&gt;： 加粗* &lt;i&gt;...&gt;&lt;/i&gt;： 斜体 3、练习运用代码如下： 123456789101112131415161718192021&lt;html&gt; &lt;meta charset="utf-8"&gt; &lt;!--解决字符乱码问题--&gt; &lt;head&gt; &lt;title&gt;枫桥夜泊&lt;/title&gt; &lt;/head&gt; &lt;center&gt; &lt;h2&gt; &lt;!-- 标识一个标题--&gt; &lt;font color="red"&gt;枫桥夜泊&lt;/font&gt; &lt;/h2&gt; &lt;b&gt;作者： 张继&lt;/b&gt; &lt;!--加粗--&gt; &lt;br&gt; &lt;!-- 换行意思--&gt; &lt;p&gt; &lt;!--创建一个段落--&gt; &lt;i&gt; &lt;!--斜体--&gt; &lt;font size="3" color="blue"&gt;月落乌啼霜满天，江枫渔火对愁眠。 &lt;br&gt; 姑苏城外寒山寺，夜半钟声到客船。 &lt;/font&gt; &lt;/i&gt; &lt;/p&gt; &lt;/center&gt;&lt;/html&gt; 效果如下： 如何输入特殊字符特殊字符即指的是：小于号，大于号，空格，制表符等，这儿的知识点，记住这张表就好了！！！ 使用方法使用方法看代码： 1234567891011121314151617181920212223&lt;html&gt; &lt;meta charset="utf-8"&gt; &lt;!--解决字符乱码问题--&gt; &lt;head&gt; &lt;title&gt;枫桥夜泊&lt;/title&gt; &lt;/head&gt; &lt;center&gt; &lt;!--诗歌的标题--&gt; &lt;font size="2" color="gray"&gt;&amp;lt;!--诗歌的标题--&amp;gt;&lt;/font&gt; &lt;h2&gt; &lt;!-- 标识一个标题--&gt; &lt;font color="red"&gt;枫桥夜泊&lt;/font&gt; &lt;/h2&gt; &lt;b&gt;作者： 张继&lt;/b&gt; &lt;!--加粗--&gt; &lt;br&gt; &lt;!-- 换行意思--&gt; &lt;p&gt; &lt;!--创建一个段落--&gt; &lt;i&gt; &lt;!--斜体--&gt; &lt;font size="3" color="blue"&gt;月落乌啼霜满天，江枫渔火对愁眠。 &lt;br&gt; 姑苏城外寒山寺，夜半钟声到客船。 &lt;/font&gt; &lt;/i&gt; &lt;/p&gt; &lt;/center&gt;&lt;/html&gt; 效果如下图所示： 表格相关标签先说几个缩写：t:table,r:row,h:head,d:data 定义表格定义表格用table标签：表格所有内容都放在table标签里面。 12345&lt;table&gt;&lt;/table&gt;举例：&lt;table border="1" align="center" bgcolor="white"&gt;&lt;/table&gt; * * *border : 定义表格边框的宽度，从0开始的整数，0代表没有边框；*align : 表格对齐方式，左中右。*bgcolor ： 背景颜色 定义表格标题定义表格标题使用caption定义。 1&lt;caption&gt;XXX成绩单&lt;/caption&gt; 定义行tr标签代表表格的行。 123&lt;tr align="center" valign="middle"&gt;&lt;/tr&gt;* align : 控制这一行的水平对齐方式。左中右* valign : 控制这一行的垂直对齐方式。上中下 定义表头th标签。 12&lt;th width="50"&gt;英语&lt;/th&gt;&lt;th width="50"&gt;数学&lt;/th&gt;* width : 调整列的宽度，该宽度会影响下面单元格的宽度。 定义单元格单元格是表格的最小组成单元，用td标签定义，专门用于放置具体的数据。 12&lt;td&gt;90&lt;/td&gt;&lt;td&gt;75&lt;/td&gt;* 说明：表格行还可以按照头部、身体、和底部来进行划分，分别使用&lt;thead&gt;,&lt;tbody&gt;,&lt;tfoot&gt;. 应用举例下面来一个完整使用表格标签定义的一个成绩单实例。 1234567891011121314151617181920212223242526272829303132333435363738&lt;html&gt; &lt;meta charset="utf-8"&gt; &lt;!--解决字符乱码问题--&gt; &lt;head&gt; &lt;title&gt; 2018年度西安电子科技大学XXX班成绩单 &lt;!--文档标题--&gt; &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--定义一个边框为1，居中对齐，背景颜色为白色的表格--&gt; &lt;table border="1" align="center" bgcolor="white"&gt; &lt;!--表格的标题为：2018年度西电XXX班成绩单--&gt; &lt;caption&gt;2018年度西电XXX班成绩单&lt;/caption&gt; &lt;!--定义表头行，水平居中，垂直居中--&gt; &lt;tr&gt; &lt;th width="100"&gt;姓名&lt;/th&gt; &lt;!--定义表头姓名--&gt; &lt;th width="50"&gt;英语&lt;/th&gt; &lt;th width="50"&gt;高数&lt;/th&gt; &lt;th width="80"&gt;C语言&lt;/th&gt; &lt;th width="150"&gt;Java程序设计&lt;/th&gt; &lt;/tr&gt; &lt;!--定义数据行，表头--&gt; &lt;tr&gt; &lt;td width="100"&gt;张三&lt;/td&gt; &lt;td width="50"&gt;89&lt;/td&gt; &lt;td width="50"&gt;90&lt;/td&gt; &lt;td width="50"&gt;98&lt;/td&gt; &lt;td width="50"&gt;99&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td width="100"&gt;李四&lt;/td&gt; &lt;td width="50"&gt;86&lt;/td&gt; &lt;td width="50"&gt;78&lt;/td&gt; &lt;td width="50"&gt;83&lt;/td&gt; &lt;td width="50"&gt;100&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; 效果如下，我用截图来表示： HTML交互式表单交互性强是Web页面最大的特点之一。 先说几个概念： 表单元素：放在表单中的元素（控件），如：文本输入框、按钮、下拉菜单、单选框、复选框等。 请求参数：用户通过控件输入的数据。 如何定义表单定于表单用form标签。在form之间的定义的所有控件都是表单元素。 1&lt;form action="服务器端请求URL" method="post | get"&gt;&lt;/form&gt; 说明： 服务器端URL作用：将表单中的数据全部发送到该URL。 URL : 地址 绝对地址：绝对地址以“/”开头，从该站点的根目录开始寻址。 相对地址：相当于当前页面的目录开始寻址，不以“/”开头。 表单提交方式（两种） post： 表单的数据存放在HTTP请求正文里。 get：表单数据直接被追加到请求的URL后面。 如何定义表单控件表单控件用input定义。 1&lt;input type="控件类型" name="参数名字" value="参数得值"&gt; 说明： type： 认识为哪种类型 name： 定义一个请求参数得名字。 value：通过value值得到参数的值。 文本输入相关控件允许用户通过键盘输入数据。文本输入控件有3个。 文本框：单行输入控件，适内容少文本。如：用户名、姓名等。 密码输入框：类似于文本框，不同点在于会隐藏输入的内容。 文本域：用于多行输入。如留言板输入框等。 示例代码如下： 123&lt;input type="textfield" name="username" value="StormWang"&gt;&lt;input type="password" value="123456"&gt;&lt;textarea name="message"&gt;&lt;/textarea&gt; 效果如下： 选择输入相关控件该控件指的是：提供几个有限的选择项。用户只需要选择其中一项或多项即可。主要有以下3种。 下拉菜单：包含一个下拉列表。下拉菜单用select定义，控件名字用select标签的name属性定义，值为option的value值。列表项用option定义。 1234&lt;select name="city"&gt; &lt;option value="bj"&gt;北京&lt;/option&gt; &lt;!--定义一个选项。显示为"北京"，值为“bj”--&gt; &lt;option value="sh"&gt;上海&lt;/option&gt;&lt;/select&gt; 效果如下： ​ 单选框：只能选择一个选择框。 123&lt;!--定义性别选择框，只能二选一--&gt;&lt;input type="radio" name="gender" value="male"&gt;&lt;input type="radio" name="gender" value="female"&gt; 效果如下： ​ 复选框：可选多个选择框。 1234&lt;!--定义爱好选择框，可多选--&gt; &lt;input type="checkbox" name="hobby" value="pingpang"&gt; &lt;input type="checkbox" name="hobby" value="football"&gt; &lt;input type="checkbox" name="hobby" value="basketball"&gt; 效果如下： ​ 按钮相关控件按钮根据用途不同可分为3类： 普通按钮：type=button，为普通按钮，没有默认触发事件，但可以通过onclick属性添加用户自定义事件。 12&lt;!--定义了一个普通按钮--&gt;&lt;input type="button" name="one_button" value="一个按钮"&gt; 来看看效果：​ ​ 重置按扭：type=reset,通过单击他可将表单内所有控件的值设置为空值。 12&lt;!--重置按钮--&gt; &lt;input type="reset" name="one_reset" value="重置"&gt; 提交按扭：type=submit,通过单击他可以提交表单，提交地址为form标签的action属性所指定的服务器的URL。 12&lt;!--提交按钮--&gt;&lt;input type="submit" name="one_submit" value="提交" 效果图如下： 应用举例模拟用户注册的一个表单，包含用户注册时需要的一些信息。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;html&gt; &lt;meta charset="utf-8"&gt; &lt;!--解决字符乱码问题--&gt; &lt;head&gt; &lt;title&gt;用户注册&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--定义一个表单action=XXX.jsp，method=post--&gt; &lt;form action="index.html" method="post"&gt; &lt;table border="1" align="center"&gt; &lt;!--定义标题--&gt; &lt;caption&gt;用户注册&lt;/caption&gt; &lt;!--定义用户名输入框--&gt; &lt;tr&gt; &lt;td&gt;用户名：&lt;/td&gt; &lt;td&gt; &lt;input type="textfield" name="username" &gt; &lt;/td&gt; &lt;/tr&gt; &lt;!--定义密码输入框--&gt; &lt;tr&gt; &lt;td&gt;密码：&lt;/td&gt; &lt;td&gt; &lt;input type="password" name="password"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!--定义性别输入框--&gt; &lt;tr&gt; &lt;td&gt;性别：&lt;/td&gt; &lt;td&gt; &lt;!--定义男性选择框--&gt; 男&lt;input type="radio" name="gender" value="male"&gt; &lt;!--定义女性选择框--&gt; 女&lt;input type="radio" name="gender" value="female"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!--定义爱好选择框--&gt; &lt;tr&gt; &lt;td&gt;爱好：&lt;/td&gt; &lt;td &gt; 乒乓&lt;input type="checkbox" name="hobby" value="pingpang"&gt; 足球&lt;input type="checkbox" name="hobby" value="football"&gt; 篮球&lt;input type="checkbox" name="hobby" value="basketball"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!--定义个人介绍文本域--&gt; &lt;tr&gt; &lt;td&gt;个人介绍：&lt;/td&gt; &lt;td&gt; &lt;input type="textarea" name="introduction" size="20"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;!--定义提交按钮--&gt; &lt;tr&gt; &lt;td colspan="2" align="center"&gt; &lt;input type="button" name="submit" value="提交"&gt; &lt;input type="button" name="reset" value="重置"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 现在来看看效果： 其他常用标签超级链接标签功能：用户单击超级链接，从一个页面的一部分跳转到另一部分，或从一个页面跳转到另一个页面。 定义： 用a标签来定义超级链接，有2个属性，href,target。 12345&lt;a href="资源URL" target="目标框架"&gt;资源信息的描述&lt;/a&gt;说明：* URL地址：绝对地址/相对地址。* 空连接：用“#”井号代替。* target：指定该超级链接的信息资源打开的目标框架。框架有：本窗口、一个新窗口、窗口里的一个框架。 示例代码： 12345&lt;!--定义超级链接--&gt;&lt;a href="资源URL" target="目标框架"&gt;资源信息的描述&lt;/a&gt;&lt;a href="index.html"&gt;一个相对地址链接&lt;/a&gt;&lt;a href="/javaweb/html"&gt;一个绝对地址链接&lt;/a&gt;&lt;a href="http://www.163.com"&gt;网页主页&lt;/a&gt; 效果： 图片标签图片格式： GIF JPG PNG … 定义： img标签 123456&lt;!--图片标签--&gt; &lt;img src="图片URL" width="宽度" height="高度"&gt;说明：* src： 指定图片的URL，可以是本服务器地址，也可以是其他网站地址。* width： 设定图片宽度，单位：像素* height： 设定图片高度。 注意： 图片也可以使用超级链接。将img放到a之间。 div块标签div标签代表division（块，区）的意思。 示例代码： 12&lt;!--div标签--&gt; &lt;div style=""&gt;...&lt;/div&gt; 作用：用于页面布局。 现阶段DIV+CSS： div来包含数据，css来展现样式。css在style属性中进行设置。 学习知识总是需要静下心来一步一步走。阅读累了吧，一起听首歌曲放松一下吧。给大家分享一首许巍 救赎之旅]]></content>
      <categories>
        <category>JavaWeb起步篇</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[驾驭 JavaWeb 开发环境]]></title>
    <url>%2F2018%2F01%2F25%2F--%E9%A9%BE%E9%A9%ADJava-Web%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[“工欲善其事，必先利其器”！今天学习Java Web开发所需要的环境。主要有以下几个知识点： 开发工具包JDK Web服务器 数据库 IDE(集成开发环境)Java Web所需要的开发环境 开发工具包JDKJDK 包括运行Java程序所需要的JRE(Java Runtime Enviroment,Java 运行环境)及其开发工程中常用的库文件。 JDK/JRE/JVM的区别: Web服务器Web服务器试运行及其发布Web应用的容器，只有将开发的Web项目放置到其中，才能使网络中的所有用户通过浏览器访问。比较长用的有如下几种： BEA WebLogic服务器 IBM WebSphere应用服务器 Tomcat服务器 数据库开发动态网站时数据库是必不可少的，它主要用来保存网站中需要的信息。根据网站的规模采用合适的数据库。如下： 大型网站： Oracle 中型网站： SQL Server 或MySQL 小型网站： Microsoft Access (具有方便、灵活的特点，但是功能远不如SQL Server和MySQL） Web浏览器浏览器是客户端访问Web的应用工具，与开发JSP应用关系不大。所以开发JSP对浏览器的要求不高，任何支持HTML的浏览器都可以。目前比较流行的Web浏览器是IE 和火狐浏览器。 安装和配置JDK关于安装和配置JDK在我前面的学习中，也写过博客做过总结。就不再累赘说了。大概可分为以下几个步骤： 下载JDK 安装JDK 在Windows系统下配置和测试JDK 安装和配置 Tomcat大致分为以下几个步骤： 获取Tomcat 说明：“ZIP”对应的是Windows下的版本，下载后是一个压缩文件，解压即可使用。tar.gz为Linux平台下的开发包。 熟悉Tomcat 修改Tomcat的默认端口 熟悉Tomcat 下图为Tomcat的目录结构和文件。 Tomcat目录中的关键目录及其文件的作用： bin： 存放各种平台下启动和关闭Tomcat的脚本文件，包括两个关键文件：startup.bat、shutdown.bat，前者启动，后者关闭Tomcat文件。 conf: 用于保存Tomcat的配置文件。 主配置文件：server.xml;所有Web应用的配置文件：web.xml; 定义Tomcat配置用户的权限和安全：tomcat-users.xml lib: 存放Tomcat服务器和所有Web应用都能访问的JAR文件。 logs: 存放Tomcat的日志文件。 temp: 临时文件夹，若Tomcat运行时有临时文件，则保存在此目录中。 webapps: Web应用的发布目录，把Java Web站点或war文件放入这个目录下，即可通过Tomcat服务器访问。 work ： Tomcat解析JSP生成的Servlet文件存放在这个目录中。 修改Tomcat的默认端口打开conf 目录下的servlet.xml文件，找到相应代码块，即可改为其他端口。建议使用默认的8080端口。 若修改成功后须要重启Tomcat。 Eclipse开发工具的安装和使用 要下载适用于Java开发人员创建Java EE和Web应用程序的eclipse，包括Java IDE，Java EE，JPA，JSF，Mylyn等工具。 下载地址 安装eclipse中文语言包 做好项目开发的准备工作主要有以下两点： 集成eclipse与Tomcat ​ 完善Web项目开发所需要的配置 为eclipse指定Web浏览器 默认情况下，使用其系统默认的Web浏览器浏览网页，但在开发过程不方便，为其指定一种浏览器。具体方式不再阐述，百度 ​ 指定JSP页面的编码格式。百度 虽然有时候我走的很慢，但我相信自己可以走的更远！加油！！！]]></content>
      <categories>
        <category>JavaWeb起步篇</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 语言和 Web 应用开发描述]]></title>
    <url>%2F2018%2F01%2F24%2FJavaWeb01%2F</url>
    <content type="text"><![CDATA[寒假放假已四天了，刚去老家浪完亲戚。今天开始学习了，每天给自己定个小目标，达成自己的小目标，写作和阅读同样需要耐心！！！ 今天主要学习三部分： Java语言简介 Web应用开发简介 用Java进行Web开发 Java语言简介Java语言的特点： 平台无关性： 一次开发，随处运行。 面向对象： 以更符合人类思维方式来思考问题。 安全性： Java语言直接操作内存的地方少，更容易回收系统资源。 并发编程： Java包装的多线程开发模式，使得开发更容易，运行效率更高。 异常处理机制：帮助程序员更容易地为用户定位各种错误。 丰富的类库： JDK本身包含了许多丰富的类库，许多第三方的类库也是开源或者免费提供的。 Java语言的发展现状： 网络环境开发：理论上来讲，Java可以应用到任何的领域，只是网络环境上的开发，是它应用最广泛和最成功的的地方。 桌面应用程序：例如：IBM支持的Eclipse,Oracle数据库、Borland的JBuilder、Sun的Netbeans等。当需要开发跨平台的开发程序的时候，Java往往是最好的选择。 Java语言的发展前景：当今世界的IT技术发展异常迅猛，Java语言也不断的发展，在未来的开发环境里，Java技术会在以下几个方面有很好的发展前景。 1、大型服务程序。 目前许多大型的服务器程序（如：电信计费系统、银行记账系统、证券业务系统等）都是在UNIX或Linux系统上运行，这些系统普遍有几个特点，就是安全、高效、集群等。使用Java语言开发，能够很好的满足这些需求。Java的跨平台性，使得程序可以在Windows上开发，在UNIX上运行，开发效率高；Java开发的程序往往比较健壮和安全，不易出现系统崩溃等大问题；Java的服务器程序大多有比较好的集群支持，不会使用操作系统底层的API来实现集群。另外，Java在这些方面也非常丰富的类库以供使用，设计模式也很成熟。 2、信息管理系统。以前大多数信息管理系统采用C/S结构开发，需要一个专门的客户端；随着浏览器的富客户端技术(RIA)日渐成熟，尤其是Ajax技术的大量普及，信息管理系统越来越多的采用B/S结构。Java的.Net技术也在这方面很有优势。 3、嵌入式开发。 以前的嵌入式开发（如：电视机顶盒、手持智能设备等）由于硬件配置比较低，大多采用C/C++这类效率优先的语言进行开发，这种方式开发难度大且几乎不具有移植性。随着J2ME技术的应用和普及，尤其是手机行业，开发这类移动软件容易多了，移植性也增强了。 Web应用开发简介Web程序的运行机制： Web程序总是包含两部分：（1）、浏览器客户端程序（2）、服务器端程序。 Web程序基本组成元素： 网页。一般代表网站中的一页，通常是超文本标记语言（HTML）格式（文件拓展名为.html，.htm，.asp，.aspx，.php或.jsp）。浏览器通过解析网页向用户呈现文字、图片等。 Web程序运行机制概括：用户通过浏览器向服务端发送HTTP请求，服务器端接受请求并处理，然后将处理结果返回给客户端浏览器，浏览器得到处理结果并呈现给用户。 Web的特点： 1、丰富的图形化功能 ​ 一页上可以显示丰富多彩的图形和文本，它具有将图形、音频、视频信息集合于一体的特性。 2、易于导航 Web的超级链接机制，把全联系起来，用户只需要从一个连接跳到另一个链接，就可以在各页面、各站点之间进行浏览了。而且，超级链接也增强了Web技术的互操作性。 3、终端平台无关性 访问Web程序是通过 浏览器（Browser）实现。不论是Windows，Linux还是别的操作系统都可以安装浏览器软件。且大多数系统都自带浏览器软件。 4、信息是分布式的 大量的图形、音频和视频信息资源会占用大量的磁盘空间，Web可以把这些资源进行整合，将物理上并不在一起的信息资源组成一个逻辑上的整体，用户就可以以最小的代价访问这些资源。其实，用户根本不知道这些资源是分布在不同地方的。 5、信息的动态性Web技术的发展 HTML: 超文本语言，用来表示网上信息的一种符号标记语言。 DHTML: 与HTML最大区别是，能够动态改变网页的内容。有两个基本组成：（1）、级连格式（CSS）(2)、脚本语言。 CSS为HTML带来了两点很大的好处：一是丰富了HTML的变现力，另一点是实现了内容与变现的分离。 有了CSS之后，HTML就只用来表示网页元素和内容，如何呈现给用户由CSS来完成，由此，提高了开发效率，降低了维护难度。 动态语言: 动态语言也是嵌入到HTML代码中间的，只不过这些代码是在服务器端执行，返回到客户端时已是执行以后得页面内容了。ASP/PHP/JSP是使用最多的3种动态语言。 系统解决方案: 略 Web技术的发展开发一个Web应用的基本步骤一个典型的Web应用程序会包含若干网页，这些网页是用户最终看到的内容，根据用户的可看到的网页内容和网页之间的联系，可以确定该Web应用程序提供了多少功能，然后再组织服务器端来实现这些功能。 基本步骤如下： 根据特定的业务需求完成页面实现。 例如一个登陆程序会包含2个页面，一个是登陆页面，另一个是登录完成成功以后的页面。 完成服务器端程序的实现。 例如：登录程序需要从客户端接受2个参数: 用户名和密码。然后验证参数是否正确（可能会访问数据库），正确则转到成功页面。失败则返回登录页面。 把页面和服务器端程序部署到Web服务器里面。 一般是直接复制文件到服务器的相应位置，必要时还需要做相应配置。 通过浏览器访问Web程序 在浏览器地址栏输入相应地址（格式：http://&lt;主机名或IP地址&gt;:&lt;端口号&gt;/&lt;应用的名字&gt;/&lt;页面的名字&gt;）并按下Enter键，就可以访问Web程序了。 用Java进行Web用开发Java Web开发的基本思想Java Web开发指的是使用 Java语言，按照 Java EE规范开发Web应用程序。这些应用程序需要部署到符合该规范的Web容器里面。 Java EE规范很广泛，Web只是其中一个方面，它定义了一个标准的Java Web应用程序的各种规范，包括目录结构、描述文件、Servlet、JSP等。 目录结构 JavaWeb程序的所有文件需要包含在一个文件里面。该文件夹目录结构有一定的规范。 需要包含文件夹名为：“Web-INF”。该文件夹对客户端来说不可见。”Web-INF”文件夹中还包含了存放类文件夹的” classes “文件夹，和存放类库的文件” lib “，以及Web描述文件”Web.xml“ ; 与“Web-INF”文件夹同一层次的目录存放的是 JSP、HTMl等页面文件。 Web描述文件 Web描述文件指的是“web.xml”。是整个Web应用程序的配置文件，通过它定义 Servlet、过滤器、监听器和一些参数等信息，（定义的是4个哦）。Web容器通过该文件的配置来控制整个Web应用程序的行为方式，详细配置见JavaWeb05。 Servlet Servlet是服务器端处理HTTP请求的基本组成单元，包括JSP、过滤器等在内的许多技术都基于或依赖于Servlet而实现。Servlet是符合一定规范的Java类，它存活于Web容器里面，由容器来控制Servlet的生命周期。 JSP JSP是参考其他动态语言而设计的，脚本语言是Java，但是它的本质也是Servlet,它比其他动态语言更强大。JSP作为Java web开发不可或缺的一部分，在大多数开发中，它往往只是用于显示数据的，而很少负责业务逻辑。 熟悉JSP开发，并不意味者熟悉Java Web的开发，只能说是使用动态语言开发Web程序。 JavaEE 与.NET技术比较略。很多知识需要自己学会上网求知。 虽然有时候我走的很慢，但我相信自己可以走的更远！加油！！！]]></content>
      <categories>
        <category>JavaWeb起步篇</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开启 JavaWeb 之门]]></title>
    <url>%2F2018%2F01%2F23%2F-%E5%BC%80%E5%90%AFJava-Web%E4%B9%8B%E9%97%A8%2F</url>
    <content type="text"><![CDATA[开启Java Web之门，希望是一个好的开始。 主要学习以下几个知识点： Java概述 Web应用概述 Web应用程序的工作原理 网络程序开发体系结构 Java Web网站的基本构建流程 小结 Java概述相信既然学习到了Java We这个地步，对Java这门语言已经或多或少的了解了一些，这里就简单的描述一下： 1、Java是1995年由Sun公司推出的一种极富创造力的面向对象的程序设计语言。 2、Java语言的特点是：简单、面向对象、分布性、可移植性、安全性、健壮性（6个）。 Java Web概述JavaWeb是指用Java语言解决先关Web领域的技术总和，一个Web应用程序包括Web客户端和Web服务器两部分，即基于B/S(浏览器/服务器)架构的应用程序。 Web客户端Web客户端通常是指用户机上的浏览器，如微软的IE或火狐浏览器。客户端不需要开发任何用户界面，而同一采用浏览器即可！ Web服务器Web服务器是一台或多台可运行Web应用程序的计算机，通常我们浏览器中输入的网址即为服务器的地址。 过程是这样的： 用户在浏览器中输入网站地址并按回车键后，请求即被送到Web服务器。 服务器收到请求后，会返回给用户带有请求资源的相应信息。 图片详解如下： Java Web成功案例 清华大学本科生招生网 工商银行网站 交通银行网站 邮政储蓄银行网站 …… Web应用技术客户端应用技术目前常用有以下四种： HTML语言 CSS语言 Flash 客户端脚本技术 HTML语言HTML语言是客户端技术的基础，主要用于显示网页信息。不需要翻译，由浏览器解析执行。 说明：HTML语言不区分大小写！！！与Java不同。 CSS语言CSS为样式表（Style Sheet）技术，也称为“层叠样式表”。 作用如下： 制作网页时，采用CSS样式，可更加精确控制页面 布局、字体、颜色、背景和其他效果。 优点如下：（样式表文件只是简单的文本格式，不需要安装第三方插件） 美化页面 优化网页速度（包含许多滤镜效果，避免大量使用照片） FlashFlash是一种交互式矢量动画制作技术，可包含动画、音频、视频及其应用程序。文件较小，适合在Web中应用。 客户端脚本技术客户端脚本技术是指嵌入到Web页面中的程序代码，这些代码是一种解释性语言，浏览器可以解释客户端脚本。通过脚本语言可以实现以编程方式控制页面元素，从而增加页面的灵活性。常用客户端脚本语言有如下两种： JavaScript VBScript 说明： 目前应用最广泛的客户端脚本语言是JavaScript,他是Ajax的重要组成部分。 服务器端应用技术目前常用服务器端技术如下： CGI : 通用网关接口，最早用来创建动态网页的一种技术，可以使浏览器与服务器之间产生互动关系。 ASP : (Active Server Page)是一种使用很广泛的开发动态网站的技术，它通过在页面代码中嵌入VBScript或JavaScript脚本语言来生成动态的内容。 PHP : (Personal Home Page)是一种开发动态网页的技术，其语法类似于C。并且混合了Perl、C++、和Java的一些特性。是一种开源的Web服务器脚本语言。· ASP.NET JSP : (Java Server Page是以Java为基础开发的，沿用Java强大的API功能。JSP页面中的HTML代码用来显示静态内容部分；嵌入到页面中的Java代码与JSP标记来生成动态的内容部分。JSP允许开发人员编写自己的标签库来完成应用程序特定的要求。他可以被预编译，从而提到运行速度。 Web应用程序的工作原理Web应用程序大体分为两种： 静态网站 动态网站 静态网站静态网站：即静态页面的浏览。使用HTML语言编写，放在Web服务器上。 其工作流程大体如下： 用户使用浏览器通过HTTP协议请求服务器上的Web页面，Web服务器处理接受到的用户请求后发送给客户端浏览器显示给用户。 图片详解如下： 动态网站动态网站：即根据用户请求动态生成页面信息。使用HTML语言和脚本语言（如JSP、ASP、或PHP）编写，并部署到Web服务器上。 其过程大体如下： Web服务器处理动态脚本代码并将其转换为浏览器可以解析的HTML代码，最后返回给客户端浏览器显示给客户 图片详解如下： 网络程序开发体系结构大体分为两种：基于客户端/服务器、浏览器/服务器、 C/S B/S什么是C/S结构 即客户端/服务器。 如下图所示： 服务器：通常采用高性能的PC或工作站，并采用大型数据库系统（如Oracle或SQL Server）。 客户端：需要安装专用的客户端软件。 优点：可充分利用两端硬件环境的优势，将任务合理分配到客户端和服务器，降低系统开销。主要流行于2000年以前。 什么是B/S结构即浏览器/服务器 如下图所示： 客户端： 无需开发任何用户界面，统一采用IE或火狐浏览器等·。 服务器： 通过Web浏览器向Web服务器发送请求，由Web服务器处理并将处理结果逐级返回给客户端。 B/S 与 C/S的区别从开发和维护成本、客户端负载、安全性三方面： 1、先说说B/S的优缺点： 只需更新服务器端软件，客户端只需要重新登录系统即可。 客户端只需要显示，事务处理逻辑部分交给服务器端处理。导致服务器负载过多，一旦服务器宕机，后果不堪设想，许多单位都有数据库存储服务器，以防万一！ 安全性较低 2、C/S的优缺点： 需要更新客户端和服务器两端软件和程序，成本高。 客户端负载大，维护复杂。 安全性较高 Java Web网站的基本构建流程我觉得很重要！！！ 构建一个JavaWeb网站的基本流程如下图所示： 即有如下10个步骤： 步骤一： 搭建开发环境 步骤二：确定网站主题 步骤三：搜集资料 步骤四：规划网站 步骤五：构建数据库 步骤六：开发网站 步骤七：测试网站 步骤八：上传网站 步骤九：推广网站 步骤十：维护更新小结 本篇博客主要写了Java和JavaWeb、JavaWeb开发的成功案例，以及Web应用技术，然后比较了网络程序开发的两种体系结构，并说明了Web应用开发所采用的体系结构。最后详细介绍了JavaWeb网站开发的基本流程。 虽然有时候我走的很慢，但我相信自己可以走的更远！加油！！！]]></content>
      <categories>
        <category>JavaWeb起步篇</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集成 Eclipse 与 Tomcat]]></title>
    <url>%2F2018%2F01%2F22%2F22--%E9%9B%86%E6%88%90-Eclipse-%E4%B8%8E-Tomcat%2F</url>
    <content type="text"><![CDATA[今天来总结一下Eclipse和服务器Tomcat的集成。我是根据这本书上配置的，所以就把这本书上的配置步骤列在下面以供再学习。 第一张： 第二张： 第三张： 第四张： 第五张： 以上就是JavaEE版Eclipse集成服务器Tomcat，和为Eclipse指定Web浏览器，指定JSP页面的编码格式步骤。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>Eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows10 安装 Tomcat 步骤]]></title>
    <url>%2F2018%2F01%2F22%2Fwindow10%E5%AE%89%E8%A3%85tomcat%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[开启javaWeb学习之路 一、下载 Tomcathttps://tomcat.apache.org/download-90.cgi 二、安装 Tomcat解压后，放到指定目录下。 三、配置环境变量1 、jdk环境变量配置，在在有关java学习部分已经配置好了应该。2、开始配置tomcat环境变量： CATALINE_BASE :E:\apache-tomcat-7.0.84-windows-x64\apache-tomcat-7.0.84 CATALINE_HOME :E:\apache-tomcat-7.0.84-windows-x64\apache-tomcat-7.0.84 PATH中添加：%CATALINA_HOME%\lib;%CATALINA_HOME%\bin 3、打开cmd(win+R),进入tomcat的bin目录下，执行service.bat install，当出The service &#39;tomcat 9&#39;han been installed则说明安装成功。下面我们来验证一下吧！ 四： 启动 Tomcattomcat路径下的bin文件夹内双击打开tomcat9w.exe，在打开的软管理软件内点击“start”即可 五： 检验是否安装成功浏览器打开:http://localhost:8080/若打开成功，则说明安装成功了！！！]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017年终总结]]></title>
    <url>%2F2017%2F12%2F31%2F--2017%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[今天在微博上看到了这样的文字，2017年12月31日后，1999年12月31日，也是所有的90后都十八了，成为了法定成年人。突然有一种莫名的感受，晚上的时候朋友圈里便刮起了一阵向自己18岁说再见、晒图片的风暴，诉说着自己18岁的模样。我也去空间找了一张那时的模样。18岁，是一个…emmm怎么说呢，一个转折点吧。18岁，我们高三，决战高考，告别高中岁月，踏入大学校门；18岁，告别青涩的青少年时代，步入成年人行列，慢慢的走向成熟和稳重，但也不失18岁前的单纯和无知，但也更多了一些杂事在心头。总之，18岁，无怨也无悔！ 总结一下2017吧，说起这一年，总体大概就分为两个部分吧，学习和生活。 先来说说生活，我想按时间轴来回顾自己的2017！ 2017年1月：1月初，微信小程序正式上线，很新奇。1月中旬，我在大学的第一个寒假里，选择了去和一群人学习。虽然只有短短10天，但每一天，每一个人，都会带来一份惊讶和感动。认识了一帮好人，做了一些终身难忘的事儿。1月21日，我告别了他们，回家了。记得当时，感触很多。 2017年2月：学习完回家后一直和家人待在一起，期间下了一场雪，很开心，在家的时光，没有学校里的快节奏，过得舒心极了。期间，去了一趟银川，见了见老同学，还和田林学长在六盘山门口吃了个饭，快乐的回忆。2月24日，和勇哥一起来到了学校，开启新的一学期，大一下学期。 2017年3月：这个月，新的一学期开始了。3月18日，我们去烧烤了，大一的我们去的人很多，那天是和张明、马林贵、马小军学长骑行去的，回来的时候，一鼓作气，骑回到了学校，和他们同时回到学校。那时候，校园里花正开，好一番景象！ 2017年4月：3月末4月初的学校，春暖花开。每天晚上，学长学姐我们都约着跑步，绕学校一圈，大概5.5公里，跑下来，一天的疲惫都会感觉被汗水带走了。4月，清明节的第一天，我们便开始了来回长达120公里的骑行。一趟周至，转转水街，一路上骑着自行车跟在大部队的后面听歌溜达，时而追赶，时而说笑，反正我记得，骑行来回的三天，我都会发一条朋友圈。4月29号，和高中的几个同学，我们爬了一趟华山，一路上，酸甜苦辣都有，回来一鼓作气还写了一篇文章，发表在了公众号上。这一月，浪狼的一月。 2017年5月：5月，我们赶了一个小尔迪和涛哥，马总。5月，我们金工实习，磨出属于自己的一个小锤子。5月，有很多一批人，总在凌晨的四点多相互叫着起床，一起吃封斋饭，封莱麦丹月份的斋。记得，一天都没拉下。电话里告诉我父母，说自己的儿子长大了。那些天，每晚的礼拜下，我都祈求着，给我们健康，幸福，知识和快乐，祈求给我们正道和坚忍！5月26日，我们的大四欢送会正式表演，而我和学长张明演出了其中一个节目相声。那天，第一次穿正装，一副老气横秋的大人模样。5月，是一群人的5月。 2017年6月：6月，注定是一个快乐与痛苦并存的6月吧。是一个美丽的季节，是一个难忘的季节，也是一个离别的季节。校园里除了一些燥热外，真的很漂亮。6月11日，和几位学长一起穿着学士服拍了很多照，定格了对他们来说再也回不去的风景。6月21日，是一个尊贵的夜晚，是盖德尔夜，那一晚，又有一群人，直到两点才睡下，做着有意义而有难忘的事情。那一晚，可以说是我内心最平静的一晚，再没有那样平静过了。6月22日，丢了手机，短短几天感觉和世界完全隔绝了一般，无法想象如今没有手机的生活。可能真会错过一个亿！6月28号，我们送走了大四最后几位毕业的学长学姐，可谓打心底里感慨时间流逝的飞快。那时，便告诉自己，一定要珍惜和善待身边的每一位兄弟姐妹，想着和他们在一起的时光将会是大学里最美的回忆。 2017年6月，也是我因为情感而情绪中的低谷。不眠的夜晚，期末考试的焦虑，压得我踹不过气来。喜欢一个女孩，问我为什么，我也说不出来。那时，每晚的心里话和小情绪都写在留言里。后来的后来，再回首，我也说不出来个一二三，喜欢就是喜欢。或许是因为太年轻吧。这一月，读了大冰的一部小说《好吗？好的》，记得在C楼和勇哥一起自习，他在准备期末考试，我却因为情感的低迷，无心学习，却在大冰的书中，找到了一个说不出来的世界。反正很美好吧。 2017年7月：正式进入期末备考阶段，每天都是打了鸡血学习吧。当身心全部都投入到某件事情上时，会发现，那真是一种幸福。7月15日，我大学的四分之一正式画上句号。大一第二学期结束了。 大学以来的第一个暑假，我选择了和学长们去另一个地方学习。这个暑假，真的过的是一个又有意义，又很仓促的的暑假。和学长们在那里认识到的人，学到的东西，还有给人印象和影响，真的深深地刻在了脑海里，感谢他们，感谢那二十几天。也在那二十天里，我才决定放下这一段熬人的感情，或许这是成长的一部分吧！ 2017年8月：我回了趟老家海原，去了趟银川，去了趟舅舅家，一个圈下来，便已匆匆忙忙来到了学校，提前了几天，只是为了参加一个Java培训。最开始的几天，感觉哇真好，还能免费培训，每天朝九晚五挤公交，中午便在那个培训地点的清真窗口上吃一顿，一种上班人的感受在心底已开始泛滥。后面的某一天，负责人把我叫去聊天，聊了很久。说到底，要交一万多元钱，保证可以怎样怎样，回来后，第二天再也没去，一觉睡到天荒！去你的小杰瑞，我哪儿有钱给你，自身难保呢~。8月31日，古尔邦节，在这边过的。一个繁忙的8月，仓促的8月。 2017年9月：又是9月，不在是单纯的别人的学弟学妹了，我们迎来了我们的学弟学妹。那一天，是我最累的一天，也是这次来西安后，做的第一件有意义的事情了。接了一整天的学弟学妹，记得接的第一个学弟是王金川，和父母提前一天过来。转了西安，游玩了古城。从图书馆出来的我和他相遇到图书馆和情人坑的那条街上，是田鸿才学长叫出去的。接的最后一个学弟是马伯谦，深夜十点了，下着毛毛细雨，在外面等他从航天城打的过来。接他回到我宿舍，安排好后，已不记得后续的事情了，或许已经睡着了。9月，还读了大冰的新书《我不》，依旧感觉很好。 2017年10月：这个十一，回家帮家人搬玉米，苦中作乐，乐在其中！10月21日，骑行去三星公园一起在秋天的落叶中，放松自我。10月24日，程序员的节日。10月25号，报名了西安城墙彩虹跑。十月，感觉很快的一个月。 2017年11月：11月，这个月，主打题是学长学姐的经验分享，那几天，有国创，有学长学姐分享完要做的微信推送。当我们三个把国创项目立项书交上去后的前一天晚上，第一次在C楼过夜，第一次睡到了桌子上，第二天清晨被发现，让我们下不为例。交上去的第二天，我便瘫痪了，身体累到不行，别人都说，怎么憔悴了不少…。其实，会发现，一件事情结果如何先不管，这个过程真的很难忘。这个月在微信公众号推送了好几篇，学长学姐们的经验也细细品读，希望自己在学习技术的路上少走些弯路。在自己搭建的博客上，我写下对自己的一句话：虽然有时候我走的很慢，但我相信自己可以走得很远！最后那几天，每天都固定在C楼一个教室，很充实。真心希望所有人的努力都会有相应的回报。 愿你有好运气，如果没有，愿你在不幸中学会慈悲。 愿你被很多人爱，如果没有，愿你在寂寞中学会宽容。 感谢和我一直在一起的几位学长学姐一直的陪伴。 2017年12月：终于到了2017年，写到了12月，2017就这样被写到了结束。12月，考了四级，却把翻译内容写在了写作文的地方，被提前收走了，写到最后的翻译处才发现，自己写错了。考场的我在心里对自己笑了一万遍。那就来年再战吧！ 昨天晚上，组织了一次2017年末包饺子活动，感谢大二的这帮兄弟姐妹们。很感谢！忙了一天，理应睡的很香，但却失眠了。发表了2017年的倒数第二个微博，想对自己说一些话。 总之，2017年，生活和学习都在前进中，也在前进中，不断的成长，认识自己，认识这个世界。真的，成长了很多。 要想用一句话总结的话，我想那就是：问心无愧吧 2018年，希望自己在学习技术的道路上，可以更加的投入，逼自己一把。活成为自己想成为的模样。生活中，不再奢求谁可以陪伴你，聊天散步谈心情，发现每个人都有自己的生活轨迹，每个人都有自己的事情可做，终究要学会习惯一个人也可以活得很潇洒。总之，2018，希望我关心的和关心我的人，都能够幸福，快乐，充实吧，将自己活得更精致一些！ 你好2018！再见，再也不见，2017！ -----2017年12月30号晚 小虎|诉说17，规划18]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>心得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC 使用步骤及练习]]></title>
    <url>%2F2017%2F12%2F10%2F10--JDBC--%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4%E3%80%81%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[通常，JDBC的使用可以按照以下几个步骤进行： （1）加载并注册数据库驱动123DriverManager.registerDriver(Driver driver);或Class.forName(&quot;DriverName&quot;);123 （2）通过DriverManager获取数据库连接1Connection conn = DriverManager.getConnection(String url,String username,String password);1 说明：getConnection()方法中有三个参数，分别表示连接数据库的地址、登录数据库的用户和密码。以MySql为例。其地址书写方式如下： 1jdbc:mysql://hostname:port/databasename1 说明：jdbc:mysql:是固定的写法，mysql指的是MySql数聚库。hostname指的是主机的名称（若主机在本机中，hostname为localhost或127.0.0.1；若要连接的主机在其他计算机上，则hostname为所要连接计算机的IP）。port指的是端口，Mysql默认端口为3306。databasename为MySql中数据库名称。 （3）通过Connection对象获取Statement对象Connection对象创建Statement的方式有如下几种：（1）createStatement(): 创建基本的Statement对象。（2）prepareStatement():创建PreparedStatement对象。（3）preparedCall():创建CallableStatement对象。以创建基本Statement对象为例： 1Statement stmt = conn.createStatement();1 （4）使用Statement执行SQL语句所有的Statement都有如下3种执行SQL语句的方法。（1）exeecute(): 可执行任何SQL语句。（2）executeQuery(): 通常执行查询语句，执行后返回代表结果集得ResultSet对象（3）executeUpdate():主要执行DML语句和DDL语句。执行DML语句，如insert，update,delete时，返回受SQL语句的行数，执行DDL语句返回0。 12//执行SQL语句，获取结果集ResultSetResultSet rs =stmt.executeQuery(sql) ;12 （5）操作ResultSet结果集若执行SQL语句是查询语句，执行结果将返回一个ResultSet对象，该对象里保存了SQL语句查询的结果。程序可以通过操作该ResultSet对象来获取查询结果。 （6）关闭连接，释放资源每次操作操作数据库结束后，都要关闭数据库连接，释放资源，包括关闭ResultSet,Statement,和Connection等资源。 练习： 前期准备：（1）搭建数据库环境（2）创建项目环境鼠标右击—-new—-folder,命名为lib,将下载好的MySql数据库驱动文件复制到项目的lib中，并使用鼠标右键单击该jar包，build path ——add to bulid path（3）编写JDBC程序 1类一：读取数据库中的users表，并将结果输出到控制台1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package cn.itcast.jdbc.example;import java.sql.Date;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import com.mysql.jdbc.Connection;import com.mysql.jdbc.Statement;public class JDBCExample &#123; public static void main(String[] args) &#123; Statement statement = null ; ResultSet resultSet = null ; Connection connection = null ; try &#123; //1：注册数据库的驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //2.通过DriverManager获取数据库连接 String url = &quot;jdbc:mysql://localhost:3306/jdbc&quot;; //连接数据库的地址 String username = &quot;root&quot;; String password = &quot;xiaohu&quot;; connection = (Connection) DriverManager.getConnection(url, username, password); //3.通过Connection对象获取Statement对象 statement = (Statement) connection.createStatement(); //用于创建一个Statement对象，将SQL语句发送到数据库。 //4.使用Statement对象执行SQL语句 String sql =&quot;select * from users&quot;; resultSet =statement.executeQuery(sql); //该方法返回一个表示查询结果的ResultSet对象。 //5.操作ResultSet结果集 System.out.println(&quot;id | name | password&quot;+&quot;| email | birthday&quot;); while (resultSet.next()) &#123; int id = resultSet.getInt(&quot;id&quot;); //通过列名获取指定字段值 String name = resultSet.getString(&quot;name&quot;); String password1 = resultSet.getString(&quot;password&quot;); String email = resultSet.getString(&quot;email&quot;); Date birthday = resultSet.getDate(&quot;birthday&quot;); System.out.println(id+&quot; | &quot;+name+&quot; | &quot;+password1+&quot; | &quot;+email+&quot; | &quot;+birthday); &#125; &#125; catch (ClassNotFoundException | SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; //6.收回数据库资源 if (resultSet != null) &#123; try &#123; resultSet.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; resultSet = null ; &#125; if (statement != null) &#123; try &#123; statement.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; statement = null ; &#125; if (connection != null) &#123; try &#123; connection.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; connection =null ; &#125; &#125; &#125;&#125;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980 注意： 123（1）.虽然使用DriverManager.registerDriver(new com.mysql.jdbc.Driver)方法也可以完成注册，但此方法会使数据库驱动被注册两次。这是因为Driver类的源码中，已经在静态代码块中完成了数据库的驱动注册。所以，为了避免数据库驱动被重复注册，只需要在程序中使用Class.forName()方法加载驱动类即可！（2）释放资源应该将释放资源的代码操作放在finally代码块中。123 1使用PreparedStatement对象对数据库进行插入操作。1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package cn.itcast.jdbc.example;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.SQLException;public class JDBCExample2 &#123; public static void main(String[] args) &#123; Connection connection = null ; PreparedStatement pStatement = null ; try &#123; //加载数据库驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); String url = &quot;jdbc:mysql://localhost:3306/jdbc&quot;; String username = &quot;root&quot;; String password = &quot;xiaohu&quot;; //创建应用程序与数据库连接的Connectin对象 connection=DriverManager.getConnection(url, username, password); //执行SQL语句 String sql=&quot;insert into users(name,password,email,birthday)&quot;+&quot;values(?,?,?,?)&quot;; //使用？通配符来代替参数，然后使用setXxx()方法为SQL语句赋值。 //1.创建执行SQL语句的PrepareedStatement对象 pStatement = connection.prepareStatement(sql); //2.为SQL语句中参数赋值 pStatement.setString(1,&quot;stormwang&quot; ); pStatement.setString(2, &quot;123456&quot;); pStatement.setString(3, &quot;StormWangxhu@163.com&quot;); pStatement.setString(4, &quot;1998-05-04&quot;); //3.执行SQL语句 pStatement.executeUpdate(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; //回收数据库资源 if (connection != null) &#123; try &#123; connection.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; if (pStatement != null) &#123; try &#123; pStatement.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677使用ResultSet对象取出指定数据的信息。1package cn.itcast.jdbc.example;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class JDBCExampe3 &#123; public static void main(String[] args) &#123; Connection connection= null ; Statement statement = null ; try &#123; //注册数据库驱动 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); String url=&quot;jdbc:mysql://localhost:3306/jdbc&quot;; String username =&quot;root&quot;; String password=&quot;xiaohu&quot;; //连接数据库 connection=DriverManager.getConnection(url, username, password); //SQL语句 String sql=&quot;select * from users&quot;; Statement statement2 = connection.createStatement( ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY); //执行SQL语句并将获取的数据信息存放在ResultSet中 ResultSet resultSet =statement2.executeQuery(sql); //取出ResultSet中指定的数据信息 System.out.print(&quot;第二条数据的name为：&quot;); resultSet.absolute(2); //将指针定位到结果集中的第2行数据 System.out.println(resultSet.getString(&quot;name&quot;)); System.out.print(&quot;第一条数据的name值为：&quot;);// System.out.println(resultSet.getString(&quot;name&quot;)); resultSet.beforeFirst(); //将指针定位到结果集中第一行数据前 resultSet.next(); //将指针向后滚动 System.out.println(resultSet.getString(&quot;name&quot;)); System.out.print(&quot;第4条数据的name值为：&quot;); resultSet.afterLast(); //将指针定位到结果集中最后一条数据之后 resultSet.previous(); //将指针向前滚动 System.out.println(resultSet.getString(&quot;name&quot;)); &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally &#123; //释放资源 if (connection != null) &#123; try &#123; connection.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;if (statement != null) &#123; try &#123; statement.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>JDBC</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC 常用接口 API]]></title>
    <url>%2F2017%2F12%2F10%2FJDBC---%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3API%2F</url>
    <content type="text"><![CDATA[学习目标：（1）了解什么是JDBC（2）熟悉JDBC的常用API（3）掌握如何使用JDBC操作数据库 1、1什么是JDBC定义：全称Java数据库连接（Java Database Connectivity）,是一套用于执行SQL语句的Java API。应用程序可以通过这套API连接到关系型数据库，并使用SQL语句完成对数据中数据的查询、增加、更新和删除等操作。 图解： 实质：JDBC在应用程序与数据库之间起到了一个桥梁作用，当应用程序使用JDBC访问特定的数据库时，需要通过不同数据库驱动与不同数据库进行连接，连接后即可对该数据库进行相应的操作。 1.2JDBC常用APIJDBC常用API主要位于Java.sql包中，该包定义了一系列访问数据库的接口和类。 1.2.1 Driver接口driver接口是所有jdbc驱动程序必须实现的接口，该接口专门提供给数据库厂商使用。注意：在编写jdbc程序时，必须要把所使用的数据库驱动程序或类库加载到项目的classpath中（这里指MySql驱动jar包）。 1.2.2 DriverManager类DriverManger类用于加载jdbc驱动并且创建与数据库的连接。 主要有两个比较重要的静态方法：该方法用于向DriverManager中注册给定的jdbc驱动程序。 该方法用于建立和数据库的连接，并返回表示连接的Connection对象。 1.2.3 Connection接口Connection接口代表Java程序和数据库的连接，只要获得该连接对象后，才能访问数据库，并操作数据表。Connection接口常用方法。 1.2.4 Statement接口Statement接口用于执行静态的SQL语句，并返回一个结果对象。Statement接口对象可以通过Connection实例的createStatement（）方法获得，该对象会把静态的SQL语句发送到数据库中编译执行，然后返回数据库中的处理结果。提供3个常用的执行SQL语句的方法。 1.2.5 PreparedStatement接口该接口中的一些方法 1.2.6 ResultSet接口ResultSet接口用于保存JDBC执行查询时返回的结果集，该结果集封装在一个逻辑表格中。在ResultSet接口内部有一个指向表格数据行的游标（或指针）。ResultSet对象初始化时，游标在表格的第一行前，调用next()方法可将游标移动到下一行。若下一行没有数据，则返回false,在程序中经常使用next()方法作为while循环条件来迭代ResultSet结果集。一些常用方法：]]></content>
      <categories>
        <category>JDBC</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 视图的案例应用]]></title>
    <url>%2F2017%2F12%2F09%2F09--mysql_%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B_%E8%A7%86%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1、案例目的：掌握视图的创建、查询、更新和删除操作。 2、案例操作过程：（1）三张表的创建：学生表、报名表、成绩表 （2）数据的插入 （3）创建北大视图：（4）创建清华视图（5）更新]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 高级操作]]></title>
    <url>%2F2017%2F12%2F09%2FMySql---%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[1.1数据库的备份与还原数据库的备份1、备份单个数据库基本语法： 1mysqldump -uusername -ppassword dbname [tbname1[tbname2...]]&gt;filename.sql1 说明：-u username 为用户名。- p password 为登录密码dbname 表示需要备份的数据库名称tbname 表示数据库中国的表名。可指定一个或多个，多个表名之间用逗号隔开。若不指定，则备份整个数据库。filename.sql 表示备份文件的名称，文件名前可加绝对路径。 2.备份多个数据库1mysqldump -uusername -ppassword --datebases dbname1 [dbname2,...]&gt;filename.sql 1 说明： –databases: 该参数后面至少指定一个数据库名称，若有多个，则名称之间用逗号隔开。 3.备份所有数据库1mysqldump -uusername -ppassword --all-databases &gt; filenama.sql1 数据的还原定义：当数据库中的数据遭到破坏时，可以通过备份好的数据文件进行还原，这里所说的还原是指还原数据库中的数据，而库是不能被还原的。mysql命令还原数据的语法格式如下： 1mysql -uusername -ppassword[dbname]&lt;filename.sql1 说明： username： 登录的用户名。password : 表示用户的密码dbname 表示要还原的数据库名称，若使用mysqldump命令备份的filename.sql文件中包含创建数据库的语句，则不需要指定数据库。 举例操作： 1.删除数据库2.创建数据库3.还原数据4.查看数据 1.2 用户管理定义：MySql用户分为root用户和普通用户。root用户为超级管理员，具有所有权限，如创建用户，删除用户，管理用户。普通用户只拥有被赋予的某些权限。 1.2.1 user表安装mysql数据库时，会自动安装一个名为mysql的数据库，该数据库中的表都是权限表，如user，db,table_priv….等。其中user表是最重要的一个权限表，他记录了允许连接到服务器的账号信息以及一些全局级的权限信息，通过操作该表既可以对这些信息进行修改。mysql5.5的user表中大致有42个字段，大致分4类： 1.用户列2.权限列3.安全列4.资源控制列1.2.2创建普通用户主要有三种方式： 方式一：使用grant 语句创建用户grant语句不仅可以创建用户，还可以对用户进行授权，该语句会自动加载权限表，不需要手动刷新，且安全、准确、错误少。使用grant语句是创建用户最好的方式。基本语法： 12grant privileges on database.tableto &apos;username&apos;@&apos;hostname&apos; [identified by [password]&apos;password&apos;][,...]12 说明：privileges : 表示该用户具有的权限信息。database.table : 表示新用户的权限范围表，可以在指定数据库、表上使用自己的权限。username : 新用户的名称。hostname : 主机名。password : 新用户的密码。 方式二：使用create user 语句创建用户。该语句创建新用户时，服务器会自动修改相应的授权表，但需要注意，该语句创建的用户没有任何权限。 1create user &apos;username&apos;@&apos;hostname&apos;[identify by [password]&apos;password&apos;][,...]1 方式三：使用insert语句创建用户1.2.3删除普通用户MySql中通常会创建多个用户来管理数据库，若发现某用户没有必要，就可以删除。主要有两种方式： 方式一： 使用drop user语句删除用户基本语法： 1drop user &apos;username&apos;@&apos;hostname&apos;[,...] ;1 方式二：使用delete语句删除用户1delete from mysql.user where Host=&apos;hostname&apos; and User=&apos;username&apos; ;1 1.2.4修改用户密码1.修改root用户密码（1）.使用mysqladmin 命令修改root用户密码基本语法： 1mysqladmin -u username [-h hostname] -p password new_password1 注：命令行第一次提示输入的密码为旧密码。 （2）.使用update语句修改root用户密码由于所有用户信息都存放在mysql.user表中，因此，只要root用户登录到MySql服务器，就可以用update语句修改自己的密码。 123update mysql.user set Password =PASSWORD(&apos;new_password&apos;)where User=&apos;username&apos;and Host=&apos;hostname&apos; ;123 root用户修改普通用户的密码（1）.使用grant语句修改普通用户密码grant语句作用比较多，不仅仅可以修改用户授权，还可以修改用户的密码。为了不影响当前用户的权限，可以使用grant usafe 语句修改指定账户的密码。 1grant usafe on * . * to &apos;username&apos;@&apos;localhost&apos; identified by [password]&apos;new_password&apos; ;1 2.使用update语句修改普通用户密码root用户具有操作数据库的所有权限，因此，他不仅可以使用update语句修改自己的密码，还可以修改普通用户的密码。基本语法： 123update mysql.user set Password=PASSWORD(&apos;new_password&apos;)where User=&apos;username&apos;and Host=&apos;hostname&apos; ;123 注意：使用上属语句修改普通用户密码后，还需要使用flush privileges语句重新加载权限表。 3.使用set语句修改普通用户的密码set不仅可以修改root用户密码，还可以修改普通用户密码，在修改普通用户密码时，还需要增加一个for子句，指定要修改哪个用户即可。set语句修改密码语法： 1set password for&apos;username&apos;@&apos;hostname&apos;=password(&apos;new_password&apos;) ;1 3.普通用户修改密码set语句： 1set password=password(&apos;new_password&apos;) ;1 多学一招：如何解决root用户密码丢失！大家都知道，root用户为超级管理员，具有很多权限，因此该用户密码一旦丢失，将会带来很多麻烦。可以通过特殊方法解决，步骤如下：1.停止MySql服务 1net stop mysql 1 2.使用–skip-grant-tables启动MySql服务MySql服务器中有一个 skip–grant-tables选项，他可以停止MySql的权限判断，即说明任何用户都可以访问数据库，并且通过该选项也可以启动MySql服务，在“运行”对话框中执行如下命令。 1mysql --skip-grant-tables 1 3.登录MySql服务器重新开启一个“运行”对话框，在“运行”对话框中登录MySql服务器。 1mysql -u root 1 4.使用update语句设置root用户密码登录成功后，可以重置密码。 12update mysql.user set Password=password(&apos;itcast&apos;) where User=&apos;root&apos; ;12 5.加载权限表MySql密码设置完成后，还需要加载权限表，让设置的密码生效。 1flush privileges ;1 上述步骤执行完，可以使用 EXIT或\q命令退出服务器，然后使用新密码重新登录。至此，便完成了root用户密码设置。 1.3权限管理在MySqL中，为了保证数据的安全性，数据库管理员需要为每个用户赋予不同的权限，以满足不同用户的需求。 1.3.1 MySql的权限1.3.2 授予权限1.3.3 查看权限select语句可以查看权限，但是麻烦！ 1show grants for&apos;username&apos;@&apos;hostname&apos; ;1 只需要指定用户名和主机名即可！！ 1.3.4 收回权限1234revoke privilege[columns][,privileges[(columns)]]on database.tablefrom &apos;username&apos;@&apos;hostname&apos;[,&apos;username&apos;@&apos;hostname&apos;]...1234 说明：privileges: 表示收回的权限。columns: 表示权限作用于哪列上，若不指定，则作用整个表。可以使用select语句查询user表中的信息。 12select Host,User,Password,Insert_priv from mysql.userwhere user=&apos;username\G&apos; ;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 解决命令行无法退出问题]]></title>
    <url>%2F2017%2F12%2F09%2F9--mysql%E8%A7%A3%E5%86%B3%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%97%A0%E6%B3%95%E9%80%80%E5%87%BA%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题： 解决方法： 1即 ’\c 即可退出这样的问题命令行。1]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 视图、增删改查（二）]]></title>
    <url>%2F2017%2F12%2F08%2F08--mysql%E8%A7%86%E5%9B%BE---%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在多表上创建视图创表： 插入数据并创建视图： 查询视图表 查看视图定义：查看数据库中已经存在的视图。查看视图必须要有show view 的权限。 查看视图主要有三种方式： 方式一：使用describle 语句查看视图1describle 视图名;1 或者 1desc 视图名 ;1 方式二： 使用 show table status 语句查看视图1show table status like &apos;视图名&apos; ;1 like : 表示后面匹配的字符串。‘视图名’： 表示要查看的的视图的名字。视图名称需要用单引号括起来。 方式三：show create view 查看视图1show create view 视图名 ;1 实例： view 和普通表最直接的区别： Comment项的值为 null 和 view 。 修改视图定义：指修改数据库中存在的视图的定义，比如当基本表中的某些字段发生变化时，可以通过修改视图的方式来保持与基本表一致。主要有两种方式： 方式一： 使用create or replace view 语句修改视图1234create [or replace][algorithm =&#123;undefined | merge|temptable&#125;]view view_name[(conlumn_list)]as select_statement[with[cascaded |local ] check option]1234 使用create or replace view 语句修改视图时，若视图存在，则修改语句对视图进行修改。若不存在，则创建视图。 方式二：使用alter 语句修改视图1234alter [algorithm =&#123;undefined | merge|temptable&#125;]view view_name[(conlumn_list)]as select_statement[with[cascaded |local ] check option]1234 更新视图定义：更新视图是指通过视图来更新、删除、插入基本表中的数据。因为视图它是一个虚拟表，其中没有数据，当通过视图更新数据其实就是在更新基本表中的数据，对视图中的数据进行增加或删除操作时，实际上就是对其基本表中的数据表进行增加、删除操作。 主要有3种方法更新视图 方法一：使用update语句更新视图MySql中，update对视图中原有数据进行更新。 1update 视图名 set 字段更新 ;1 方法二： 使用insert 语句更新视图MySql中，insert 语句可以向表中插入一条记录。 1insert into 视图名 values(值....) ;1 方法三： 使用delete 语句更新视图MySql中，delete语句删除视图中的部分记录。 1delete from 视图名 [where 条件语句] ;1 综上： 基本表变化 —–&gt;&gt; 视图也立即变化。 说明： 当视图中有以下内容时，不能执行更新操作。（1）、视图中包含基本表中定义的非空的列。（2）、在定义视图的select语句后的字段列表中使用了数学表达式。（3）、定义视图的select语句后的字段列表中使用了聚合函数。（4）、定义视图的select语句中使用了distinct，union，top,group by 或having字句。 删除视图定义：视图不需要时，就可以将其删除，删除视图时，只是删除视图的的定义，不会删除数据。 123drop view[if exists]view_name [,view_name1...][restrict | cascade]123 说明：view_name : 要删除视图的名称，视图可添加多个，名称间用逗号隔开。删除视图必须拥有drop权限。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 视图]]></title>
    <url>%2F2017%2F12%2F07%2FMySql---%E8%A7%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[1、1视图概述1、定义视图是从一个表或多个表中导出来的表，是一种虚拟表，且表结构和数据依赖于基本表。 2、优点（1）简化查询语句简化用户对数据的理解和操作。即将经常使用的查询定义为视图，使用户避免大量重复。 （2）安全性视图使得用户只能查询、修改所能见到的数据，数据库中其他数据即看不到也得不到。 （3）逻辑数据独立性帮助用户屏蔽真是表结构带来的影响。 综上：由于视图是在基本表上建立的表，其结构和数据都来自于基本表。因此，诸如更新数据，都可以在视图上进行。 视图管理即 创建、查看、修改、更新、删除。 1、2、1 创建视图 （create view语句）语法格式： 1234create [or replace] [algorithm =&#123;undefined | merge | temptable&#125;]view view_name [(column_list)]as select_statement[with [cascaded | local ] check option] 讲解：（1）create：表示创建视图的关键字，能创建新的视图。（2）or replace: 若给定次句，表示该语句能够替换已有视图。（3）algorithm:可选，表示视图选择的算法。（4）undefined：表示Mysql将自动选择所使用的算法。（5）merge:表示将使用视图的语句与视图定义合并起来，使得视图定义的某一部分取代语句的对应部分。（6）temptable:表示将视图的结果存入临时表，然后使用临时表执行语句。（7）view_name：表示要创建的视图名称。（8）columb_list:可选，表示属性清单。指定了视图中各个属性的名，默认下，与select语句中查询的属性相同。（9）as:表示指定视图要执行的操作。（10）select_statement:是一个完整的查询语句，表示从某个表或视图中查出某些满足条件的记录，并将其导入视图中。（11）with check option:可选，表示创建视图时，要保证在该视图的权限范围内。（12）local:…..]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 权限问题]]></title>
    <url>%2F2017%2F12%2F07%2FMySql%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题：访问被拒绝用户’ODBC’@’localhost’（使用密码：否） 解决办法1mysql -u root -p 1 可以看到，顺利进入mysql。 命令解释：123mysql -u root -p-u user 为 root-p password 显示密码]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 常见配置问题]]></title>
    <url>%2F2017%2F12%2F07%2FMySql%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[mysql数据库的使用在我手里问题是真的多！！！今天说一下在命令行下使用mysql的配置问题： 配置my.ini文件（整体配置问题）1234567891011121314151617181920[mysql] # 设置mysql客户端默认字符集 default-character-set=utf8 [mysqld] #设置3306端口 port = 3306 # 设置mysql的安装目录 #basedir=E:\mysql\mysql# 设置mysql数据库的数据的存放目录 #datadir=F:\mysql_data\data # 允许最大连接数 max_connections=200 # 服务端使用的字符集默认为8比特编码的latin1字符集 character-set-server=utf8 # 创建新表时将使用的默认存储引擎 default-storage-engine=INNODB #default-storage-engine=MYISAM [WinMySQLAdmin] Server = &quot;E:\mysql\mysql\bin\mysqladmin.exe&quot; 1234567891011121314151617181920 配置完成后将该文件存放到mysql目录下。然后是环境变量的配置，和使用eclipse一样，将mysql的bin目录添加到PATH下，这个就不说了。 完了之后，在cmd命令行中切换到mysql的bin目录下，使用一下命令语句：（1） 1mysqld remove 回车1 （2） 1mysqld install 回车1 （3）重新启动（4）net start mysql]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 字符乱码问题]]></title>
    <url>%2F2017%2F12%2F07%2FMySql%E5%AD%97%E7%AC%A6%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[尝试一： 失败！！！ 解决办法： 1set charset gbk ;1 成功！！！]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多表操作_外键_关联表_查询]]></title>
    <url>%2F2017%2F11%2F27%2F27--%E5%A4%9A%E8%A1%A8%E6%93%8D%E4%BD%9C_%E5%A4%96%E9%94%AE_%E5%85%B3%E8%81%94%E8%A1%A8_%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[1、1 外键1、1、1 什么是外键（1）定义：外键是指引用另一个表中的一列或多列，被引用的列具有主键约束或唯一约束。 （2）目的：外键用于建立和加强两个表数据之间的连接。 （3）概念：a. 主表： 被引用的表。 如 grade表b.从表 ： 引用外键的表 。如 student表 两者关系： 主从关系。 举例说明：先创建grade 、student表 student： 两者关系： 从查询结果来看：gid 为student 表的外键，且依赖于grade 表中的id键。 注意：（1）建立外键的表必须为 InnoDB型，不能是临时表。在MySql中只有InooDB类型的表才支持外键。（2）定义外键名时，不能加引号。 如 constraint’FK_ID’或constraint “FK_ID”。 1、1、2 为表添加外键约束建立外键的基本语法： 1alter table 从表名 add constraint FK_ID foreign key(外键字段名) references 主表名(主键字段名);1 补充：当主表中删除数据时，从表中数据也应该删除，否则会产生垃圾数据。MySql中可以在建立外键时添加 on delete或on update子句告诉数据库，怎样避免垃圾数据的产生。 123alter table 从表名 add constraint FK_ID foreign key(外键字段名) references 主表名(主键字段名);[on delete&#123;cascade | set null | no action | restrict&#125;][on update&#123;cascade | set null | no action | restrict&#125;]123 具体参数说明： 。 1、1、3 删除外键约束当需要解除两表的关联关系时，需要解除： 基本语法： 1alter table 表名 drop foreign key 外键名 ;1 从表中可以看出，student表中的外键约束已成功删除！ 1、2 操作关联表1、2、1 关联关系MySql中数据表之间的关联关有三种。如下：1、多对一 注意：在多对一的表关系中，应该将外键建在多的一方，否则会造成数据的余！！！ 2、多对多 3、一对一 注意：这种关系在数据库中并不常见，因为以这种方式存储的信息通常会放在一个表中。在实际开发中，一对一关联关系可以应用到以下几个方面。（1）、分割具有很多列的表（2）、由于安全原因，隔离表的一部分。（3）、保存临时数据，且可以毫不费力的通过删除该表而删除这些数据。 1、2、2 添加数据实际开发，最常见关系 ; 多对一 关系 ！ 在grade 和 student 中添加外键约束来建立两个表的关联关系!步骤一： 添加外键约束 1、2、3 删除数据在除数据时，删除顺序： 先从表后主表 ！否则会报错！ 1、3连接查询分类：（1）交叉查询（2）内连接查询（3）外链接查询 1、3、1交叉连接返回笛卡尔积：即 返回第一个表中符合查询条件的数据行 乘 第二个表中符合查询条件的数据行数。 如department表中有4个部门，employee表中有4个员工，则有4*4=16条数据。 基本语法： 1select * from 表1 cross join 表2 ;1 说明：cross join连接两个要查询的表。该语句可查询两个表中所有数据组合。 建立 department、employee 表： 查询：//16条 完。 1、3、2 内连接只有满足条件的记录才能出现在查询记录中！ 基本语法： 12select 查询字段 from 表1 [inner] join 表2 on 表1.关系字段= 表2.关系字段; 12 说明： 12inner join 连接两个表on 指定连接条件12 图解： 练习： 在MySql中可以使用where条件语句实现相同功能！ where 和 inner join 区别：（1）where：条件判断句，where后可直接添加其他条件。（2）inner join 内连接语句，后不可以直接添加条件。 自连接查询：设计两个表为同一张表。逻辑上为两个表。 说明： 1select 表1别名 from 表1 表1别名1 join 表1 表1别名2 on 连接条件; 1 1、3、3 外连接分类：（1）左连接 : 左表返回包括左表中所有记录和右表中符合连接条件的记录。（2）右连接 ： 右表返回包括右表中所有记录和左表中符合连接条件的记录。 基本语法： 1234select 所有字段 from 表1 left | right [outer] join 表2on 表1.关系字段=表2.关系字段 where 条件;1234 左连接图解： 右连接图解： 1、LEFT JOIN (左连接)左连接的结果包括left join子句中指定的左表的所有记录，以及满足连接条件的记录。 2、RIGHT JOIN (右连接） 返回结果：指定右表的所有记录和满足连接条件的记录。 若右表中某条记录在左表无匹配，则显示为null. 1、3、4 符合条件连接查询定义： 在连接查询中，添加过滤条件来限制查询结果，使查询结果更精确！！]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单表查询、简单条件查询]]></title>
    <url>%2F2017%2F11%2F25%2F25--%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2_%E7%AE%80%E5%8D%95_%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[一、简单查询1、1、SELECT语句 MySql语句从数据库中查询数据的基本语句为SELECT语句。基本语法： 123456SELECT [DISTINCT] * | &#123;字段名1，字段名2，...&#125;FROM 表名[WHERE 条件表达式1][GROUP BY 字段名1[HAVING 条件表达式2 ]][ORDER BY 字段名 [ASC| DESC ]][LIMIT [OFFSET] 记录数]123456 说明：（1）、* 通配符表示表中的所有字段（2）、GROUP BY 将查询结果按字段分组（3）、ORDER BY 将查询结果按字段进行排序。（4）、LIMIT OFFSET（5）、 DISTINCT 剔除查询结果中的重复值。 1、2查询所有字段 1、在SELECT语句中指定所有字段 基本语法： 1SELECT 字段名1，字段名2，字段名3... FROM 表名;1 说明 ; 字段1，字段2，字段3….为表中所有的字段。 举例： 2、在SELECT 语句中使用 * （通配符）代替所有字段。 基本语法： 1SELECT * FROM 表名 ;1 1、3 查询指定字段 只针对部分查询字段，不查询全部字段 基本语法： 1SELECT 字段名1，字段名2，... FROM 表名 ;1 说明：字段1，字段2，…为表中的字段名称，这里只需指定表中部分字段的名称。 举例： 二、按条件查询2、1 带关系运算符的查询在SELECT语句中，最常见的是使用WHERE语句指定查询条件进行数据的查询。 基本语法： 123SELECT 字段名1，字段名2，...FROM 表名WHERE 条件表达式 ;123 关系运算符，即常见的大于，小于，不等于….等！ 举例： 2、2 带IN关键字的查询IN 关键字 用于判断某个字段是否在指定集合中。若字段的值在集合中，则该字段所在的记录将被查询出来。 基本语法： 123SELECT * |[字段名1。字段名2，...]FROM 表名WHERE 字段名 [not] IN [元素1，元素2...]；123 说明：元素1，元素2， 表示集合中的元素，级指定的条件范围。not 为可选参数，使用not表示查询不在in关键字指定集合范围中的记录。 举例： 2、3带between and 关键字的查询 用于判断某个字段的值是否在某一个范围内，若字段的值在指定范围内，则满足条件，该字段所在的记录将会被查询出来，否则，不会查询出来@ 基本语法： 123select * | [字段名1，字段名2，...]from 表名where 字段名 [not] between 值1 and 值2 ；123 说明：（1）上述值1、值2，分别表示条件范围的起始值、结束值。（2）若字段的值在范围内，则将会被查出来。否则，不会查询出来。（3）not 为可选参数，表示不再条件范围内的字段值。 举例： 2、4 空值查询 在数据表中某些列的值可能为空值（null），空值不等同于0,也不同于空字符串。在MySQl种使用is null关键字来判断字段的值是否为空值。 基本语法： 123select * | [字段名1，字段名2，...]from 表名where 字段名 is [not] null ;123 说明：not为可选参数，使用not关键字用于判断字段值不是空值。 举例：//图 2、5 带 distinct 关键字的查询表中某些字段的值存在重复数据，该关键字用于去除重复值，只留一种！即过滤重复内容！！！ 基本语法： 1select distinct 字段名 from 表名 ；1 说明：字段名表示要过滤重复记录的字段。 举例： 注意： distinct 关键字用于多个字段基本语法： 1select distinct 字段名1，字段名2，... from 表名;1 条件：字段1，字段2，….等多个字段的值相同才能过滤。不相同，则会直接查询出来，不能起到过滤的作用！ 2、6 带like 关键字的查询 即对字符串进行模糊查询 ！！！ 基本语法： 123select * | [字段名1，字段名2，...]from 表名where 字段名 [not] like &apos;匹配字符串&apos;;123 说明：（1）not 可选参数，表示查询与指定字符串不匹配的记录。（2）‘匹配字符串’ 指定用来匹配的字符串，其值可以是一个普通的字符串，也可以包含百分号 % 通配符或者下划线_通配符。。。 下面介绍一下百分号通配符，和下划线通配符！ 1&gt;百分号%通配符匹配任意长度的字符串，包括空字符串。 比如： 123select 字段名1，字段名2，...from 表名where 字段名 like &apos;S%&apos;；123 说明：（1）‘s%’表示 匹配以字符 s开始，任意长度的字符串。如‘ct’,’cut’,’current’.（2）如：%s% : 表示统配 举例：//图 2&gt;下划线通配符 _下划线通配符只匹配单个字符。若要匹配多个字符，需要使用多个下划线通配符。 注意： 若使用多个下划线匹配多个连续的字符，下划线之间不能有空格！ 举例： 百分号通配符和下划线通配符的转义这两个可以联合起来进行查询操作。 使用右划线’\’对百分号 %、和下划线通配符 _ 进行转义： 比如： \%, _ 举例： 2、7、带 and 关键字的多条件查询 为了使查询结果更精确，可以使用多个查询条件。 基本语法： 123select * | [字段1，字段2，...]from 表名 where 条件表达式1 and 条件表达式2 [...and条件表达式n];123 注意： and 关键字两边条件要同是满足 ！ 举例： 2、8、带 or 关键字的多条件查询 只要记录满足任意一个条件就会被查询·出来 123select * | [字段1，字段2，...]from 表名 where 条件表达式1 or 条件表达式2 [...or条件表达式n];123 即每两个条件之间用 or 关键字连接。 举例： and 和 or 混合使用 查询注意： and 的优先级高于 or 。举例： 说明: 若and优先级和or 的优先级相同 或者 比 or 低，and操作会最后执行，查询结果只会返回一条记录，记录的grade =99。但是：：：：哈哈但是：本例中返回了 6条记录。说明先执行了 and 后执行了 or 。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[添加、更新与删除数据]]></title>
    <url>%2F2017%2F11%2F23%2F23--%E6%B7%BB%E5%8A%A0%E3%80%81%E6%9B%B4%E6%96%B0%E4%B8%8E%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[首先介绍一下查询语句： 12SELECT * FROM 表名[where 条件表达式 ];12 添加数据SQL语句：INSERT INTO 语句 1、为表中所有的字段添加数据 向表中添加的数据称之为记录。 两种方式： 方式一：insert语句中指定所有字段名在insert 语句中列出表中的所有字段名，其值与其字段名、类型要一一对应！语法格式： 12INSERT INTO 表名 （字段名1，字段名2，...） VALUES(值1，值2，...);12 说明：“字段名1，字段名2，…”表示数据表中的字段名称，此处应为表中所有字段名称。“值1，值2…”表示每一个字段的值，其值顺序、类型须与对应的字段相匹配！ 注意：使用inset语句添加记录时，表名后的字段顺序可以与在其表中定义的顺序不一致，他们需要与values中值得顺序一致即可！ 方式二：insert语句中不指定字段名。其实，他就是在不指定字段名的情况下，直接用values为其默认赋值。 注意：正因为没有字段名，则values中值得顺序必须与字段在表中顺序一致。 基本语法： 1INSERT INTO 表名 VALUES(值1，值2，....);1 2、为表的指定字段添加数据即在insert语句中只向部分字段添加值，而其他值为默认值。关于默认值可以使用show create table 表名;查看字段的默认值。 基本语法： 12INSERT INTO 表名（字段1，字段2，...） VALUES (值1，值2，...);12 说明：“字段1，字段2，…”表示数据中的字段名称，此处指表中的部分字段名称“值1，值2，…”为指定字段的值，每一个值得顺序、类型必须与对应的字段相匹配。 注意：（1）在为了某个字段赋值时，如果没有为其赋值，系统会自动为其赋值默认值。通过show create table 表名 ；可查询表的具体结构！ （2）如果某个字段在定义时添加了非空约束，但没有添加default约束，那么插入新纪录时就必须为该字段赋值，否则数据库系统会提示错误！ 比如： 上述两种方法总结：语法格式： 12insert into 表名 （字段1，字段2，...）values(值1，值2，...)12 就方法一而言，是把所有字段都写出来，然后值也是全部都为之赋值上。就方法二而言，相比于方法一，只不过是写出了部分字段，部分赋值，其余的则以默认值赋之。仅此而已！ 更新数据更新数据，即对表中存在的数据进行修改。SQL语句：UPDATE 语句基本语法： 123UPDATE 表名 SET 字段名1=值1[,字段名2=值2，...] [WHERE 条件表达式]123 语法说明：字段名1，字段名2，用于指定更新的字段名称值1，值2，用于表示字段更新的新数据。where条件表达式，可选参数，用于指定更新数据需要满足的条件。 UPDATE语句在更新表中数据时可 部分、全部更新 1、update更新部分数据 即 使用where子句指定更新条件，来更新表中的某一条或几条记录。 一般更新前，使用select * from 表名 [where 条件表达式]； 来查询表。 如更新student表中字段id值小于4的记录，将grade 字段值更新为99 2、update 更新全部数据 很简单，即没有where 语句，就会将表中的所有记录的指定字段1都进行更新！ 基本语法： 12UPDATE 表名SET 字段名1=值1[字段名2=值2，...];12 举例： 上述两种类别总结：其实很简单，只要记住了 UPDATE语句基本语法，部分更新还是全部更新全只在于where 条件表达式的有无和限定范围，仅此而已！ 删除数据即，对表中存在的记录进行删除。 基本语法： 12DELETE FROM 表名 [ WHERE 条件表达式 ] ;12 说明:表名指的是要执行删除操作的表。where 条件表达式，可选参数，只要满足条件的记录会被删除！ 1DELETE 语句可 删除部分 、 全部数据1 1、DELETE 删除部分数据 根据指定条件删除表中的某一条或者某几条记录，需 WHERE 子句指定要删除的条件。 或者这样查询： 删除成功！ 2、DELETE 删除全部数据 很简单，即没有 `WHERE 子句 ; 1DELETE FROM 表名 ;1 结果来看，记录为空，说明表中的所有记录被成功删除！ 补充：即对删除表中全部数据另一种方法：关键字： truncate解释：截短 基本语法： 1TRUNCATE [TABLE] 表名 ;1 1、与delete语句区别：（1）、truncate 只能删除全部数据，delete 后可以有where。（2）、truncate删除数据后，再像表中添加记录时，自动增加字段的默认初始值重新由 1 开始。delete删除表中积累后，再次向其添加记录时，自动增加字段的值为删除时该字段的最大值加 1 。 演示： 现在删除该表中记录： 接下来，由delete 语句删除表中记录。 添加数据： 。这是因为使用delete 语句中删除的记录总，id字段的最大值为4。再次添加为5。 （3）delete语句每删除一条记录，都会在日志中记录。truncate语句不会记录。导致： truncate 执行效率高于 delete \]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[索引（一）]]></title>
    <url>%2F2017%2F11%2F23%2F23--%E7%B4%A2%E5%BC%95%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1.1 索引概念数据库种的索引好比新华字典种的音序表。 1.2 索引分类1、普通索引 1key 或 index 1 2、唯一性索引 1unique1 3、全文索引 1fulltext1 条件： 只能创建在 char 、 varchar 或 text类型的字段上。 4、单列索引5、多列索引6、空间索引 索引优缺点： 优点： 可提高数据表的访问速度缺点： 占用一定磁盘空间，消耗时间随着数据量的增加而增加。 1121.3 创建索引1、创建表的时候创建索引定性： 最简单、方便 基本语法： 12345678create table 表名（字段名 数据类型 [完整性约束条件],字段名 数据类型 [完整型约束条件],... 字段名 数据类型 [unique|fulltext|spatial|index|key [别名]（字段名1[长度]） [asc | desc]） );12345678 上述语法解释：（1）unique ； 可选参数，表示唯一索引（2）fulltext ： 可选参数，表示全文索引（3）spatial : 可选参数，空间索引（4）indes 或 key : 表字段索引，二选一（5）别名： 可选，表示创建索引的名称（6）字段名1： 指定索引对应字段的名称（7）长度： 可选，表示索引长度。（8）asc 和 desc ，分别表 升序排列、降序排列。 （1）创建普通索引如在id 字段上建立索引（2）创建唯一索引（3）创建全文索引 （4）创建单列索引 说明：name字段上已经建立了一个名称为single_name的单列索引，且索引长度为20。 （5）创建多列索引 注意： 在多列索引中，只有查询条件中使用这些字段中的第一个字段时，多列索引才会被使用。为了验证，使用如下SQL语句：]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[索引（二）]]></title>
    <url>%2F2017%2F11%2F22%2F22--%E7%B4%A2%E5%BC%95%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[今天主要写一写创建索引的三种方式和删除索引的SQL语句。在第一期中，主要写了一下第一种创建索引的方法。主要说三种呢，是我自己看书总结的，哈哈~！ 创建索引： 一.在表的内部创建索引这种创建方式，即第一期中说的方式，再拿过来： 12345678create table 表名（字段名 数据类型 [完整性约束条件],字段名 数据类型 [完整型约束条件],... 字段名 数据类型 [unique|fulltext|spatial|index|key [别名]（字段名1[长度]） [asc | desc]） );12345678 然后就是六种类型索引的创建。其中三种需要在index 前面加可选参数，即唯一索引，全文索引，空间索引。unique 、fulltext、protial。 二、以创建好的表为基础，外部创建索引使用CREATE INDEX 语句在已经创建好的表上创建索引。主要使用SQL语句： 1create [unique|fulltext| spatial] index 索引名 on 表名（字段名[(长度)] [ASC|DESC]）1 说明：unique /fulltext/spatial :可选参数index 用于指明字段为索引。 举例：以下为创建六种类型的索引1、普通索引 2、创建单列索引 - 3、创建多列索引 4、创建全文索引 5、创建空间索引 6、创建唯一性索引 三、以创建好的表为基础，在外部创建索引使用ALTER TABLE 语句在已经存在的表上创建索引 基本语法： 1alter table 表名 add [unique|fulltext|spatial ] index 索引名 （字段名[(长度)] [ASC|DESC]）1 然后就是六种索引的创建。不举例。 四、删除索引原因：由于索引会占用一定的磁盘的空间，因此，为了避免影响数据库性能，应该及时删除不再使用的索引。 删除有两种方式 方式一：使用 alter table 删除索引 1alter table 表名 drop index 索引名 ;1 方式二：使用 drop index 删除索引 基本语法： 1drop index 索引名 on 表名 ;1 举例：]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据表的约束、字段值自动增加]]></title>
    <url>%2F2017%2F11%2F22%2F22--%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%9A%84%E7%BA%A6%E6%9D%9F%E3%80%81%E5%AD%97%E6%AE%B5%E5%80%BC%E8%87%AA%E5%8A%A8%E5%A2%9E%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[（一）数据表的约束1、约束目的： 为了防止数据库中插入错误的数据。在设计数据库时，为了确保数据库表中数据的质量，需要考虑数据的完整性（数据的完整性是指数据的正确性和一致性）。举个例子：当你要为学生建立一个基本信息表StudentInfo时，这个表中学生的名字可以相同但是学号必须不一样，而他的年龄也得限制在一定范围内，像这样类似的“限制”有很多，如果违反了这些限制就制造了与现实不符的失真数据即破坏了数据的完整性。因为数据库不能自行判断哪些数据失真，所以需要认为添加一些约束来保证数据的完整性。2、约束条件：数据库中对表的约束有五种：–1.主键约束（Primary Key constraint）：主键列数据唯一，并且不允许为空。主键是表中的一列或一组列，它们的值可以唯一地标识表中的每一行。 –2.唯一约束（Unique constraint）：该列数据唯一，允许为空，但只能出现一个空值（不重复性）。唯一性约束保证了除主键外的其他一个或一组列的数据具有唯一性，以防止在列中输入重复的值。（一个表只可以有一个主键约束，如果其它列也不希望有重复就可以使用唯一性约束。） –3.检查约束（Check constraint）：范围限制、格式限制检查约束使指定表中一列或一组列可以接受的数据值或格式。 –4.默认约束（Default constraint）：为指定列定义一个默认值。在输入数据时，如果没有输入该列的值，则将该列的值设置为默认值。 5.外键约束（Foreign Key constraint）：表间约束，确保数据的参照完整性将当前表中的某一列或一组列关联到另一个表的主键列，可创建两个表之间的连接。当前表中的列就成为外键。外键涉及到两个表，一个主表，一个从表 ，主表中的外键是从表中的主键 1121.1 主键约束作用： 为了快速查找表中的某条信息，可以通过设置主键来实现。方式： primary key 定义，唯一标示表中的记录，好比身份证。 单字段主键 基本语法 1字段名 数据类型 primary key 1 多字段主键基本语法 1primary key(字段名1，字段名2，...字段名n)1 说明： 字段名1，字段名2等指的是构成主键的多个字段的名称。 注意：每一个数据表中最多只能有一个主键约束，定义为primary key 的字段不能有重复，且不能为空！ 1121.2 非空约束基本语法： 1字段名 数据类型 not null 1 非空约束指的是字段值不能为空 1121.3 唯一约束唯一约束用于保证数据表中字段的唯一性，即表中的字段的值不能重复出现。基本语法 1字段名 数据类型 unique ;1 说明：id 字段为主键stu_id 字段为唯一值，该字段不能有重复值。grade 字段的值有默认值 0。 1121.4 默认约束基本语法： 1字段名 数据类型 default 默认值 ；1 （二）设置表的字段值会自动增加定义：若为表中插入的新纪录自动生成一个唯一的ID，可以使用 auto increment 约束实现。 基本语法： 1字段名 数据类型 auto_increment ;1 说明： ID字段 为主键，且每插入一条新纪录，id值会自动增加。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库、表基本操作增删改查]]></title>
    <url>%2F2017%2F11%2F21%2F21--%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%81%E8%A1%A8%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[(一)、数据库的基本操作基本操作: 增 、删、 改 、查 增：1、建库: 12语法格式：craete database 数据库名字；12 2、查库 12语法格式：show databases ;12 改1、修改数据库的编码方式 1alter database 数据库名称 default character set 编码方式 collate 编码方式_bin ;1 编码方式指的是修改后的数据库编码方式！ 删1、删除数据库 1drop database 数据库名称 ；1 一般情况下，在删除数据库前后使用show databases ; 进行数据库的查询，以保证要删除数据库的存在和删除成功，否则会删除失败！ 查查询数据库列表 1show databases ;1 查询某一个数据库的信息： 1show create database 数据库名称；1 实战演练：1、建库、查库信息2、修改数据库编码方式删数据库删除成功！ （二）数据表的基本操作数据表的基本操作：增、删、改、查 基本会使用到的SQL语句：（1） alter table 表名 …该语句主要用于增加、修改、删除表字段、数据类型的一系列操作：字段： change （修改的意思）数据类型： modify （修改的意思）（2）show tables; //列出数据表列单（3）desc 表名； // 列出数据表信息（4）show create table 表名； // 列出数据表信息- 建表 123456create table 表名称(字段名1 数据类型[完整型约束条件]，字段名2 数据类型[完整型约束条件]，...字段名n 数据类型[完整型约束条件]）；123456 其中，表名： 指的是要创建的数据表的名称字段名： 指的是数据表的列名。“完整型约束条件”： 指的是某些特殊的约束条件。 查询数据表列单（查） 1show tables ;1 查询数据表内的信息有两种方法：方法一： 1show create table 数据表名；1 方法二 1describe 数据表名；1 或简写为 1desc 数据表名；1 改：（数据表名、字段名、数据类型） —- alter table 语句（1）修改数据表名 1alter table 旧表名 rename [to] 新表名 ；1 （2）修改字段名 1alter table 表名 change 旧字段名 新字段名 新数据类型 ；1 说明：旧字段名： 指的是修改前的名。新字段名： 指的是修改后的名。新数据类型： 指的是修改后的数据类型。注意：新数据类型不能为空，即使新字段与旧字段的数据类型相同，也必须将数据类型设置为与原来一样的数据类型。 （3）修改字段的数据类型 1alter table 表名 modify 字段名 数据类型 ；1 说明：表名： 指的是要修改的字段所在的表名字段名： 指的是要修改的字段。数据类型： 指的是 修改后的字段的数据类型。 添加字段 12alter table 表名 add 新字段名 数据类型 [约束条件][first|after 已存在的字段名] 12 说明：新字段名： 为要添加的字段名“first”为可选参数，将新添加的字段设置为表的第一个子段。“after”为可选参数，将新添加的字段添加到指定的“已存在的字段名”后面。 修改字段的排列位置 1alter table 表名 modify 字段名1 数据类型 first|after 字段名21 说明：“字段名1”指的是修改位置的字段“数据类型”指的是字段1的数据类型。“first”:是将字段1修改为第一个字段。“after”是将字段1 插入到字段2 的后面。 删除字段 1alter table 表名 drop 字段名 ；1 说明： 字段名指的是要删除的字段名。一般情况下，应该先查询表信息，即desc 表名；以判断字段是否存在。 删除数据表 1drop table 表名；1 一般先查询是否存在该数据表，即show tables ; ,以检查要删除的数据表是否存在。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 线程的生命周期及其状态转换]]></title>
    <url>%2F2017%2F11%2F08%2F08--Java-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8F%8A%E5%85%B6%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[在线程中，线程主要有5中状态。来一张图详细看一下： 说明：单箭头只能单向转换。双箭头能双向转换。 详解5中状态1、新建状态（New） 创建一个线程对象后，该线程对象就处于新建状态。不能运行，和其他Java对象一样，仅仅由Java虚拟机分配了内存。 2、就绪状态（Runnable） 线程调用start()方法后，该线程就进入就绪状态。就绪状态线程位于线程队列中，具备运行条件，仅仅需要等待系统为其分配CPU的使用权。 3、运行状态（Run） 就绪状态—–&gt;获得CPU执行权——&gt;运行状态。并开始执行run()方法中的线程执行体。 当然：一个线程不可能一直处于运行状态，当使用完系统为其分配的时间后，系统就会剥夺该线程占用的CPU资源，让其他线程获得执行的机会。 注意：只有处于就绪状态才能—————-&gt;运行状态。 4、阻塞状态 一个正在执行的线程在某些特殊情况下，如被人为的挂起或执行耗时的输入/输出 操作时，会让出CPU的使用权并暂时中止自己的执行，进入阻塞状态。线程一旦进入阻塞状态后，就不能进入排队队列。只有当引起阻塞状态的原因消除后，线程才可以进入———-&gt;就绪状态。 下面列举一个线程由 运行状态———&gt;阻塞状态原因，以及如何从阻塞状态转换———-&gt;就绪状态。 当线程试图获取某个对象的同步锁时，如果该锁被其他线程所持有，则当前线程会进入阻塞状态。若：阻塞状态——&gt;就绪状态, 则： 必须获取到其他线程所持有的锁。 当线程调用一个阻塞式的IO方法时，会进入阻塞状态。若 阻塞状态——–&gt;就绪状态，则：要等待这个阻塞的IO方法返回。 当线程调用某一个对象的wait()方法时，该线程会进入阻塞状态，若阻塞状态——–&gt;就绪状态,则：需要使用 notify()方法唤醒该线程。 当线程调用Thread的sleep(long millis)方法时，也会进入阻塞状态。若阻塞状态——-&gt;就绪状态，则： 只需等待睡眠时间结束。 当在一个线程中调用另一个线程的join（）方法时，会使当前线程进入阻塞状态。若：阻塞状态——-&gt;就绪状态，则： 需要等待新加入的线程运行结束后才会结束阻塞状态，进入就绪状态。 5、死亡状态当线程调用stop()方法、run()方法执行完毕后，或者线程抛出一个未捕获的异常（Exception）、错误（error）,线程就进入死亡状态。注意：一旦线程进入死亡状态，线程将不再拥有运行的资格，也不能转换到其他状态。即死亡即死亡！！！！]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse jdk 环境变量配置]]></title>
    <url>%2F2017%2F11%2F08%2F08--eclipse-jdk%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[再好的，都不如自己花一些时间一边一边尝试出来！这样才记忆深刻！ jdk环境的配置因为一些原因，重装了一下系统，eclipse又重新下载了一遍，jdk不能却！一下午，终于配置好了环境变量。 配置方法：系统—–&gt;高级系统设置——&gt;环境变量——&gt;选择系统变量 123JAVA_HOME: D:\Program Files\Java\jdk1.8.0_151PATH: %JAVA_HOME%\binCLASSPATH: .;%JAVA_HOME%\lib\tools.jar;%JAVA_HOME%\lib\dt.jar123 测试： 快捷键：win+Rcmd打开DOS命令行： 123javajavacjava -version123 分别看一下结果： java javac java -version 成功！！！]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>eclipse</tag>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 多线程]]></title>
    <url>%2F2017%2F11%2F08%2F08--Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[今天来学习线程。先来了解几个概念。 1、进程1、定义: 每一个独立运行的程序都可以称为进程，即正在运行的程序。目前大部分计算机上安装的都是多任务操作系统，既可以同时执行多个应用程序，最常见Windows,Linux,UNIX等。 2、多进程实质： 在计算机中，所有的应用程序都是由CPU执行的。对于一个CPU而言，在某一个时间点只能执行一个程序，也就是只能执行一个进程。操作系统会为一个进程分配一段有限的CPU使用时间，CPU在这段时间中执行某一个进程，然后会在下一段时间执行另一个进程。CPU运行速度很快，可在极短时间内在不同进程之间切换，给人以错觉。 2、线程1、定义：一个进程中可执行多个单元，这些单元称为线程。操作系统中每一个进程中至少存在一个线程。 2、（1）单线程程序——–代码按照调用顺序依次往下执行，不出现交替执行。（2） 多线程程序——-多段程序代码交替执行。即一个进程在执行过程中可以产生多个单线程，这些单线程运行时相互独立，并发执行。实质：依旧是右CPU来调度。 2、1、线程的创建两种方式：（1）、继承Java.lang包下的Thread类，覆写其run()方法，在run()方法中实现运行在线程上的代码。（2）、实现java.lang包下的Runnable接口，同样在run(）方法中实现运行在线程上代码。 先来看第一种方法： 12345678910111213141516171819202122232425262728293031package com.stormwang.ThreadDemo;/*** @author StormWangxhu* @version 创建时间：2017年11月8日 上午9:41:19**/public class CreateThreadDemo &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub MyThread myThread = new MyThread(); myThread.run(); while(true) &#123; System.out.println(&quot;main方法正在执行。&quot;); &#125; &#125;&#125;class MyThread &#123; public void run() &#123; // TODO Auto-generated method stub while (true) &#123; System.out.println(&quot;MyThread的run()方法正在main()中执行。&quot;); &#125; &#125;&#125;12345678910111213141516171819202122232425262728293031 运行： 会看到一直在运行一条语句。实则是单线程导致。 修改一下，继承Thread类。 123456789101112131415161718192021222324252627282930313233343536package com.stormwang.ThreadDemo;/*** @author StormWangxhu* @version 创建时间：2017年11月8日 上午9:41:19**/public class CreateThreadDemo &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub MyThread myThread = new MyThread(); myThread.start(); for(int i=0;i&lt;50;i++) &#123; System.out.println(&quot;main方法正在运行。&quot;+i); if (i==20) &#123; break; &#125; &#125; &#125;&#125;class MyThread extends Thread&#123; public void run() &#123; for(int j=0;j&lt;50;j++) &#123; System.out.println(&quot;MyThread的run()方法正在main()中执行。&quot;+j); if (j==20) &#123; break; &#125; &#125; &#125;&#125;123456789101112131415161718192021222324252627282930313233343536 运行： 回看到，在交替运行。 再来看第二种方法：继承Thread类有一定的局限性。因为Java支持单继承，一个类一旦继承了某个父类就无法再继承Thread类。例如学生类Student类继承了Person类，就无法再继承Thread类。 所以，Thread提供了另一个构造对象；Thread(Runnable target);实现Runnable接口中run(）方法。 1234567891011121314151617181920212223242526272829303132333435363738394041package com.stormwang.ThreadDemo;/*** @author StormWangxhu* @version 创建时间：2017年11月8日 上午10:31:51**/public class RunnableDemo &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub RunnableTest ruTest = new RunnableTest(); Thread thread = new Thread(ruTest); thread.start(); int count = 0 ; while (true) &#123; System.out.println(&quot;main方法正在运行。&quot;+count); count++; if (count==20) &#123; break; &#125; &#125; &#125;&#125;class RunnableTest implements Runnable&#123; @Override public void run() &#123; // TODO Auto-generated method stub for(int i=0;i&lt;50;i++) &#123; System.out.println(&quot;Runnable中的run()方法正在运行。&quot;+i); if (i==20) &#123; break; &#125; &#125; &#125;&#125;1234567891011121314151617181920212223242526272829303132333435363738394041 运行： 也实现了多线程。 两种实现方式的区别和对比分析以一个窗口买票的例子演示两种方式的区别：假设有四个窗口，买100张票。以第一中方式： 1234567891011121314151617181920212223242526272829303132package com.stormwang.ThreadDemo;/*** @author StormWangxhu* @version 创建时间：2017年11月8日 上午11:06:38**/public class TicketWindowDemo &#123; public static void main(String[] args) &#123; //创建4个线程 new TicketWindowTest().start(); new TicketWindowTest().start(); new TicketWindowTest().start(); new TicketWindowTest().start(); &#125;&#125;class TicketWindowTest extends Thread&#123; private int ticketNum = 100; public void run() &#123; while (true) &#123; if (ticketNum&gt;0) &#123; Thread thread = Thread.currentThread();//获取当前线程 String th_name = thread.getName(); System.out.println(th_name+&quot; 正在发售第 &quot;+ticketNum+&quot; 张！&quot;); ticketNum--; &#125; &#125; &#125;&#125;1234567891011121314151617181920212223242526272829303132 运行： 会看到，每一个售票窗口各自买了100张票，显然与实不符合。 再看第二种方式： 123456789101112131415161718192021222324252627282930313233343536373839404142package com.stormwang.ThreadDemo;/*** @author StormWangxhu* @version 创建时间：2017年11月8日 上午11:19:46**/public class TicketsWindowDemo_2 &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub TicketWindow_1 ticketWindow_1 = new TicketWindow_1(); Thread thread = new Thread(ticketWindow_1, &quot;窗口1&quot;); Thread thread2 = new Thread(ticketWindow_1, &quot;窗口2&quot;); Thread thread3 = new Thread(ticketWindow_1, &quot;窗口3&quot;); Thread thread4 = new Thread(ticketWindow_1, &quot;窗口4&quot;); thread.start(); thread2.start(); thread3.start(); thread4.start(); &#125;&#125;class TicketWindow_1 implements Runnable&#123; private int ticketNumbet = 100 ; @Override public void run() &#123; while(true) &#123; if (ticketNumbet&gt;0) &#123; Thread thread = Thread.currentThread(); //获取当前运行run()方法的线程 String name = thread.getName();//得到线程的名称。 System.out.println(name+&quot; 正在发售 第 &quot;+ticketNumbet-- +&quot; 张！&quot;); &#125; &#125; &#125;&#125;123456789101112131415161718192021222324252627282930313233343536373839404142 运行： 可以看到，四个线程共享一个runnable资源。实现了共买100张票。 以上比较，实现Runnable接口有以下几点好处：1231、适合多个相同程序代码的线程去处理同一个资源的情况，把线程与程序代码、数据有效的分离，很好的体现了面向对象的设计思想。2、可以避免由于Java的单继承带来的局限性。在开发中经常碰到这样情况，就是使用一个继承了某一个父类的子类创建线程，由于一个类不能同时有两个父类，所依不能用继承Thrad类的方式，那么就只能采用Runnable接口的方式。123]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 多线程同步、死锁问题]]></title>
    <url>%2F2017%2F11%2F08%2F08--Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E3%80%81%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1、同步代码块当多个线程使用同一个共享资源时，可以将处理共享资源的代码放在一个使用synchronized关键字来修饰的代码块中，这个代码块被称作同步代码块。 语法格式如下： 123synchronized (lock)&#123;操作共享资源代码块&#125;123 解释：lock是一个锁对象，他是同步代码块的关键。当某一个线程执行同步代码块时，其他线程将无法执行当前同步代码块，会发生阻塞，等待当前线程执行完同步代码块后，所有线程开始抢夺线程的执行权，抢到执行权的线程将进入代码块，执行其中的代码。循环往复，知道共享资源被处理完为止。 这个过程就如一个公用电话亭，只有前一个人打完电话出来后，后面的人才可以打。 案例演示： 四个窗口，共售10张票。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.stormwang.ThreadDemo;/*** @author StormWangxhu* @version 创建时间：2017年11月8日 上午11:19:46**/public class TicketsWindowDemo_2 &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub TicketWindow_1 ticketWindow_1 = new TicketWindow_1(); //创建线程的任务类对象 Thread thread = new Thread(ticketWindow_1, &quot;窗口1&quot;); Thread thread2 = new Thread(ticketWindow_1, &quot;窗口2&quot;); Thread thread3 = new Thread(ticketWindow_1, &quot;窗口3&quot;); Thread thread4 = new Thread(ticketWindow_1, &quot;窗口4&quot;); thread.start(); thread2.start(); thread3.start(); thread4.start(); &#125;&#125;//线程的任务类。class TicketWindow_1 implements Runnable&#123; private int ticketNumbet = 10 ; Object lock = new Object(); //定义任意一个对象，用做同步代码块的锁。 @Override public void run() &#123; while(true) &#123; synchronized (lock) &#123; try &#123; Thread.sleep(1000); //线程休眠10毫秒 &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; if (ticketNumbet&gt;0) &#123; Thread thread = Thread.currentThread(); //获取当前运行run()方法的线程 String name = thread.getName();//得到线程的名称。 System.out.println(name+&quot; 正在发售 第 &quot;+ticketNumbet-- +&quot; 张！&quot;); &#125; else &#123; break; &#125; &#125; &#125;&#125;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 运行： 注意：12345同步代码块中的锁对象可以是任意类型的对象，但多个线程共享的锁对象必须是唯一的。“任意”： 指的是共享锁对象的类型。锁对象的创建代码块不能放到run()方法中，否则每一个线程运行到run(）方法都会创建一个新对象，这样每个线程都会有一个不同的锁，每个锁都有自己的标志位，这样的线程之间便不会产生同步的效果。12345 再来学习同步方法，该方法和把操作共享资源的代码块放在sychronized（）中产生一样的效果。 同步方法在方法前面加sychronized关键字来修饰，同样可以实现同步代码块相同的功能。 语法格式如下： 12sychronized 返回值类型 方法名（[参数1，...]）&#123;&#125;12 说明：被sychronized关键字修饰的方法在某一时刻只允许一个线程访问，访问该方法的其他线程都会发生阻塞，直到当前线程访问完毕后，其他线程才有机会执行该方法。 修改售票案例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.stormwang.ThreadDemo;/*** @author StormWangxhu* @version 创建时间：2017年11月8日 上午11:19:46**/public class TicketsWindowDemo_2 &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub TicketWindow_1 ticketWindow_1 = new TicketWindow_1(); //创建线程的任务类对象 Thread thread = new Thread(ticketWindow_1, &quot;窗口1&quot;); Thread thread2 = new Thread(ticketWindow_1, &quot;窗口2&quot;); Thread thread3 = new Thread(ticketWindow_1, &quot;窗口3&quot;); Thread thread4 = new Thread(ticketWindow_1, &quot;窗口4&quot;); thread.start(); thread2.start(); thread3.start(); thread4.start(); &#125;&#125;//线程的任务类。class TicketWindow_1 implements Runnable&#123; private int ticketNumbet = 10 ;// Object lock = new Object(); //定义任意一个对象，用做同步代码块的锁。 @Override public void run() &#123; while(true) &#123; SaleTicket(); &#125; &#125; public synchronized void SaleTicket() &#123; try &#123; Thread.sleep(1000); //线程休眠10毫秒 &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; if (ticketNumbet&gt;0) &#123; Thread thread = Thread.currentThread(); //获取当前运行run()方法的线程 String name = thread.getName();//得到线程的名称。 System.out.println(name+&quot; 正在发售 第 &quot;+ticketNumbet-- +&quot; 张！&quot;); &#125; else &#123; System.exit(0); &#125; &#125;&#125;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 运行： 效果一样！描述:将售票代码收取为方法SaleTicket()，并用sychronized关键字修饰把SaleTicket（）方法修饰为同步方法，然后在run()方法中调用该方法。 2、死锁问题看一个实例： 该实例结果可想而知，两个人都吃不上饭。 银行存款程序设计（应用多线程）描述：假设有两个储户都去银行往同一个账户存款，一次存100，每人存3次。要求储户每存一次钱，账户余额增加100元 Bank类： 1234567891011121314151617181920212223package com.stormwang.ThreadExample;/*** @author StormWangxhu* @version 创建时间：2017年11月8日 下午3:56:18**/public class Bank &#123; private int sum ; //方法一 public void add_1(int num ) &#123; synchronized (this) &#123; sum = sum + num ; System.out.println(&quot;账户的余额为 ：&quot;+sum); &#125; &#125; //方法二 public synchronized void add_2(int num) &#123; sum = sum + num ; System.out.println(&quot;账户余额为：&quot;+sum); &#125;&#125;1234567891011121314151617181920212223 储户类： 1234567891011121314151617181920package com.stormwang.ThreadExample;/*** @author StormWangxhu* @version 创建时间：2017年11月8日 下午3:56:32**/public class Customer implements Runnable&#123; Bank bank = new Bank(); @Override public void run() &#123; // TODO Auto-generated method stub for (int i = 0; i &lt; 3; i++) &#123;// bank.add_1(100); bank.add_2(100); &#125; &#125; &#125;1234567891011121314151617181920 测试类： 1234567891011121314151617181920package com.stormwang.ThreadExample;/*** @author StormWangxhu* @version 创建时间：2017年11月8日 下午3:57:12**/public class SaveMoneyTest &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub Customer customer = new Customer(); Thread thread = new Thread(customer); Thread thread2 = new Thread(customer); thread.start(); thread2.start(); &#125;&#125;1234567891011121314151617181920 运行后： 成功！]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java jdk5.0新特性——泛型]]></title>
    <url>%2F2017%2F11%2F06%2F06--Java-jdk5.0%E6%96%B0%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[泛型集合可以存储任何类型的对象，但是当把一个对象存入集合后，集合会“忘记”这个对象的类型，将该对象从集合中取出时，这个对象的编译类型就变成了Object类型。换句话说，在程序中无法确定集合中的元素到底是什么类型。那么在取出元素时，如果进行强制类型转换，就会很容易出错。 结合代码来看看： 1234567891011121314151617181920212223242526272829package com.stormwang.MapTest;import java.util.ArrayList;import java.util.Iterator;/*** @author StormWangxhu* @version 创建时间：2017年11月6日 下午8:27:45**/public class ParameterizedTypeDemo &#123; public static void main(String[] args) &#123; ArrayList arrayList = new ArrayList&lt;&gt;(); arrayList.add(&quot;java&quot;); arrayList.add(&quot;Collection&quot;); arrayList.add(&quot;String&quot;); arrayList.add(1); Iterator it = arrayList.iterator(); while (it.hasNext()) &#123; Object object = (Object) it.next(); System.out.println(object); &#125; &#125;&#125;1234567891011121314151617181920212223242526272829 编译运行： 我们看到，程序将集合中的元素输出时，将类型都转换为了Object类型。或许这样并不好。那么泛型出现就可以指定集合所装元素的类型。下面我们使用泛型来演示一下： 我们看到指定泛型后，在编译时就出现了错误，Integer对象无法转换为String类型，因此程序在编译时就已经无法通过！避免了运行时出现的错误。 那么，我们学习一下泛型 泛型格式1ArrayList&lt;参数化类型&gt; list = new ArrayList&lt;参数化类型&gt;（）；1 那么，我们使用泛型来演练一下： 1234567891011121314151617181920212223242526272829package com.stormwang.MapTest;import java.util.ArrayList;import java.util.Iterator;/*** @author StormWangxhu* @version 创建时间：2017年11月6日 下午8:27:45**/public class ParameterizedTypeDemo &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;(); arrayList.add(&quot;java&quot;); arrayList.add(&quot;Collection&quot;); arrayList.add(&quot;String&quot;); ///arrayList.add(1); Iterator it = arrayList.iterator(); while (it.hasNext()) &#123; String object = (String) it.next(); System.out.println(object); &#125; &#125;&#125;1234567891011121314151617181920212223242526272829 编译运行： 这样的话，程序就可以正常运行了。 注意：在使用泛型后，每次遍历集合元素时，可以指定该元素类型为String,或者是自己定义的类型，而不是Object，这样就可以避免了在程序中使用强制类型转换。 思考题（1）、简述List、Set、Map 这3个接口存取元素时各有什么特点？（2）、简述使用泛型的优点！ 在这里我们先解决第二个思考题：优点：1、可以先定义集合元素的类型，避免了装箱、拆箱的麻烦。2、在编译时就可以发现错误，避免程序在运行时出现错误。3、。。。。。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse 如何查看 Java源码]]></title>
    <url>%2F2017%2F11%2F06%2F06--eclipse-%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8BJava%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[今天自己在eclipse中想查看Java源码，试了好多次，都失败了，不知道怎么样才能够在eclipse中阅读源码。还好没放弃，最后成功了！ 在Eclipse中查看JDK类库的源代码！！！步骤如下： 设置1、点“Window”—&gt;”preferences”—&gt;”Java”—&gt;”Installed JRE” 此时右边会出现一个表格。如图所示： 2、右边表格里列出了系统的JRE环境，选择JRE，点击一下，然后点击右边的Edit… 3、接下来，我们会看到很多以.jar结尾的文件。我们选择rt.jar. 点 左边的“&gt;” 号展开它，4.展开后，可以看到“Source Attachment:(none)”，点这一项，点右边的按钮“Source Attachment…”.5、 选择JDK所在目录下的 “src.zip”文件5.一路点”ok”,结束。 6、接下来我们就可以在eclipse中看源码了，将鼠标放在想要查看的类名或方法名下面，按住Ctrl,右击鼠标，就可以查看了！ 如图所示： 说明：dt.jar是关于运行环境的类库,主要是swing的包tools.jar是关于一些工具的类库rt.jar包含了jdk的基础类库，也就是你在java doc里面看到的所有的类的class文件。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>eclipse</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashSet 模拟新浪微博用户注册]]></title>
    <url>%2F2017%2F11%2F06%2F06--HashSet%E6%A8%A1%E6%8B%9F%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%2F</url>
    <content type="text"><![CDATA[1、任务描述编写一个新浪微博用户注册的程序，要求使用HashSet集合实现。假设当用户输入用户名、密码、确认密码、生日（输入格式yyyy-mm-dd为正确）、手机号码（手机长度为11位，并且以13、15、17、或18开头的手机号为正确）、邮箱（包含符号“@”为正确）信息之后，判断信息是否输入正确，正确校验用户是否重复注册，如果不是重复注册，则注册成功。 实现思路（1）、为了便于存储用户信息，需要创建一个用户类，在类中重写其中的HashCode(）方法，令其返回用户名的哈希值，再重写equals()方法，来比较对象的用户名属性是否相等。（2）、有了用户类之后，再需要1一个用户注册类来模拟注册信息，该类中可以用HashSet集合来创建一个数据列表，然后向列表中添加两条初始注册信息。（3）、从控制台获取用户填写信息，可以通过Scanner类的nextLine(）方法来实现，获取后，需要将获取的信息校验。（4）、校验信息可以创建一个检验类，在类中实现用户输入的信息的方法。检验结束后，如果检验结果错误就直接返回错误信息，这里可以声明一个检验结果变量和一个检验状态变量。检验结果变量用于存储提示信息，检验状态变量用于存储结果的判断标识。（5）、当用户输入的信息不满足格式时，需要修改变量1状态并存储错误信息。（6）、判断校验状态，如果所有信息都通过校验，则将用户信息创建成为用户对象，通过将对象添加到用户列表返回结果来判断用户名是否重复，并记录下返回结果信息。 下面来看看代码User类： 创建用户类，并重写其HashCode(）方法和equals（）方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.stormwang.HashTest;/*** @author StormWangxhu* @version 创建时间：2017年11月5日 上午12:14:37**//** * 用户类 * *///用户信息public class User &#123; private String userName ; //用户名 private String password ; //密码 private String birthday ; //生日 private String telNumber ; //手机号 private String email ; //邮箱 public User()&#123; &#125; public User(String userName, String password, String birthday, String telNumber, String email) &#123; super(); this.userName = userName; this.password = password; this.birthday = birthday; this.telNumber = telNumber; this.email = email; &#125; @Override public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + ((userName == null) ? 0 : userName.hashCode()); return result; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; User other = (User) obj; if (userName == null) &#123; if (other.userName != null) return false; &#125; else if (!userName.equals(other.userName)) return false; return true; &#125;&#125;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 用户注册类：创建用户注册完类，模拟注册信息。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.stormwang.HashTest;/*** @author StormWangxhu* @version 创建时间：2017年11月5日 上午12:23:56**///创建用户注册类import java.util.Date;import java.util.HashSet;import java.util.Scanner;public class UserRegister &#123; public static HashSet&lt;User&gt; USER_DATE =new HashSet&lt;&gt;(); public static void main(String[] args) &#123; initData(); //初始化人员信息 Scanner scanner = new Scanner(System.in); System.out.print(&quot;请输入用户名：&quot;); String userName = scanner.nextLine(); //获取用户名 System.out.print(&quot;请输入登录密码：&quot;); String password = scanner.nextLine(); //获取登录密码 System.out.print(&quot;请重复密码：&quot;); String rePassword = scanner.nextLine(); // 获取重复密码 System.out.print(&quot;出生日期：&quot;); String birthday = scanner.nextLine(); //获取出生日期 System.out.print(&quot;请输入手机号：&quot;); String telNumber = scanner.nextLine(); // 获取手机号 System.out.print(&quot;请输入邮箱：&quot;); String email = scanner.nextLine(); // 获取邮箱账号 //校验信息，返回登录状态信息 CheckInfo checkInfo = new CheckInfo(USER_DATE); String result = checkInfo.checkAction(userName,password,rePassword,birthday,telNumber,email); System.out.println(&quot;注册结果：&quot;+result); System.out.println(&quot;是否查询数据库信息：&quot;); String answer = scanner.nextLine(); if ((answer.equals(&apos;y&apos;))||(answer.equals(&apos;Y&apos;))) &#123; new PrintInfo(USER_DATE).showInfo(); &#125;else &#123; System.out.println(&quot;查询失败！&quot;); &#125; &#125; private static void initData() &#123; User user1 = new User(&quot;小明&quot;, &quot;123456&quot;, &quot;1998-02-06&quot;, &quot;18810319240&quot;, &quot;2690582170@qq.com&quot;); User user2 = new User(&quot;小王&quot;, &quot;654321&quot;, &quot;1997-01-01&quot;, &quot;15379648332&quot;, &quot;1234567890@qq.com&quot;); USER_DATE.add(user1); USER_DATE.add(user2); &#125;&#125;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 创建信息校验类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package com.stormwang.HashTest;import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;import java.util.HashSet;/*** @author StormWangxhu* @version 创建时间：2017年11月6日 上午11:02:58**//** * 校验信息类 * */public class CheckInfo &#123; public static HashSet&lt;User&gt; USER_DATE = new HashSet&lt;&gt;(); public CheckInfo(HashSet&lt;User&gt; USER_DATE) &#123; // TODO Auto-generated constructor stub this.USER_DATE = USER_DATE; &#125; //校验用户信息返回登录状态 public String checkAction(String userName, String password, String rePassword, String birthday, String telNumber, String email) &#123; StringBuilder result = new StringBuilder(); //字符串构造器 // 1 代表成功 ，2 代表失败 int state = 1; //密码判断 if (!password.equals(rePassword)) &#123; System.out.println(&quot;两次输入的密码不一致！ \r\n&quot;); state = 2 ; &#125; //生日判断 if (birthday.length() != 10) &#123; System.out.println(&quot;生日格式不正确！\r\n&quot;); state = 2 ; &#125;else &#123; for(int i=0;i&lt;birthday.length();i++) &#123; Character thisChar = birthday.charAt(i); if (i==4 || i==7 ) &#123;//验证第四位和第七位是否为符号“-” if (!(thisChar == &apos;-&apos;)) &#123; result.append(&quot;生日格式不正确！\r\n&quot;); state =2 ; &#125; &#125;else &#123;//验证除了第四位和第七位的字符是否为数字。 if (!(Character.isDigit(thisChar))) &#123; result.append(&quot;生日格式不正确\r\n&quot;); state =2 ; &#125; &#125; &#125; &#125; //手机号判断 if (telNumber.length()!=11) &#123; result.append(&quot;手机号码不正确！\r\n&quot;); state =2 ; //默认有效手机号为13,15,17和18开头的手机号 &#125;else if (!(telNumber.startsWith(&quot;13&quot;)||telNumber.startsWith(&quot;15&quot;)||telNumber.startsWith(&quot;17&quot;) || telNumber.startsWith(&quot;18&quot;))) &#123; state = 2; &#125; //邮箱判断 if (!email.contains(&quot;@&quot;)) &#123; result.append(&quot;邮箱不正确！\r\n&quot;); state = 2; &#125; //如果以上信息都校验无误，则将新用户加入到集合 if (state ==1 ) &#123; //格式化日期返会Date 对象 DateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date dateBirthday = null; try &#123; dateBirthday = format.parse(birthday);//parse()从给定的字符串开始解析文本，以生成一个日期。 &#125; catch (ParseException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; User newUser = new User(userName, password, birthday, telNumber, email); //将新用户添加到列表中，同时根据HashSet判断出用户名是否重复 if (!USER_DATE.add(newUser)) &#123; result.append(&quot;用户重复！&quot;); state = 2 ; &#125; if (state ==1 ) &#123; result.append(&quot;注册成功！&quot;); &#125; &#125; return result.toString();//toString()方法： 将指定的数据以字符串形式返回。 &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HashSet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java HashMap 集合初探（一）]]></title>
    <url>%2F2017%2F11%2F06%2F06--Java-HashMap%E9%9B%86%E5%90%88%E5%88%9D%E6%8E%A2%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Map集合介绍先通过图了解 Map集合存储具有映射关系的数据。 Map接口是一种双列集合，它的每一个元素都包含一个键对象Key和值对象Value,键和值之间存在一种对应关系，称为映射。从Map集合中访问元素时，只要指定了Key,就能找到对应得Value. 再来一张 看看API常用方法： Map中的键具有唯一性！！！！ （一）HashMap集合练习下面我们通过一个实例来演示HashMap集合最基本的操作： 存入（put）、取出(get)： 123456789101112131415161718192021222324252627282930package com.stormwang.MapTest;import java.util.HashMap;import java.util.Map;/*** @author StormWangxhu* @version 创建时间：2017年11月6日 下午4:04:01**/public class MapDemo_1 &#123; public static void main(String[] args) &#123; Map map = new HashMap&lt;&gt;(); //向集合中增加元素 map.put(&quot;1&quot;, &quot;Jack&quot;); map.put(&quot;2&quot;,&quot;Rose&quot;); map.put(&quot;3&quot;, &quot;Mark&quot;); map.put(&quot;4&quot;, &quot;wang&quot;); //取出元素 System.out.println(&quot;1:&quot;+map.get(&quot;1&quot;)); System.out.println(&quot;2:&quot;+map.get(&quot;2&quot;)); System.out.println(&quot;3:&quot;+map.get(&quot;3&quot;)); System.out.println(&quot;4:&quot;+map.get(&quot;4&quot;)); &#125;&#125;123456789101112131415161718192021222324252627282930 运行后看一下结果： 前面介绍到：Map中的键具有唯一性。下面向Map集合中存储一个相同的键看看会出现什么情况。将代码进行修改 123456789101112131415161718192021222324252627282930package com.stormwang.MapTest;import java.util.HashMap;import java.util.Map;/*** @author StormWangxhu* @version 创建时间：2017年11月6日 下午4:04:01**/public class MapDemo_1 &#123; public static void main(String[] args) &#123; Map map = new HashMap&lt;&gt;(); map.put(&quot;1&quot;, &quot;Jack&quot;); map.put(&quot;2&quot;,&quot;Rose&quot;); map.put(&quot;3&quot;, &quot;Mark&quot;); map.put(&quot;4&quot;, &quot;wang&quot;); //对代码进行修改 map.put(&quot;4&quot;, &quot;tian&quot;); System.out.println(&quot;1:&quot;+map.get(&quot;1&quot;)); System.out.println(&quot;2:&quot;+map.get(&quot;2&quot;)); System.out.println(&quot;3:&quot;+map.get(&quot;3&quot;)); System.out.println(&quot;4:&quot;+map.get(&quot;4&quot;)); &#125;&#125;123456789101112131415161718192021222324252627282930 运行： 可以看出：Map中仍然有4个元素，只是第五次添加得值“tian”覆盖了原来的值“wang”,这也证实了Map中的键必须是唯一的，不能重复，如果存储了相同的键，后存储的值就会覆盖原有的值。 简言之： 键相同，值覆盖！！！！ （二）HashMap集合的遍历程序开发中，经常需要取出Map中的所有键和值，那么如何遍历Map中所有键和值？ 有两种方式可以实现：（1）、先遍历Map集合中所有的键，再根据键获取相应的值。案例演示： 1234567891011121314151617181920212223242526272829303132package com.stormwang.MapTest;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Set;/*** @author StormWangxhu* @version 创建时间：2017年11月6日 下午4:04:01**/public class MapDemo_1 &#123; public static void main(String[] args) &#123; Map map = new HashMap&lt;&gt;(); map.put(&quot;1&quot;, &quot;Jack&quot;); map.put(&quot;2&quot;,&quot;Rose&quot;); map.put(&quot;3&quot;, &quot;Mark&quot;); map.put(&quot;4&quot;, &quot;wang&quot;); //先获得键的集合 Set keySet = map.keySet(); Iterator iterator = keySet.iterator(); //获得存储键集合的迭代器 while (iterator.hasNext()) &#123; Object key = (Object) iterator.next(); Object value = (Object)map.get(key); System.out.println(key+&quot;:&quot;+value); &#125; &#125;&#125;1234567891011121314151617181920212223242526272829303132 运行： 遍历成功！ 将所有的键存储的集合Set,再获得该集合的迭代器。 （2）、另一中遍历方式，是先获取集合中所有的映射关系，然后从映射关系中取出键和值。案例演示： 123456789101112131415161718192021222324252627282930313233343536package com.stormwang.MapTest;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.Set;/*** @author StormWangxhu* @version 创建时间：2017年11月6日 下午4:04:01**/public class MapDemo_1 &#123; public static void main(String[] args) &#123; //创建Map集合 Map map = new HashMap&lt;&gt;(); //存储键和值 map.put(&quot;1&quot;, &quot;Jack&quot;); map.put(&quot;2&quot;,&quot;Rose&quot;); map.put(&quot;3&quot;, &quot;Mark&quot;); map.put(&quot;4&quot;, &quot;wang&quot;); Set entrySet = map.entrySet(); //获取集合中的键值对映射 Iterator iterator = entrySet.iterator(); //获取Iterator对象 while (iterator.hasNext()) &#123; Map.Entry entry = (Map.Entry)(iterator.next());//获取集合中的键值对映射 Object key = entry.getKey(); //获取Entry中的键 Object value = entry.getValue(); //获取Entry中的值 System.out.println(key+&quot;:&quot;+value); &#125; &#125;&#125;123456789101112131415161718192021222324252627282930313233343536 运行： 遍历成功！！！！ 接下来看看第二种方式中EntrySet. 第二种方式解释：首先调用Map对象的entrySet(）方法获得存储在Map中所有映射的Set集合，这个集合中存放了Map.Entry类型的元素（Entry是Map内部接口），每一个Map.Entry对象代表Map中的一个键值对，然后迭代Set集合，获得一个映射对象，并分别调用对象的getKey()和getValue(）来获取键和值。 特例：Map集合还提供了一个values()方法，来直接获取Map集合中存储所有值的Collection集合。案例演示： 12345678910111213141516171819202122232425262728293031323334package com.stormwang.MapTest;import java.util.Collection;import java.util.HashMap;import java.util.Iterator;import java.util.Map;/*** @author StormWangxhu* @version 创建时间：2017年11月6日 下午4:04:01**/public class MapDemo_1 &#123; public static void main(String[] args) &#123; //创建Map集合 Map map = new HashMap(); //存储键和值 map.put(&quot;1&quot;, &quot;Jack&quot;); map.put(&quot;2&quot;,&quot;Rose&quot;); map.put(&quot;3&quot;, &quot;Mark&quot;); map.put(&quot;4&quot;, &quot;wang&quot;); Collection values = map.values(); Iterator iterator = values.iterator(); while (iterator.hasNext()) &#123; Object object = (Object) iterator.next(); System.out.println(values); &#125; &#125;&#125;12345678910111213141516171819202122232425262728293031323334 运行结果： 通过调用Map的values()方法获取Map中所有值的Collection集合，然后迭代出集合中的每一个值。 声明: HashMap不能保证迭代出来的元素顺序和存入的顺序一致。若要想一定保证取出和存入顺序一致，则可用LinkedHashMap类。 LinkedHashMap类： 是HashMap类的子类，与LinkedList集合一样，它也使用双向链表来维护内部元素的顺序关系，使Map集合元素的迭代的顺序和存入的顺序一致。 案例演示： 1234567891011121314151617181920212223242526272829303132package com.stormwang.MapTest;import java.util.Iterator;import java.util.LinkedHashMap;import java.util.Map;import java.util.Set;/*** @author StormWangxhu* @version 创建时间：2017年11月6日 下午5:56:06**/public class LinkedMapDemo_1 &#123; public static void main(String[] args) &#123; Map map = new LinkedHashMap&lt;&gt;(); map.put(&quot;1&quot;, &quot;Jack&quot;); map.put(&quot;2&quot;,&quot;Rose&quot;); map.put(&quot;3&quot;, &quot;Mark&quot;); map.put(&quot;4&quot;, &quot;wang&quot;); Set keySet = map.keySet(); Iterator iterator = keySet.iterator(); while (iterator.hasNext()) &#123; Object key = (Object) iterator.next(); Object value = map.get(key); System.out.println(key+&quot;:&quot;+value); &#125; &#125;&#125;1234567891011121314151617181920212223242526272829303132 运行： 这样一定会保证迭代元素的顺序和存入的顺序一致。 &amp;Properties集合 ——-properties:属性Map接口中还有一个实现类Hashtable,它和HashMap集合十分相似。区别： Hashtable是线程安全的。 Hashtable存取元素速度很慢，目前基本上被HashMap取代，但是Hashtable类有一个子类Properties,在实际应用中非常重要。 主要用途： 主要用来存取字符串类型的键和值，在实际开发中，经常使用Properties集合来存取应用的配置项。 比如说：假设有一个文本工具，要求默认背景为红色，字体大小为14px，语言为中文。 123Blackground-color = red ;Font-size = 14px ;Language = Chinese ;123 在程序中可以使用Properties集合对这些配置项进行存取。来一个Demo看： 1234567891011121314151617181920212223242526272829303132package com.stormwang.MapTest;import java.util.Enumeration;import java.util.Properties;/*** @author StormWangxhu* @version 创建时间：2017年11月6日 下午6:16:51**/public class PropertiesDemo &#123; public static void main(String[] args) &#123; Properties properties = new Properties(); //创建Properties对象 //添加元素 //setProperties()就会调用Hashtable的put(String key,String value)方法 properties.setProperty(&quot;Black-color&quot;, &quot;red&quot;); properties.setProperty(&quot;Font-size&quot;, &quot;14px&quot;); properties.setProperty(&quot;Language&quot;, &quot;Chinese&quot;); Enumeration names = properties.propertyNames(); //返回属性列表中所有键的枚举。 while (names.hasMoreElements()) &#123; String key = (String) names.nextElement(); String value =properties.getProperty(key); System.out.println(key+&quot; = &quot;+value); &#125; &#125;&#125;1234567891011121314151617181920212223242526272829303132 运行： 说明：Peopeoties类中，针对字符串的存取提供了两个专用的方法： setProperty(): 从中可以看到，该方法会调用Hashtable的put(）方法。那为什么不直接调用put()方法呢？ 看看原因：红框圈出。 getProperty() 有两种类型方法： 都是根据传入的键来返会该键所对应的值。 propertyNames(）方法得到一个包含所有键的Enumeration对象。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java HashSet 集合初探]]></title>
    <url>%2F2017%2F11%2F04%2F04--Java-HashSet%E9%9B%86%E5%90%88%E5%88%9D%E6%8E%A2%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Set集合先来看看集合框架图： 与List接口相同点：同样继承自Collection接口，它与Collection接口中的方法基本一致，并没有对Collection接口进行功能上的增强，但比Collection接口更加严格！ 不同点Set接口中的元素 无序、不重复！ 至于以什么样的方式保证不重复，其原因后面会说到。 先来结合代码看看HashSet集合中添加重复元素会发生什么： 123456789101112131415161718192021222324252627package com.stormwang.SetTest;import java.util.HashSet;import java.util.Iterator;/*** @author StormWangxhu* @version 创建时间：2017年11月4日 下午4:03:26**/public class HashSetDemo &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub HashSet set= new HashSet(); //向集合中添加元素 set.add(&quot;java&quot;); set.add(&quot;Friday&quot;); set.add(&quot;java&quot;); Iterator iterator = set.iterator(); while (iterator.hasNext()) &#123; Object object = (Object) iterator.next(); System.out.println(object); &#125; &#125;&#125;123456789101112131415161718192021222324252627 再来看看结果： 在代码中，重复了字符串Java，但是运行后，只保留下了一个。且可以看出，取出顺序和加入顺序也不一致。 原因：不重复是因为做了很多工作：当向Set集合中添加对象时，add().步骤：1、首先调用当前存入对象的hashCode()方法，获得该对象哈希值。2、根据哈希值确定其存储位置。3、判断该位置上是否有对象 （1）、无对象，则存入集合。（2）、有对象 ———-&gt;&gt;&gt;调用equal()方法，比较对象是否相等。（3）、相等——-&gt;&gt;&gt;舍弃该对象不相等——存入该集合。 下面根据图来理解一下： 则要想HashSet正常工作，就必须重写hashCode()方法、equals()方法。 下面以没有重写两个方法演示一下后果： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.stormwang.SetTest;/*** @author StormWangxhu* @version 创建时间：2017年11月4日 下午4:35:50**/import java.util.HashSet;import java.util.Iterator;/** * 不复写hashCode()方法、equals()方法 * */public class HashDemo &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub //创建集合 HashSet set =new HashSet&lt;&gt;(); //创建Student对象 Student student = new Student(&quot;1&quot;, &quot;Jack&quot;); Student student2 = new Student(&quot;2&quot;, &quot;mary&quot;); Student student3 = new Student(&quot;3&quot;, &quot;Rose&quot;); Student student4 = new Student(&quot;3&quot;, &quot;Rose&quot;); set.add(student); set.add(student2); set.add(student3); set.add(student4); Iterator iterator = set.iterator(); while (iterator.hasNext()) &#123; Object object = (Object) iterator.next(); System.out.println(object); &#125; &#125;&#125;class Student&#123; private String id ; private String name ; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; //构造方法 public Student(String id,String name ) &#123; this.id = id; this.name = name ; &#125; // @Override public String toString() &#123; return &quot;Student [id=&quot; + id + &quot;, name=&quot; + name + &quot;]&quot;; &#125;&#125;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 看一下运行后效果： 看到： 出现了相同的值： [ id=3,name=Rose]. 原因分析是因为在类没有重写hashCode()方法，和equals()方法。这样的重复在HashSet集合中理应是不存在的。那么就重写这两个方法试试。假设id相同的学生是一同一个学生。看代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package com.stormwang.SetTest;/*** @author StormWangxhu* @version 创建时间：2017年11月4日 下午4:35:50**/import java.util.HashSet;import java.util.Iterator;/** * 不复写hashCode()方法、equals()方法 * */public class HashDemo &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub //创建集合 HashSet set =new HashSet&lt;&gt;(); //创建Student对象 Student student = new Student(&quot;1&quot;, &quot;Jack&quot;); Student student2 = new Student(&quot;2&quot;, &quot;mary&quot;); Student student3 = new Student(&quot;3&quot;, &quot;Rose&quot;); Student student4 = new Student(&quot;3&quot;, &quot;Rose&quot;); set.add(student); set.add(student2); set.add(student3); set.add(student4); Iterator iterator = set.iterator(); while (iterator.hasNext()) &#123; Object object = (Object) iterator.next(); System.out.println(object); &#125; &#125;&#125;class Student&#123; private String id ; private String name ; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; //构造方法 public Student(String id,String name ) &#123; this.id = id; this.name = name ; &#125; // @Override public String toString() &#123; return &quot;Student [id=&quot; + id + &quot;, name=&quot; + name + &quot;]&quot;; &#125; @Override public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + ((id == null) ? 0 : id.hashCode()); result = prime * result + ((name == null) ? 0 : name.hashCode()); return result; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Student other = (Student) obj; if (id == null) &#123; if (other.id != null) return false; &#125; else if (!id.equals(other.id)) return false; if (name == null) &#123; if (other.name != null) return false; &#125; else if (!name.equals(other.name)) return false; return true; &#125;&#125;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101 再来看看运行结果： 重复的没有了，保证了元素的不重复性。也会看到元素的无序性。 再看看HashSet的API构造函数： 方法： HashSet的一些常用方法添加元素hashset.add(E e)：返回boolean型，如果此 set 中尚未包含指定元素，则添加指定元素；如果此 set 已包含该元素，则该调用不更改 set 并返回 false。 删除元素：hashset.clear()：从此 set 中移除所有元素。hashset.remove(Object o)：如果指定元素存在于此 set 中，则将其移除。hashset.isEmpty()：如果此 set 不包含任何元素，则返回 true。hashset.contains(Object o)：如果此 set 包含指定元素，则返回 true。hashset.size()：返回此 set 中的元素的数量（set 的容量）。 总结： 1要想HashSet正常工作，必须重写hashCode()方法和equals()方法。1 重写技巧： 右击——–&gt;&gt;source———-&gt;&gt;Generate hashCode() and equals(）…. 1就看到这儿吧，晚上再来一个实例练习HashSet()。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java LinkedList 之KTV点歌系统]]></title>
    <url>%2F2017%2F11%2F04%2F04--Java-LinkedList%E4%B9%8BKTV%E7%82%B9%E6%AD%8C%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[1好好学习，天天向上！ 今天来练习一下昨天学的ArrayList和LinkedList.通过一个简单KTV点歌系统，达到练习LinkedList的方法使用。 KTV点歌系统介绍功能介绍：1、将歌曲置顶2、将歌曲前移一位3、退出系统4、添加歌曲到列表 实现步骤：1、 （1）、为了指引用户操作，首先将各个指令打印到控制台。 （2）、程序中需要创建一个集合作为歌曲列表，并向其添加一部分歌曲。 （3）、由于控制台需要实时等待用户的输入，所以用while(true)来使程序一直处于等待用户输入指令的状态。 （4）、可以通过Scanner类的nextInt()方法接受来自控制台的信息。 （5）、可以使用switch语句，根据控制台传入的指令，判断应该执行的操作。 （6）、通过LinkedList集合或ArrayList集合定义的方法操作歌曲列表。 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175package com.stormwang.ListTest;import java.util.Iterator;import java.util.LinkedList;import java.util.Scanner;/*** @author StormWangxhu* @version 创建时间：2017年11月4日 上午9:50:42**//** * KTV点歌系统： * 主要应用 LinkedList 增删改查 * 五个模块： * 模块一： 初始化列表 * 模块二: 添加歌曲至列表 * 模块三： 将歌曲至顶 * 模块四： 将歌曲前移一位 * 模块五 ： 退出系统 * */public class KTVByLinkedList &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub //初始化列表 System.out.println(&quot;---------------欢迎来到KTV点歌系统------------------&quot;); System.out.println(&quot;0------添加歌曲至列表&quot;); System.out.println(&quot;1------将歌曲至顶&quot;); System.out.println(&quot;2------将歌曲前移一位&quot;); System.out.println(&quot;3------退出系统&quot;); System.out.println(&quot;4------将歌曲乱序&quot;); //接受用户的输入 System.out.println(&quot;请输入数字来实现相应功能：&quot;); //创建歌曲列表 LinkedList linkedList = new LinkedList&lt;&gt;(); //初始化列表 addListMusic(linkedList); while (true) &#123; Scanner scanner = new Scanner(System.in); int number = scanner.nextInt(); switch(number) &#123; case 0 : addMusic(linkedList); break; case 1 : setTop(linkedList); break; case 2 : setBefore(linkedList); break; case 3 : exit(); break; default : System.out.println(&quot;您输入的数字有误，请重新输入！&quot;); break; &#125; &#125; &#125; // 模块一 ：初始化列表 private static void addListMusic(LinkedList linkedList) &#123; // TODO Auto-generated method stub linkedList.add(&quot;旧情人，我是时间的新欢&quot;); linkedList.add(&quot;奔跑&quot;); linkedList.add(&quot;感谢--龙井说唱&quot;); linkedList.add(&quot;完美生活&quot;); linkedList.add(&quot;执着&quot;); linkedList.add(&quot;我们的时光---赵雷&quot;); System.out.println(&quot;歌单中有歌曲 ：&quot;+linkedList.size()+&quot; 首 ！&quot;); System.out.println(&quot;歌单列表为：&quot;); Iterator iterator = linkedList.iterator(); while (iterator.hasNext()) &#123; Object object = (Object) iterator.next(); System.out.println(object); &#125; &#125; //模块二： 实现将歌曲添加至列表 private static void addMusic(LinkedList linkedList) &#123; System.out.print(&quot;请输入您要添加歌曲的名称： &quot;); Scanner scanner = new Scanner(System.in); String addMusicName = scanner.nextLine(); //若存在，则不输入，反之添加成功 if (((linkedList.indexOf(addMusicName)) ==-1)) &#123; //不存在，则将歌曲添加至集合末尾 linkedList.addLast(addMusicName); System.out.println(&quot;添加成功！&quot;); &#125;else &#123; System.out.println(&quot;您要添加得歌曲已在列表中！&quot;); &#125; System.out.println(&quot;修改后歌单：&quot;); for (Object object : linkedList) &#123; System.out.println(object); &#125; &#125; //模块五： 实现退出系统 private static void exit() &#123; System.out.println(&quot;感谢您的使用！&quot;); System.out.println(&quot;-----------您已退出系统-------------&quot;); //退出程序 System.exit(0); &#125; //模块四 ： 将歌曲前移一位 private static void setBefore(LinkedList linkedList) &#123; System.out.print(&quot;请输入您要至前歌曲的名称：&quot;); Scanner scanner = new Scanner(System.in); String musicName = scanner.nextLine(); //查找指定歌曲位置 int position ; position = linkedList.indexOf(musicName); if (position==0) &#123; System.out.println(&quot;已到顶部，无法前移！&quot;); &#125;else if (position&lt;0) &#123; System.out.println(&quot;该歌曲不在列表中，请重新输入：&quot;); &#125;else &#123; //歌曲存在，且不在第一位，进行前移 linkedList.remove(musicName); linkedList.add(position-1, musicName); System.out.println(&quot;前移一位成功！&quot;); System.out.println(&quot;当前歌曲名单列表：&quot;); Iterator iterator = linkedList.iterator(); while (iterator.hasNext()) &#123; Object object = (Object) iterator.next(); System.out.println(object); &#125; &#125; //判断要至前歌曲是存在 &#125; //模块三 ： 将歌曲置顶 private static void setTop(LinkedList linkedList) &#123; System.out.print(&quot;请输入将要置顶歌曲的名称：&quot;); Scanner scanner = new Scanner(System.in); String topMusicName = scanner.nextLine(); //获得歌曲在列表中的位置 int position ; position = linkedList.indexOf(topMusicName); //判断是否已在第一位 if (position==0) &#123; System.out.println(&quot;该歌曲已在顶部！&quot;); &#125;if (position&lt;0) &#123; System.out.println(&quot;歌名输入有误，不存在该歌曲！&quot;); &#125;else &#123; linkedList.remove(topMusicName); linkedList.addFirst(topMusicName); /* * 此处若为ArrayList 若要置顶元素 * 代码如下： * arraylist.add(0,topMusicName); * * 区别： * ArrayList的add()方法需要指定元素的索引位置来实现 * LinkedList的add()方法一步到位！ * 这也体现出了LinkedList强大的增删功能！ * */ System.out.println(&quot;置顶成功！&quot;); &#125; System.out.println(&quot;修改后的歌单：&quot;); for (Object object : linkedList) &#123; System.out.println(object); &#125; &#125;&#125;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175 运行后效果图： 再来一张： 特别提醒： 1234567891011121314ArrayList和LinkedList在将歌曲置顶方法中，略有区别：ArrayList的add()方法代码： arraylist.add(0,topMusicName);LinkedList的add()代码：linkedList.addFirst(topMusicName);区别：ArrayList的add()方法需要指定元素的索引位置来实现LinkedList的add()方法一步到位！1234567891011121314 总结： 不急不躁，加油吧！]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>eclipse</tag>
        <tag>Linkedlist</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 集合 ArrayList、LinkedList]]></title>
    <url>%2F2017%2F11%2F03%2F03--Java%E9%9B%86%E5%90%88ArrayList%E3%80%81LinkedList%2F</url>
    <content type="text"><![CDATA[今天来总结一下集合，这篇主要总结一下List借口及其相关的实现类。首先看一下集合的框架。 再一张 最后一张性能总结性图： 从上图中可以看到，List接口主要有两个实现类，ArrayList和LinkedList,主要讲一下第一个。 1、ArrayList（1） 关于ArrayList的实现原理，以后通过看源代码来总结。 （2）、 1ArrayList的一些方法，实现增删改查：1 结合代码看： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package com.stormwang.List;import java.util.ArrayList;import java.util.Iterator;import javax.rmi.ssl.SslRMIClientSocketFactory;import javax.swing.plaf.synth.SynthSpinnerUI;/*** @author StormWangxhu* @version 创建时间：2017年11月3日 上午10:03:44**//** * List 是一个借口 * ArrayList是其一个实现类！ * 特点： 查询元素快，增删效率低下！ * 那么，这种缺陷，由LinkedList集合来克服：后面再练习！ * LinkedList特点： * 删除效率高！ * ArrayList 练习 * 实现集合元素的增删改查！ * */public class ListDemo &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub ArrayList arrayList = new ArrayList&lt;&gt;(); //实现集合的增删改查 arrayList.add(&quot;hello!&quot;); arrayList.add(&quot;I am java!&quot;); arrayList.add(&quot;今天是11月3号！，我在图书馆学习！&quot;); arrayList.add(&quot;我也会很牛逼的对吗！&quot;); arrayList.add(3, &quot;我是指定位置插入的元素&quot;); System.out.println(arrayList.size()); System.out.println(&quot;以下是直接输出集合元素：&quot;); System.out.println(arrayList); //遍历集合 System.out.println(&quot;使用迭代器遍历集合：&quot;); Iterator iterator = arrayList.iterator(); while (iterator.hasNext()) &#123; Object object = (Object) iterator.next(); System.out.println(object); &#125; //删 System.out.println(&quot;删操作：&quot;); if (arrayList.get(2).equals(&quot;今天是11月3号！，我在图书馆学习！&quot;)) &#123; arrayList.remove(2); System.out.println(&quot;第三个元素删除成功&quot;); &#125;else &#123; System.out.println(&quot;删除失败！&quot;); &#125; //使用foreach 循环输出集合元素 System.out.println(&quot;使用foreach循环输出集合元素：&quot;); for (Object object : arrayList) &#123; System.out.println(object); &#125; //改 System.out.println(&quot;改操作：&quot;); System.out.println(&quot;现在集合大小为：&quot;+arrayList.size()); arrayList.set(1, &quot;我是新的第二个元素，原来已被我替换！！&quot;); //ArrayList 有序，可重复 arrayList.set(0, arrayList.get(1)); System.out.println(&quot;...&quot;); /** * * 问题：这一部分为什么会执行不了？ 抛出异常！ Iterator iterator2 = arrayList.iterator(); while (iterator.hasNext()) &#123; Object object = (Object) iterator.next(); System.out.println(object); &#125;*/ System.out.println(&quot;现在集合元素为：&quot;); for (Object object : arrayList) &#123; System.out.println(object); &#125; //查操作 //如果没有元素返回真 if (!arrayList.isEmpty()) &#123; System.out.println(arrayList.isEmpty()); &#125; if (arrayList.contains(2)) &#123; System.out.println(&quot;什么鬼！&quot;); &#125;else &#123; System.out.println(&quot;包含操作查询失败！&quot;); &#125; Object object ; System.out.println(&quot;查操作：&quot;); object =arrayList.get(0); System.out.println(&quot;第一个元素为：&quot;+object); //使用toString()方法，将集合元素转换为字符串。 System.out.println(arrayList.toString()); System.out.println(arrayList); &#125;&#125;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101 ArrayList 特点：1、实现：集合底层是使用了一个数组来保存元素的，在增加、删除指定位置元素时，会导致创建新的数组，效率比较低，因此不适用于做大量的增删操作。但这种数据结构，允许程序通过索引的方式来访问元素。因此使用ArrayList集合查找元素很便捷。 2、提供的查找方法： LinkedList1、特点：LinkedList* 该集合内部维护了一个双向循环链表，链表中的每一个元素* 都使用引用的方式记住它的前一个元素和后一个元素，从而* 可以将所有的元素彼此连接起来。 当插入一个新元素时，只需要修改元素之间的这种引用关系即可。 当删除一个节点也是如次。正因为LinkedList的存储结构，Linkedlist集合对元素的增删操作具有很高的效率。 下面通过一组图片看LinkedList的结构： 上图为新增一个元素时：只需要让黄色部分的节点记住它后面是新元素，让黄颜色后面的记住它前面的是新元素。通过代码演示一下该类的特长————增、删操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.stormwang.List;import java.util.Iterator;import java.util.LinkedList;/*** @author StormWangxhu* @version 创建时间：2017年11月3日 下午6:55:57**//** * LinkedList * 该集合内部维护了一个双向循环链表，链表中的每一个元素 * 都使用引用的方式记住它的前一个元素和后一个元素，从而 * 可以将所有的元素彼此连接起来。 * */public class LinkedListTest &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub LinkedList linkedList = new LinkedList&lt;&gt;(); //增操作 System.out.println(&quot;增加元素:&quot;); linkedList.add(&quot;stu1&quot;); linkedList.add(&quot;stu2&quot;); linkedList.add(&quot;stu3&quot;); linkedList.add(&quot;stu4&quot;); System.out.println(linkedList.toString()); //向指定位置插入元素 linkedList.add(2, &quot;指定位置&quot;); Iterator iterator = linkedList.iterator(); while (iterator.hasNext()) &#123; Object object = (Object) iterator.next(); System.out.println(object); &#125; //在最前面插入元素 linkedList.addFirst(&quot;First&quot;); //删除最后一个元素 linkedList.removeLast(); //返回此列表的第一个元素。 System.out.println(linkedList.getFirst()); System.out.println(linkedList); //删除指定元素 linkedList.remove(3); System.out.println(linkedList); //删除最后一个元素 linkedList.removeLast(); System.out.println(linkedList); //删除第一个元素 linkedList.removeFirst(); System.out.println(linkedList); &#125;&#125;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 LinkedList在增删方面有7个特有的方法。看看：增 删 具体可以查看API 下面看看ArrayList和LinkedList的区别： 123456789101112131415总结：ArrayList: 有序 可重复 查找效率高，大批量增加、删除操作慢。 线程不安全LinkedList 有序 可重复 增删效率高！ 查找效率不好。 线程安全]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Arraylist</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 集合遍历Iterator/foreach]]></title>
    <url>%2F2017%2F11%2F03%2Fforeach%2F</url>
    <content type="text"><![CDATA[常用遍历集合元素方式两种：1、Iterator接口2、foreach循环 Iterator接口程序开发中经常需要遍历集合元素，Java jdk 专门提供一接口iterator. 与Collection、Map接口主要用于存储元素不同，iterator接口主要用于迭代访问（即遍历）Collection中的元素。因此iterator也被称为迭代器。 案例： 123456789101112131415161718192021222324252627282930313233package com.stormwang.cycle;import java.util.ArrayList;import java.util.Iterator;/*** @author StormWangxhu* @version 创建时间：2017年11月3日 下午9:12:42**//** * 练习使用迭代器 遍历集合元素 * */public class IteratorDemo &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub ArrayList arrayList = new ArrayList&lt;&gt;(); arrayList.add(&quot;day_1&quot;); arrayList.add(&quot;day_2&quot;); arrayList.add(&quot;day_3&quot;); arrayList.add(&quot;day_4&quot;); Iterator iterator =arrayList.iterator();//获取Iterator对象 while (iterator.hasNext()) &#123; //判断ArrayList中是否存在下一个元素 Object object = (Object) iterator.next(); //取出ArrayList集合中的元素 System.out.println(object); &#125; &#125;&#125;123456789101112131415161718192021222324252627282930313233 解释代码遍历过程如下：1、首先调用ArrayList集合的iterator()方法获得迭代器对象。2、然后 hasNext()方法判断集合中是否有下一个元素。3、若存在; 则next()方法获取元素。否则： 说明已到达了集合末尾，停止遍历元素。注意：next()方法获取元素时，必须保证获取元素的存在，否则，回抛出NoSuchElementException . 需要特别说明的是： 当通过迭代器获取ArrayList集合元素时，都会将这些元素当做Object类型看待，如果要得到特定类型的元素。需要进行强制类型转换。 iterator迭代器对象在遍历集合时，内部采用指针方式来跟踪集合中的元素。hasNext()方法返回false时，终止迭代器。 迭代器注意：在集合进行迭代过程中，不允许出现迭代器以外的对象操作。比如： 1234567891011121314151617181920212223242526272829303132333435package com.stormwang.cycle;import java.util.ArrayList;import java.util.Iterator;/*** @author StormWangxhu* @version 创建时间：2017年11月3日 下午9:12:42**//** * 练习使用迭代器 遍历集合元素 * */public class IteratorDemo &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub ArrayList arrayList = new ArrayList&lt;&gt;(); arrayList.add(&quot;day_1&quot;); arrayList.add(&quot;day_2&quot;); arrayList.add(&quot;day_3&quot;); arrayList.add(&quot;day_4&quot;); Iterator iterator =arrayList.iterator();//获取Iterator对象 while (iterator.hasNext()) &#123; //判断ArrayList中是否存在下一个元素 Object object = (Object) iterator.next(); //取出ArrayList集合中的元素 System.out.println(object); arrayList.add(&quot;Java&quot;); //出现迭代器以外的对象操作元素 &#125; &#125;&#125;1234567891011121314151617181920212223242526272829303132333435 我们看一下结果： 因为在迭代过程中。出现了迭代器以外的对象操作元素。会抛出java.util.ConcurrentModificationException异常。 12所以：Iterator在迭代是，只能对元素进行获取（next()）和删除（remove()）操作。12 1下面来说说foreach循环：1 虽然Iterator可以用来遍历集合元素，但写法上比价繁琐，为了简化书写，jdk5。0开始提供了foreach循环。foreach循环是一种更加简洁的for循环，也称为增强for循环。 foreach循环用途：用于遍历 : 数组 或 集合 语法格式：for(容器中元素类型 临时变量 ： 容器变量 ){执行语句；} 与for循环区别：不需要获取容器的长度不需要根据索引访问容器中的元素，但会自动遍历容器中的每一个元素。没有循环条件没有迭代语句 先来看看用foreach循环编辑集合： 123456789101112131415161718192021222324252627package com.stormwang.cycle;import java.util.LinkedList;/*** @author StormWangxhu* @version 创建时间：2017年11月3日 下午9:17:34**/public class ForEachDemo &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub LinkedList linkedList = new LinkedList&lt;&gt;(); //增操作 System.out.println(&quot;增加元素:&quot;); linkedList.add(&quot;stu1&quot;); linkedList.add(&quot;stu2&quot;); linkedList.add(&quot;stu3&quot;); linkedList.add(&quot;stu4&quot;); for (Object object : linkedList) &#123; System.out.println(object); &#125; &#125;&#125;123456789101112131415161718192021222324252627 结果： 再来看看利用简单的 for循环遍历集合： 1234567891011121314151617181920212223242526272829303132333435package com.stormwang.cycle;import java.util.LinkedList;/*** @author StormWangxhu* @version 创建时间：2017年11月3日 下午9:17:34**/public class ForEachDemo &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub LinkedList linkedList = new LinkedList&lt;&gt;(); //增操作 System.out.println(&quot;增加元素:&quot;); linkedList.add(&quot;stu1&quot;); linkedList.add(&quot;stu2&quot;); linkedList.add(&quot;stu3&quot;); linkedList.add(&quot;stu4&quot;); /* for (Object object : linkedList) &#123; System.out.println(object); &#125;*/ int length ; length= linkedList.size(); System.out.println(length); for(int i =0;i&lt;length;i++) &#123; System.out.println(linkedList.get(i)); &#125; &#125;&#125;1234567891011121314151617181920212223242526272829303132333435 运行结果： 可以看到，运行结果一样，但是foreach循环操作更简单。 foreach遍历集合的局限性方便的同时，有其局限性：在遍历数组或者集合时，只能访问集合里元素，不能对其进行修改。接下来以一个String 类型的数组为例进行演示： 12345678910111213141516171819202122232425262728package com.stormwang.cycle;/*** @author StormWangxhu* @version 创建时间：2017年11月3日 下午11:44:55**//** * foreach循环局限性演示： * 不能修改元素 * */public class SpecialForeach &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub String[] str = &#123;&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;&#125;; for (String string : str) &#123; string = &quot;ddd&quot;; &#125; System.out.println(&quot;foreach循环修改后的数组&quot;+str[0]+&quot;, &quot;+str[1]+&quot;, &quot;+str[2]); //for循环遍历叔祖 for (int i = 0; i &lt; str.length; i++) &#123; str[i] = &quot;ddd&quot;; &#125; System.out.println(&quot;for循环修改后的数组&quot;+str[0]+&quot;, &quot;+str[1]+&quot;, &quot;+str[2]); &#125;&#125;12345678910111213141516171819202122232425262728 看一下结果： foreach循环没有改变数组元素，for循环改变。 解释： 这段代码只是将临时变量str指向了一个新的字符串，对数组元素没有任何影响。 而for循环，可以通过索引的方式来引用数组中的元素并将其修改。 Iterator遍历集合元素得坑（局限性）！首先给出结论： 12结论： 在Iterator迭代器对集合元素遍历时，不允许其他对象引用自身的 remove（）方法进行删除！若想删除，须用迭代器自身的remove（）方法。否则会抛出异常。12 用代码来演示一下： 1234567891011121314151617181920212223242526272829303132333435363738394041package com.stormwang.cycle;import java.util.ArrayList;import java.util.Iterator;/*** @author StormWangxhu* @version 创建时间：2017年11月3日 下午11:59:17**//** * 迭代器Iterator在遍历过程中remove（）操作 * * */public class SpecialIterator &#123; public static void main(String[] args) &#123; ArrayList arrayList = new ArrayList&lt;&gt;(); //实现集合的增删改查 arrayList.add(&quot;hello!&quot;); arrayList.add(&quot;I am java!&quot;); arrayList.add(&quot;今天是11月3号！，我在图书馆学习！&quot;); arrayList.add(&quot;我也会很牛逼的对吗！&quot;); arrayList.add(3, &quot;我是指定位置插入的元素&quot;); //现在进行迭代 Iterator iterator =arrayList.iterator(); while (iterator.hasNext()) &#123; Object object = (Object) iterator.next(); if ((&quot;hello!&quot;).equals(object)) &#123; //注意： 使用arraylist对象的remove（）方法 arrayList.remove(object); &#125; &#125; System.out.println(arrayList); &#125;&#125;1234567891011121314151617181920212223242526272829303132333435363738394041 看看运行一下： 抛出了异常！！！！这个异常是迭代器对象抛出的。 原因：集合中删除了的元素，会导致迭代器预期的迭代次数发生改变，导致迭代器结果不准确！ 那么有什么措施吗？就不能删除了是吧！ 不不不，有的！ 措施：1、从业务逻辑上分析，只想将一个元素删除，至于后面的元素不去管他们，则删除该元素后，我们跳出循环，即 break ; 。 123456789101112131415161718192021222324252627282930313233343536373839404142package com.stormwang.cycle;import java.util.ArrayList;import java.util.Iterator;/*** @author StormWangxhu* @version 创建时间：2017年11月3日 下午11:59:17**//** * 迭代器Iterator在遍历过程中remove（）操作 * * */public class SpecialIterator &#123; public static void main(String[] args) &#123; ArrayList arrayList = new ArrayList&lt;&gt;(); //实现集合的增删改查 arrayList.add(&quot;hello!&quot;); arrayList.add(&quot;I am java!&quot;); arrayList.add(&quot;今天是11月3号！，我在图书馆学习！&quot;); arrayList.add(&quot;我也会很牛逼的对吗！&quot;); arrayList.add(3, &quot;我是指定位置插入的元素&quot;); //现在进行迭代 Iterator iterator =arrayList.iterator(); while (iterator.hasNext()) &#123; Object object = (Object) iterator.next(); if ((&quot;hello!&quot;).equals(object)) &#123; //注意： 使用arraylist对象的remove（）方法 arrayList.remove(object); break; &#125; &#125; System.out.println(arrayList); &#125;&#125;123456789101112131415161718192021222324252627282930313233343536373839404142 运行后： 2、若需要在集合的迭代期间对集合的元素进行删除，可使用迭代器自身的删除方法。 即 iterator.remove()。 看一下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041package com.stormwang.cycle;import java.util.ArrayList;import java.util.Iterator;/*** @author StormWangxhu* @version 创建时间：2017年11月3日 下午11:59:17**//** * 迭代器Iterator在遍历过程中remove（）操作 * * */public class SpecialIterator &#123; public static void main(String[] args) &#123; ArrayList arrayList = new ArrayList&lt;&gt;(); //实现集合的增删改查 arrayList.add(&quot;hello!&quot;); arrayList.add(&quot;I am java!&quot;); arrayList.add(&quot;今天是11月3号！，我在图书馆学习！&quot;); arrayList.add(&quot;我也会很牛逼的对吗！&quot;); arrayList.add(3, &quot;我是指定位置插入的元素&quot;); //现在进行迭代 Iterator iterator =arrayList.iterator(); while (iterator.hasNext()) &#123; Object object = (Object) iterator.next(); if ((&quot;hello!&quot;).equals(object)) &#123; //注意： 使用arraylist对象的remove（）方法 iterator.remove(); &#125; &#125; System.out.println(arrayList); &#125;&#125;1234567891011121314151617181920212223242526272829303132333435363738394041 再来看看运行： 这次在迭代器迭代期间删除成功！ 再次申明一下结论： 12345结论： 调用迭代器对象的remove()方法删除元素，所导致的迭代次数变化，对于迭代器对象本身而言是可以预知的！只有儿子是亲的，才会让进门！ 啊哈哈哈哈！123456]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>eclipse</tag>
        <tag>遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java IO 流（三）]]></title>
    <url>%2F2017%2F11%2F02%2FJava%20IO%E6%B5%81%EF%BC%88%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[今天再写一点关于Java I/O中的一些概念的讲解！ 1、1、流的分类1、输入流和输出流 划分依据：划分输入流和输出流是以程序运行所在的内存角度划分。 举例：-1、内存——（数据）————&gt;硬盘 输出流-2、Server——（数据）————&gt;ClientServer端内存： 负责将数据输出到网络上 &gt;&gt;&gt;输出流 2、流的概念模型 inputStream和 Reader: 所有输入流的基类，前者字节输入流，后者字符输入流。 OutputStream和Writer: 所有输出流的基类，前者字节输出流，后者字符输出流。 （1）、输入流概念模型 1、把输入设备抽象成一个“水管”，这个水管里的每个“水滴”依次排列。而一个水滴就相当于一个数据单元字节/字符。 说明：（1）、字节流和字符流处理方式都及其相似（2）、输入流使用隐式记录指针：当前正准备从哪个“水滴”开始读取。输入流inputStream和Reader提供一些方法控制记录指针的移动。 （2） 输出流和输入流也同样相似：- 1、2、装饰器设计模式 概念： 将节点流通过包装成为处理流或称为包装流处理。 使用处理流典型思路：使用处理流包装节点流，程序通过处理流来执行输入/输出功能，让节点流与底层的I/O设备、文件交互。如上图所示，将节点流包装为处理流，提供缓冲技术。增加缓冲功能后，可以提高输入输出效率，需要使用flush()方法才可以将缓冲区的内容刷出。 小思考 我觉得之所以处理流会效率比较高，一方面的原因是因为：BufferedReader还是BufferedWriter在循环读取时用到了readLine()方法，而readLine方法是一个利用read（）方法包装了一个字符数组的方法。将读取到的内容存到数组中提供缓冲功能。readline()方法，可以一次读取一行文本，以换行符为标志；如果没有读到换行符，则线程阻塞，直至读到换行符为止！ 换行符表示：Windows: \r\nUNIX/linux : \n 1、3、计算机文件分类一般来说，计算文件常分为两大类，一个是文本文件，另一个是二进制文件。 文本文件：所有能用记事本打开并看到其中字符内容的文件。 二进制文件：反之。 关系：实际上，文本文件是特殊的二进制文件，当二进制文件里的内容能被正常解析成字符时，就变成了二进制文件。 1、字节流： 可以处理所有的二进制文件。2、字符流：只能处理文本文件。 1、4、转换流两个转换流： InputStreamReader ：字节输入流————&gt;字符输入流 OutputStraemWriter：字节输出流————&gt;字符输出流 功能：只能将 字节流————&gt;字符流， 反之不可以！！！ 那么问题来了，为什么只能将字节流转换为字符流，而不能将字符流转换为字节流呢？思考一下。。。。？ 1回答：字节流和字符流的差别就是操作的数据单元不同。字节流比字符流使用范围更广，但字符流比字节流操作更方便。如果有一个流已经是字符流了，也就说，是用一个用起来比较方便的流，为什么要转换为字节流呢？！反之，若有一个字节流，可以确定这个字节流的内容都是文本内容，那么把它转换为字符流处理就会更方便一些。所以Java只提供了字节流——————&gt;&gt;字符流。1 1、5推回输入流PushBackInputStream和PushBackReader1先来看看API1 这里只看三个方法，并介绍一个重要的概念：推回缓冲区。我觉得他对理解Java I/O流应该有帮助。 我们会发现这三个方法与InputStream和Reader中的三个read(）方法一一对应。这两个推回输入流都有一个推回缓冲区，当程序调用这两个推回输入流的unread()方法时，系统将会把指定数组的内容推回到该缓冲区里，而推回输入流每次调用read()方法总是先从推回缓冲器区读取，只有完全读取了推回缓冲区的内容后，但还没有装满read(0所需的数组时才会从原输入流中读取。 推回缓冲区默认长度为 1 。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>I/O</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java IO流总结（二）]]></title>
    <url>%2F2017%2F11%2F01%2F10--Java-IO%E6%B5%81%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[面对压力，我可以挑灯夜战，不眠不休。面对挑战，我愿意迎难而上，永不退缩! 昨天我们总结了字符的输入流，主要进行读写的功能。今天来看一下字节流InputStream和OutputStream. 字节流基本框架体系图整体体系：InputStream: 基本概念1和字符流一样，字节流也有两个抽象基类作为其他类的父类。一个是InputStream,一个是OutPutStream.其他的类都是这两个类的拓展类。1 (1)特点：字节流可以操作任何数据。(2)注意：字节流使用的是字节数组 byte[]字符流使用得是字符数组 char[] inputStream(1)、inputStream是所有字节输入流的父类，是一个抽象类。(2)ByteArrayInputStream、StringBufferInputStream、FileInputStream 是三种基本的介质流，它们分别从Byte 数组、StringBuffer、和本地文件中读取数据。(3)ObjectInputStream 和所有FilterInputStream 的子类都是装饰流（装饰器模式的主角）。 outputStream(1)、OutputStream 是所有的输出字节流的父类，它是一个抽象类。（2）、ByteArrayOutputStream、FileOutputStream 是两种基本的介质流，它们分别向Byte 数组、和本地文件中写入数据。PipedOutputStream 是向与其它线程共用的管道中写入数据。（3）、ObjectOutputStream 和所有FilterOutputStream 的子类都是装饰流。 其他 （1）、LineNumberInputStream 主要完成从流中读取数据时，会得到相应的行号，至于什么时候分行、在哪里分行是由改类主动确定的，并不是在原始中有这样一个行号。在输出部分没有对应的部 分，我们完全可以自己建立一个LineNumberOutputStream，在最初写入时会有一个基准的行号，以后每次遇到换行时会在下一行添加一个行 号，看起来也是可以的。好像更不入流了。（2）、PushbackInputStream 的功能是查看最后一个字节，不满意就放入缓冲区。主要用在编译器的语法、词法分析部分。输出部分的BufferedOutputStream 几乎实现相近的功能。StringBufferInputStream 已经被Deprecated，本身就不应该出现在InputStream 部分，主要因为String 应该属于字符流的范围。已经被废弃了，当然输出部分也没有必要需要它了！还允许它存在只是为了保持版本的向下兼容而已。（3）、SequenceInputStream 可以认为是一个工具类，将两个或者多个输入流当成一个输入流依次读取。完全可以从IO 包中去除，还完全不影响IO 包的结构，却让其更“纯洁”――纯洁的Decorator 模式。（4）、PrintStream 也可以认为是一个辅助工具。主要可以向其他输出流，或者FileInputStream 写入数据，本身内部实现还是带缓冲的。本质上是对其它流的综合运用的一个工具而已。一样可以踢出IO 包！System.out 和System.out 就是PrintStream 的实例！ 12下面我们通过案例来分别讲解一下这些字节流的使用。首先讲解一下FileInputStream:12 案例一：利用字节流读取或写入文本内容到控制台或者文本文件中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package com.StormWang.InputStream;import java.io.FileInputStream;import java.io.FileWriter;import java.io.IOException;/*** @author StormWangxhu* @version 创建时间：2017年11月1日 上午11:19:03**/ class FileInStream&#123; //读文件，一个一个的读，读一个存一个 public static void readFile_1()&#123; //先写一个文件 FileWriter fileWriter = null ; FileInputStream fileInputStream = null ; try &#123; fileWriter = new FileWriter(&quot;input.txt&quot;); fileWriter.write(&quot;FileInputStream,success.&quot;); fileWriter.flush(); fileInputStream = new FileInputStream(&quot;input.txt&quot;); int ch = 0 ; while ((ch= fileInputStream.read())!=-1) &#123; System.out.print((char)ch); &#125; &#125; catch (Exception e) &#123; // TODO: handle exception e.printStackTrace(); &#125;finally &#123; if (fileInputStream != null) &#123; try &#123; fileInputStream.close(); &#125; catch (Exception e2) &#123; // TODO: handle exception e2.printStackTrace(); &#125; &#125; if (fileWriter != null) &#123; try &#123; fileWriter.close(); &#125; catch (Exception e2) &#123; // TODO: handle exception e2.printStackTrace(); &#125; &#125; &#125; &#125; /* //读方法二(读完之后，一起存起来。) public static void readFile_2() &#123; FileInputStream fileInputStream = null ; try &#123; fileInputStream = new FileInputStream(&quot;E:\\eclipse-workspace\\day1101\\input.txt&quot;); byte[] buf = new byte[1024]; int len = 0 ; while ((len = fileInputStream.read()) != -1) &#123; System.out.println(&quot;len是：&quot;+len); //System.out.print(new String(buf,0,len)); System.out.println(buf); &#125; System.out.println(&quot;buf数组内容：&quot;+buf); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if (fileInputStream != null) &#123; try &#123; fileInputStream.close(); &#125; catch (Exception e2) &#123; // TODO: handle exception System.out.println(&quot;close:&quot;+e2.toString()); &#125; &#125; &#125; &#125;*/ &#125;public class FileInputStreamDemo &#123; public static void main(String[] args) &#123; FileInStream fileInStream = new FileInStream() ; fileInStream.readFile_1(); &#125;&#125;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788 我们来看一下结果： 再来看一个实例：实现对一个图片文件的复制案例二： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.StormWang.InputStream;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;/*** @author StormWangxhu* @version 创建时间：2017年11月1日 下午4:53:32**/public class CopyPicture &#123; /* * 实现功能: 实现图片文件的复制 * 思路： * 1、字节输入流和图片文件相关联 * 2、再用字节输入流将图片文件数据写入到缓冲区中，即字节数组中 * 3、通过循环读写，完成数据的存储 * 4、关闭流资源。 * */ public static void main(String[] args) &#123; // TODO Auto-generated method stub FileInputStream fileInputStream = null; FileOutputStream fileOutputStream =null ; try &#123; fileInputStream = new FileInputStream(&quot;F:\\2016\\1.jpg&quot;); //测试代码 System.out.println(&quot;已过！&quot;); fileOutputStream = new FileOutputStream(&quot;F:\\2.JPG&quot;); byte[] buff = new byte[1024]; int ch = 0 ; //此处的read()方法可能会抛出IOException异常，我们catch一下。 while ((ch= fileInputStream.read(buff)) !=-1) &#123; /* *write方法说明： *write(byte[] b, int off, int len) * 将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此文件输出流。 * * */ fileOutputStream.write(buff, 0, ch); &#125; &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally &#123; if (fileInputStream != null) &#123; try &#123; fileInputStream.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; if (fileOutputStream != null) &#123; try &#123; fileOutputStream.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 1问题：在输入流和图片文件关联时，系统找不到指定文件。1 12F盘文件如下所示，不知道为什么会找不到文件呢？待解决：。。。。。。。12 自定义缓冲字节流123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.StormWang.InputStream;/*** @author StormWangxhu* @version 创建时间：2017年11月1日 下午6:44:40**/import java.io.IOException;import java.io.InputStream;public class MyBuffereedInputStream &#123; private InputStream iStream ; private byte[] buff = new byte[1024]; private int pos = 0,count = 0 ; public MyBuffereedInputStream(InputStream iStream) &#123; // TODO Auto-generated constructor stub this.iStream = iStream ; &#125; public int myRead() throws IOException&#123; //通过iStream读取硬盘中的数据，存储到buff //如果count=0,说明byte数组是空的，所以开始读取数据 if (count == 0) &#123; count = iStream.read(buff); //标记位 pos = 0; //通过下标找到数组 byte bt = buff[pos]; //byte数组个数递减 count--; //移动标记位 pos++; return bt&amp;255; &#125; //如果字节数组中还有数据，则继续往出取 else if (count&gt;0) &#123; byte bt = buff[pos]; count--; pos++; return bt &amp; 255 ; &#125; return -1 ; &#125; //关闭流方法 public void myClose() &#123; try &#123; iStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 这样就完成了自定义字节流的定义。下面我们来应用一下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.StormWang.InputStream;import java.io.BufferedOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;/*** @author StormWangxhu* @version 创建时间：2017年11月1日 下午7:08:36**/public class myBufferedInputStreamTest &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub FileInputStream fInStream = null; MyBuffereedInputStream myBuffereedInputStream = null ; BufferedOutputStream bufferedOutputStream = null; try &#123; fInStream = new FileInputStream(&quot;E:\\eclipse-workspace\\day1101\\src\\com\\StormWang\\InputStream\\CopyPicture.java&quot;); myBuffereedInputStream = new MyBuffereedInputStream(fInStream); bufferedOutputStream = new BufferedOutputStream(new FileOutputStream(&quot;myBuff.txt&quot;)); int ch = 0; while ((ch=myBuffereedInputStream.myRead())!= -1) &#123; bufferedOutputStream.write(ch); &#125; &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally &#123; if (myBuffereedInputStream!= null) &#123; myBuffereedInputStream.myClose(); &#125; if (bufferedOutputStream != null) &#123; try &#123; bufferedOutputStream.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; if (fInStream != null) &#123; try &#123; fInStream.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 我们来看一下结果：读写成功！ 12345678（待回头再思考。。。。。。）**注意：**字节流的read()方法读取一个字节。为什么返回的不是byte类型的，而是int 类型的呢？因为read方法读到末尾时返回的是-1.而在所操作的数据中的很容易出现连续多个1的情况，而连续读到8个1，就是-1.导致读取会提前停止。所以将读到的一个字节给提升为一个int类型的数值，但是只保留原字节，并在剩余二进制位补0.具体操作是：byte&amp;255 or byte&amp;0xff 对于write方法，可以一次写入一个字节，但接收的是一个int类型数值。只写入该int类型的数值的最低一个字节（8位）。即对于write()方法实际上进行了强制转化的动作。简单说:read方法对读到的数据进行提升。write对操作的数据进行转换。**12345678 转换流 特点：1，是字节流和字符流之间的桥梁。2，该流对象中可以对读取到的字节数据进行指定编码表的编码转换。 什么时候使用呢?1，当字节和字符之间有转换动作时。2，流操作的数据需要进行编码表的指定时。具体的对象体现：这两个流对象是字符流体系中的成员。1，InputStreamReader：字节到字符的桥梁。2，OutputStreamWriter：字符到字节的桥梁。这两个流对象是字符流体系中的成员。那么它们有转换作用，而本身又是字符流。所以在构造的时候，需要传入字节流对象进来。构造函数：InputStreamReader(InputStream):通过该构造函数初始化，使用的是本系统默认的编码表GBK。InputStreamReader(InputStream,StringcharSet):通过该构造函数初始化，可以指定编码表。OutputStreamWriter(OutputStream):通过该构造函数初始化，使用的是本系统默认的编码表GBK。OutputStreamWriter(OutputStream,StringcharSet):通过该构造函数初始化，可以指定编码表。 1我们来看看API是怎么解释的：1 我们通过代码来演示一下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586小技巧：1. * 源：键盘录入 * 目的：控制台 * @author StormWangxhu * 2.改变需求：想把键盘录入的数据存储到一个文件中 * 源：键盘 * 目的：文件 * * 3.改变需求：想要将一个文件数据打印到控制台上 * 源：文件 * 目的：控制台 * * ######################流操作的基本规律：############## * 最痛苦的就是流对象有很多，不知道该用哪一个？ * 通过三个明确来完成： * 1.明确源和目的 * 源：输入流. InputStream Reader * 目的：输出流. OutputStream Writer * 2.明确操作的数据是否是是纯文本 * 是纯文本：用字符流 * 不是纯文本：用字节流 * 3.当体系明确后，再明确要使用哪个具体的对象 * 通过设备来进行区分： * 源设备：内存、硬盘、键盘 * 目的设备：内存、硬盘（文件）、控制台 * ----------------------3个需求之一----------------------- * 1.将一个文本文件中的数据存储到另一个文件中 ，也就是复制文件 * 源：因为是源，所以使用读取流：InputStream Reader * a.是不是操作文本文件？ * 是：这就可以选择Reader * 不是：可以选择InputStream * 这样下来，所属体系就明确了。 * * b.接下来就要明确要使用体系中的哪个对象？ * 明确设备：硬盘上的一个文件 * Reader体系中可以操作文件的对象是FileReader * c.是否需要提高效率？ * 需要：加入Reader体系的缓区:BufferedReader * * 接下来就是： * 1) FileReader fr =new FileReader(&quot;a.txt&quot;); 2) BufferedReader br = new BufferedReader(fr); * 目的：文件 OutputStream Writer * a.目的是否是纯文本的？ * 是：Writer * 不是：OutputStream * b.明确设备：硬盘上的一个文件 * Writer体系中可以操作一个文件的对象是FileWriter * * c.是否需要提高效率？ * 需要：加入Writer体系的缓冲区:BufferedWriter * * 接下来就是： * 1) FileWriter fw = new FileWriter(&quot;b.txt&quot;); 2) BufferedWriter bw = new BufferedWriter(fw); * * 练习： 将一个图片文件中的数据存储到另一个图片中 ，即为copy图片，要按照以上的格式去写 * 源（是图片）：因为是源， 所以使用读取流：InputStream Reader * a.是不是操作的纯文本文件？ * 不是：这就可以选择InputStream * 是：这就可以选择 Reader * b.接下来就要明确要使用体系中的哪个对象？ * 明确设备：硬盘上的一个图片 * InputStream体系中可以操作图片的对象时FileInputStream * c.是否需要提高效率？ * * 需要：加入InputStream体系的缓冲区:BufferedInputStream * * 接下来就是： * FileInputStream fis = new FileInputStream(&quot;1.jpg&quot;); BufferedInputStream bis = new BufferedInputStream(fis); * 目的：文件 OutputStream Writer * a.是否是纯文本的文件？ * 不是：OutputStream * 是：writer * b.明确设备：硬盘上的一个图片 * * OutputStream体系中可以操作一个文件的对FileOutputStream * c.是否需要提高效率？ * * 需要：加入OutputStream体系的缓冲区:BufferedOutputStream * FileOutputStream fos = new FileOutputStream(&quot;2.jpg&quot;); * * BufferedOutputStream bos = BufferedOutputStream(fos); * 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586 1我们来实现一个功能，把一个 文件的内容 输出到 控制台 上1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package com.StormWang.InputStream;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.FileWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;/*** @author StormWangxhu* @version 创建时间：2017年11月1日 下午8:04:29**//* * 实现将一个文件中的内容输出到控制台上 * */public class FileStreamDemo_2 &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub //创建读取和写入对象 BufferedReader bReader = null ; BufferedWriter bWriter = null ; try &#123; /** * FileinputStream fs = new FileInutStream(&quot;E:\\eclipse-workspace\\day1101\\myBuff.txt&quot;); * InputStreamReader isr = new InputStreamReader(fs); * BufferedReader br = new BufferedReader(isr); * 以上三句合并为一句如下： */ bReader = new BufferedReader( new InputStreamReader(//将字节流转换为字符流。 new FileInputStream(&quot;E:\\eclipse-workspace\\day1101\\myBuff.txt&quot;))); bWriter = new BufferedWriter( //将字符流转化为字节流 //并输出到控制台上 new OutputStreamWriter(System.out)); //循环读取 String lines = null ; /** * readLine()方法的原理： * 其实缓冲区中的readLine()方法，用的还是与缓冲区关联的流对象的read()方法 。 * 只不过，每一次读到一个字符，先不进行具体的操作，先进行临时存储。 * 当读到回车标记时，将临时容器中存储的数据一次性的返回。 * * */ while ((lines = bReader.readLine())!= null) &#123; //读一行，写一行，把每一行都写到输出流中 bWriter.write(lines); //写一行后换一行 //newLine()方法为跨平台换行。。 bWriter.newLine(); //写一行刷新一行 bWriter.flush(); &#125; &#125; catch (FileNotFoundException e) &#123; System.out.println(&quot;找不到文件了！&quot;); e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally &#123; if (bReader!= null) &#123; try &#123; bReader.close(); &#125;catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; if (bWriter!= null) &#123; try &#123; bWriter.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125; &#125;&#125;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687 看一下结果：输出成功！ 好了，就先总结到这儿吧。如有错误，还望指正！]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>I/O</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java I/O流总结（一）]]></title>
    <url>%2F2017%2F10%2F31%2FJava%20IO%E6%B5%81%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[面对压力，我可以挑灯夜战，不眠不休。面对挑战，我愿意迎难而上，永不退缩！在学习的这段时间里，基础知识学了很久，但却总是记不住。在前两天，自己找了一个qq项目，在这个小项目中，关于读写数据应用很频繁。也就是I/O流的应用。今天想进行一下流的总结。 在Java中，输入和输出多以流的方式进行，他的特点是数据的发送和获取都是沿数据序列进行的，每个数据必须等待它前面的数据发送或读入后才能被读写。数据在两设备间的传输称为流，流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。 – 流的分类 根据输入输出的数据类型可分为： 字节流、字符流 根据流的流向可分为： 输入流、输出流 根据角色来分：节点流和处理流 字符流和字节流1、读写单位不同：字节流操作的数据单元一次读取或写入8位。字符流以字符为单位，操作的数据单元是16位的字符，根据码表映射字符。2、处理对象不同：字节流能够处理所有的对象，而字符流只能处理字符。3、字节流主要InputStream和OutputStream作为基类，而字符流主要由Reader和Writer作为基类 输入流和输出流输入流： 只能从中读取数据，不能写入数据。输出流： 只能从中写入数据，不能读取数据。 注意：此处的输入、输出涉及一个方向问题，要更具具体的问题需求确定输入和输出流的方向问题。节点流（低级流）和处理流（包装流）1、节点流： 可以从一个特定的IO设备（如磁盘、网络）读、写数据的流，称为节点流。节点流也被称为低级流（Low Level Stream）。 特点： 程序直接连接到实际的数据源。 2、处理流：对一个已存在的节点流进行连接或封装，通过封装后的流试现数据读写功能。处理流也被称为高级流。 （1）特点：实际上，Java使用处理流来包装节点流，是一种典型的装饰设计模式，通过使用处理流来包装不同的节点流，既可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入/输出功能。因此，处理流也被称为包装流。处理流可以“嫁接”到任何已存在的流的基础之上。通过使用处理流，Java程序无须理会输入/输出设备，程序只要将节点流包装成处理流，就可以用形同的输入/输出操作代码来完成不同的输入/输出设备的数据。 （2）处理流的功能主要体现在以下两个方面：—–性能的提高： 主要以增加缓冲的方式来提高输入输出的效率。—–操作的便捷： 处理流可以提供一系列便捷的方法来一次输入/输出大批量的内容，而不是输入/输出一个或多个“水滴”。 1I/O流的基本概念就先介绍到这里，下面来一起看看IO流的体系框架。 InputSream和ReaderinputStream和Reader是所有输入流的抽象基类，本身并不能创建实例来执行输入，但他们将成为所有输入流的模板，所以他们的以下方法是所有输入流都可以使用的方法。 在inputStream里包含得方法：（1）、int read()：从输入流中读取单个字节（相当于从水管 中读取一个水滴），返回所读取的字节数据。（2）、int read(byte[] b):从输入流中最多读取b.length个字节的数据，并将其存放在字节数组b中，返回实际读取的字节数。（3）int read(byte[] , int off ,int len ):从输入流中最多读取len个字节的数据，并将其存放在字节数据组b中。比不是从数组起点开始，而是从off位置开始，返回实际读取的字节数。 Reader(1)、int read()(2)、int read(char[] cbuf )从输入流中最多读取cbuf.length长度个字符数据，并将其存放在char数组中。返回实际读取的字符数。（3）、int read(char[] , int off ,int len ) Writer OutputStream上述两个基本流我们将在第（二）篇中讲述。 12345678910不难发现，inputStream和Reader两个基类的功能基本一样。但他们都有一个用于读取文件的输入流：FileInputStreamFileReader 下面我们通过程序是来示由Reader和Writer衍生出来的FileReaderFileWriter及其：BufferedReaderBufferedWriter的读取功能： 123456789101112131415161718192021222324252627282930313233343536373839package com.stormwang.fileinputstream;import java.io.File;import java.io.FileNotFoundException;import java.io.FileWriter;import java.io.IOException;/*** @author StormWangxhu* @version 创建时间：2017年10月31日 下午4:36:55**//*创建文件，通过流实现数据的写入*/public class FileWriterDemo &#123; public static void main(String[] args) &#123; //读取文件中的内容，首先我们来创建一个文件 File file = new File(&quot;wang.txt&quot;); FileWriter fileWriter = null ; try &#123; fileWriter = new FileWriter(file); fileWriter.write(&quot;abcdefg&quot;); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125;finally &#123; if (fileWriter != null) &#123; try &#123; fileWriter.close(); &#125; catch (Exception e2) &#123; e2.printStackTrace(); &#125; &#125; &#125;&#125; 1我们会看到，文件创建并写入成功！结果如下所示： 接下来我们就来读取文件里的内容！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.stormwang.fileinputstream;import java.io.File;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;/*** @author StormWangxhu* @version 创建时间：2017年10月31日 下午5:05:24**/public class FileReaderDemo &#123; public static void main(String[] args) &#123; FileReader fileReader= null ; /* * 关于流： * 我们发现，流在try外面申明，在try里面初始化，在finally中关闭。 * */ try &#123; fileReader = new FileReader(&quot;wang.txt&quot;); char[] buf = new char[1024]; int hasRead = 0 ; /* * * 循环读取 while ((hasRead = fileReader.read(buf))&gt;0) &#123; fileReader.read(buf); &#125;*/ hasRead = fileReader.read(buf);//将输入流中的数据读取到char数组中。 System.out.println(&quot;读取字符数为：&quot;+hasRead); System.out.println(&quot;读取字符数如下：&quot;+new String(buf)); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; /* * 在finally中关闭流时，要在try...catch中 错误关闭流资源方法： finally&#123; if(fileReader != null )&#123; fileReader.close(); &#125; &#125; 为什么这种方法是错误的呢？ 理由如下： 待补！ */ if (fileReader!=null) &#123; try &#123; //关闭流之前会自动刷新 fileReader.close(); &#125; catch (Exception e2) &#123; e2.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 我们看到，读取成功了。但是很明显，由于上面的操作是流直接从数据源或目的地进行操作，效率不高。对应的缓冲技术的出现大大减少了流和数据源之间的直接操作。通过API查看，可知BuffererReader装饰了Reader.从而演变出了装饰设计模式，这种模式很好的降低了类与类之间的耦合性。 BufferedReader演示代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package FileReaderWriter;import java.io.BufferedReader;import java.io.File;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;/*** @author StormWangxhu* @version 创建时间：2017年10月31日 下午8:18:00**/public class BufferedReaderDemo &#123; public static void main(String[] args) &#123; String lines = null; //首先我们为了继续复习向文件里写入东西。进行创建、写入！ FileWriter fileWriter = null ; FileReader fileReader = null; BufferedReader bufferedReader = null ; try &#123; //创建文件并写入数据 fileWriter = new FileWriter(&quot;buf2.txt&quot;); fileWriter.write(&quot;bufferedReader,successful!&quot;); /* * 此处我在运行过程中出现了问题： * 在finally中忘记了关闭fileWriter流，从而数据一直停留在缓冲区，无法写入到文件中。 * close（）方法自带刷新技术。 * 则要想写入数据： *（1） 要么在写后进行flush(); * （2）要么在finally中进行关闭流资源，从而实现先刷新，再关闭。 * */ //fileWriter.flush(); System.out.println(&quot;测试：已运行&quot;); //利用缓冲技术进行读取 fileReader = new FileReader(&quot;buf2.txt&quot;); bufferedReader = new BufferedReader(fileReader); while ((lines=bufferedReader.readLine())!=null) &#123; System.out.println(lines); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; //进行流资源的关闭 if (bufferedReader!=null) &#123; try &#123; bufferedReader.close(); &#125; catch (Exception e2) &#123; e2.printStackTrace(); &#125; &#125; if (fileWriter!= null) &#123; try &#123; fileWriter.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 读取成功！ 读取和写入是一样的，写入操作BufferesWriter. 12我们仔细观察上面的代码，不难发现经过BufferedReader的装饰之后，读取数据可以一次读取一行，这样很好的提高了流的操作效率，但是readLine()方法是怎么实现的呢？我们可不可以自己定义一个BufferReader类来实现这些功能呢？答案是肯定的!实现一下吧！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package FileReaderWriter;/*** @author StormWangxhu* @version 创建时间：2017年10月31日 下午9:06:14**//* * 自定义BufferedReader * 实现readLine()方法 * 实现close()方法 * */import java.io.FileReader;import java.io.IOException;public class MyBufferesReader &#123; private FileReader fReader ; /*BuffedReader的初始化参数是流对象 * 所以这里的构造函数应该是带有流参数的构造函数 * */ public MyBufferesReader(FileReader fReader) &#123; this.fReader = fReader ; &#125; public String myReadLine() throws IOException &#123; /*** * BuferedReader的readLine方法 * 内部调用的是FileReader的read方法 * 并且内部封装了一个字符数组，来存取读取的字符。 * 这里为了方便，创建一个StringBuilder来存取字符。 * * */ StringBuilder sBuilder = new StringBuilder(); int ch=0 ; /** * 因为这里的read（）方法有可能抛出异常 * 再次申明此函数抛出异常 * */ while ((ch=fReader.read())!=-1) &#123; if (ch == &apos;\r&apos;) &#123; continue; &#125;else if (ch==&apos;\n&apos;) &#123; return sBuilder.toString(); &#125;else &#123; sBuilder.append((char)ch); &#125; //避免丢失最后一行 if (sBuilder.length() != 0) &#123; return sBuilder.toString();//toString()方法将对象转化为字符串对象。 &#125; &#125; return null; &#125; /** * myClose方法 * 实现关闭流功能 * @throws IOException * * */ public void myClose() throws IOException &#123; //可以看到，其实缓冲流的关闭，实际上是在关闭字符流。 //因此，在其他缓冲流关闭资源时，可以直接关闭字符流。 fReader.close(); &#125;&#125; 我们新建一个类来测试myBufferedReader 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package FileReaderWriter;/*** @author StormWangxhu* @version 创建时间：2017年10月31日 下午9:06:14**//* * 自定义BufferedReader * 实现readLine()方法 * * */import java.io.FileReader;import java.io.IOException;public class MyBufferesReader &#123; private FileReader fReader ; /*BuffedReader的初始化参数是流对象 * 所以这里的构造函数应该是带有流参数的构造函数 * */ public MyBufferesReader(FileReader fReader) &#123; this.fReader = fReader ; &#125; public String myReadLine() throws IOException &#123; /*** * BuferedReader的readLine方法 * 内部调用的是FileReader的read方法 * 并且内部封装了一个字符数组，来存取读取的字符。 * 这里为了方便，创建一个StringBuilder来存取字符。 * 因为最终还是要将数据变成字符串 * * */ StringBuilder sBuilder = new StringBuilder(); int ch=0 ; /** * 因为这里的read（）方法有可能抛出异常 * 再次申明此函数抛出异常 * */ while ((ch=fReader.read())!=-1) &#123; if (ch == &apos;\r&apos;) &#123; continue; &#125;else if (ch==&apos;\n&apos;) &#123; return sBuilder.toString(); &#125;else &#123; sBuilder.append((char)ch); &#125; //避免丢失最后一行 if (sBuilder.length() != 0) &#123; return sBuilder.toString(); &#125; &#125; return null; &#125; /** * myClose方法 * 实现关闭流功能 * @throws IOException * * */ public void myClose() throws IOException &#123; fReader.close(); &#125;&#125; 最后，我们看到实现了缓冲技术读取文本数据。但此时问题出现了，每读取一个就换行一次，和原BufferedReader功能不符合，我查看了半天，好可惜，没有看出来是为什么？此处望路过的大佬指点迷津！ 123补充修改说明： 2017/11/1 昨晚上写的时候还不知道为什么会出现这样的情况，输出一个就换一次行，和原BufferedReader输出形式不符合。今天就发现了，原来是使用了System.out.println(),换行打印，导致如是结果，现在回头看，昨晚估计是在睡梦中写的。。。哈哈哈修改代码后，我们再来看看输出情况： 输出正常，自定义BufferedReader复写成功。 缓冲解释：为什么需要缓冲呢？原因很简单，效率问题！缓冲中的数据实际上是保存在内存中，而原始数据可能是保存在硬盘或NandFlash中；而我们知道，从内存中读取数据的速度比从硬盘读取数据的速度至少快10倍以上。那干嘛不干脆一次性将全部数据都读取到缓冲中呢？第一，读取全部的数据所需要的时间可能会很长。第二，内存价格很贵，容量不想硬盘那么大。 1我们再来看看这个流 LineNumberReader1首先看看这个类的API 123456789101112下面我们简单的演示一下这个类，再自定义一个myLineNumberReader这个类好像过时了。。。。。。。今天就写到这里吧，再把上述讲的总结一下：字符流：基类： Reader FileReader FileWriter BufferReader BufferedWriter]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>I/O</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反射]]></title>
    <url>%2F2017%2F09%2F14%2F14--%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[反射的概述什么是反射每个.class文件被加载到内存后都是一个Class类的对象！例如Demo.class加载到内存后它是Class类型的一个对象。 反射就是通过Class对象获取类型相关的信息。一个Class对象就表示一个.class文件，可以通过Class对象获取这个类的构造器、方法，以及成员变量等。 反射是Java的高级特性，在框架中大量被使用！我们必须要了解反射，不然无法学好JavaWeb相关的知识！ 反射相关类与反射相关的类：与反射相关的类，它们都不能new！！！ Class：表示类； Field：表示成员变量； Method：表示方法； Constructor：表示构造器。 Class类获取class类获取class的三种基本方式： 通过类名称.class对基本类型也支持： Class c= int.class; Class c=int[].class; Class c =String.class; 通过对象.getclass()方法 Class c =obj.getClass(); Class.forName()通过类名称加载类，这种方法只要有类名称就可以得到.class。 Class c =Class.forName(“com.jdbc.mysql”); Class类常用方法 String getName()：获取类名称，包含包名； String getSimpleName()：获取类名称，不包含包名； Class getSupperClass()：获取父类的Class，例如：new Integer(100).getClass().getSupperClass()返回的是Class！但new Object().getSupperClass()返回的是null，因为Object没有父类； T newInstance()：使用本类无参构造器来创建本类对象； boolean isArray()：是否为数组类型； boolean isAnnotation()：是否为注解类型； boolean isAnnotationPresent(Class annotationClass)：当前类是否被annotationClass注解了； boolean isEnum()：是否为枚举类型； boolean isInterface()：是否为接口类型； boolean isPrimitive()：是否为基本类型； boolean isSynthetic()：是否为引用类型； 通过反射创建对象1234567891011121314151617181920212223242526272829303132333435public class Demo1 &#123; @Test public void fun1() throws Exception &#123; String className = "cn.baidu.User"; Class clazz = Class.forName(className); User user = (User)clazz.newInstance(); System.out.println(user); &#125;&#125;class User &#123; private String username; private String password; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return "User [username=" + username + ", password=" + password + "]"; &#125;&#125; Constructor它是Class的一个组成部门，所以需要先得到Class，再通过Class的方法得到Constructor Constructor表示一个类的构造器。即构造器的反射对象！ 获取Constructor对象获取Construcator对象需要使用Class对象，下面API来自Class类： Constructor getConstructor(Class… parameterTypes)：通过指定的参数类型获取公有构造器反射对象； Constructor[] getConstructors()：获取所有公有构造器对象； Constructor getDeclaredConstructor(Class… parameterTypes)：通过指定参数类型获取构造器反射对象。可以是私有构造器对象； Constructor[] getDeclaredConstructors()：获取所有构造器对象。包含私有构造器； Constructor类常用方法 String getName()：获取构造器名； Class getDeclaringClass()：获取构造器所属的类型； Class[] getParameterTypes()：获取构造器的所有参数的类型； Class[] getExceptionTypes()：获取构造器上声明的所有异常类型； T newInstance(Object… initargs)：通过构造器反射对象调用构造器。 练习：通过Constructor创建对象User.java 123456789101112131415161718192021222324252627282930313233public class User &#123; private String username; private String password; public User() &#123; &#125; public User(String username, String password) &#123; this.username = username; this.password = password; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return "User [username=" + username + ", password=" + password + "]"; &#125;&#125; Demo1.java 12345678910public class Demo1 &#123; @Test public void fun1() throws Exception &#123; String className = "cn.itcast.User"; Class clazz = Class.forName(className); Constructor c = clazz.getConstructor(String.class, String.class);//通过参数类型来获取构造器，即获取两个String类型参数的构造器反射对象。 User user = (User)c.newInstance("zhangSan", "123");//通过构造器反射对象来调用构造器，并传递参数给构造器 System.out.println(user); &#125;&#125; Method（类的组成部分）Class — 类的反射对象 Constructor — 构造器的反射对象 Method表示方法的反射对象 Field — 成员的反射对象 获取Method获取Method需要通过Class对象，下面是Class类的API： Method getMethod(String name, Class… parameterTypes)：通过方法名和方法参数类型获取方法反射对象，包含父类中声明的公有方法，但不包含所有私有方法； Method[] getMethods()：获取所有公有方法，包含父类中的公有方法，但不包含任何私有方法； Method getDeclaredMethod(String name, Class… parameterTypes)：通过方法名和方法参数类型获取本类中声明的方法的反射对象，包含本类中的私有方法，但不包含父类中的任何方法； Method[] getDeclaredMethods()：获取本类中所有方法，包含本类中的私有方法，但不包含父类中的任何方法。 Method常用方法 String getName()：获取方法名； Class getDeclaringClass()：获取方法所属的类型； Class[] getParameterTypes()：获取方法的所有参数的类型； Class[] getExceptionTypes()：获取方法上声明的所有异常类型； Class getReturnType()：获取方法的返回值类型； Object invode(Object obj, Object… args)：通过方法反射对象调用方法，如果当前方法是实例方法，那么当前对象就是obj，如果当前方法是static方法，那么可以给obj传递null。args表示是方法的参数； 练习：通过Method调用方法12345678910111213public class Demo1 &#123; @Test public void fun1() throws Exception &#123; String className = "cn.itcast.User"; Class clazz = Class.forName(className); Constructor c = clazz.getConstructor(String.class, String.class); User user = (User)c.newInstance("zhangSan", "123"); Method method = clazz.getMethod("toString");//获取名为toString，没有参数的方法 String result = (String)method.invoke(user);//反射调用这个方法，给this赋值为user，没有传递参数，因为这个方法没有参数。 System.out.println(result);[打印返回值。] &#125;&#125; FieldField表示类的成员变量，可以是实例变量，也可以是静态变量。 获取Field对象获取Field对象需要使用Class对象，下面是Class类的API： Field getField(String name)：通过名字获取公有成员变量的反射对象，包含父类中声明的公有成员变量； Field[] getFields()：获取所有公有成员变量反射对象，包含父类中声明的公有成员变量； Field getDeclaredField(String name)：通过名字获取本类中某个成员变量，包含本类的private成员变量，但父类中声明的任何成员变量都不包含； Field[] getDeclaredFields()：获取本类中声明的所有成员变量，包含private成员变量，但不包含父类中声明的任何成员变量 Field类的常用方法 String getName()：获取成员变量名； Class getDeclaringClass()：获取成员变量的类型； Class getType()：获取当前成员变量的类型； Object get(Object obj)：获取obj对象的成员变量的值； void set(Object obj, Object value)：设置obj对象的成员变量值为value； 练习：通过Field读写成员User.java 123456789101112131415161718192021222324252627282930313233public class User &#123; public String username; public String password; public User() &#123; &#125; public User(String username, String password) &#123; this.username = username; this.password = password; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return "User [username=" + username + ", password=" + password + "]"; &#125;&#125; Demo1.java 123456789101112131415161718192021public class Demo1 &#123; @Test public void fun1() throws Exception &#123; String className = "cn.itcast.User"; Class clazz = Class.forName(className); User user = new User("zhangSan", "123"); Field field1 = clazz.getField("username");//名为username的成员变量 Field field2 = clazz.getField("password");//为password的成员变量 String username = (String)field1.get(user);//er对象的username成员变量值，因为field1表示的就是username成员变量 String password = (String)field2.get(user);//user对象的password成员变量值，因为field2表示的就是password成员变量 System.out.println(username + ", " + password); field1.set(user, "liSi");//user对象的username成员变量值为liSi field2.set(user, "456");//user对象的password成员变量值为456 System.out.println(user); &#125;&#125; AccessibleObject AccessibleObject类是Constructor、Method、Field三个类的父类。AccessibleObject最为重要的方法如下： boolean isAccessible()：判断当前成员是否可访问； void setAccessible(boolean flag)：设置当前成员是否可访问。 当Constructor、Method、Field为私有时，如果我们想反射操作，那么就必须先调用反射对象的setAccessible(true)方法，然后才能操作。 User.java 123456789101112131415161718192021222324252627282930313233public class User &#123; private String username; private String password; public User() &#123; &#125; public User(String username, String password) &#123; this.username = username; this.password = password; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return "User [username=" + username + ", password=" + password + "]"; &#125;&#125; 注意，User类的username和password成员变量为private的，这时再通过Field来反射操作这两个成员变量就必须先通过setAccessible(true)设置后才行。 12345678910111213141516171819202122public class Demo1 &#123; @Test public void fun1() throws Exception &#123; String className = "cn.itcast.User"; Class clazz = Class.forName(className); User user = new User("zhangSan", "123"); Field field1 = clazz.getDeclaredField("username"); Field field2 = clazz.getDeclaredField("password");//因为username和password都是私有的成员变量，所以需要使用getDeclaredField()才能获取到. field1.setAccessible(true); field2.setAccessible(true);//设置成员变量是可以访问的，对于私有变量、方法、构造器都必须先调用这个方法后才能操作，不然会抛出异常。 String username = (String)field1.get(user); String password = (String)field2.get(user); System.out.println(username + ", " + password); field1.set(user, "liSi"); field2.set(user, "456"); System.out.println(user); &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[增强 for 循环]]></title>
    <url>%2F2017%2F09%2F12%2F12--%E5%A2%9E%E5%BC%BA-for-%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[增强for循环是for的一种新用法！用来循环遍历数组和集合。 增强for的语法12for(元素类型 e : 数组或集合对象) &#123;&#125; 例如： 1234int[] arr = &#123;1,2,3&#125;;for(int i : arr) &#123; System.out.println(i);&#125; 增强for的冒号左边是定义变量，右边必须是数组或集合类型。例如上例中循环遍历的主浊arr这个int数组，增强for内部会依次把arr中的元素赋给变量i。 增强for的优缺点 只能从头到尾的遍历数组或集合，而不能只遍历部分； 在遍历List或数组时，不能获取当前元素下标； 增强for使用便简单，这是它唯一的优点了； 增强for比使用迭代器方便一点！ 增强for的原理任何实现了Iterable接口的类，都有返回Iterator的方法。 其实增强for底层是迭代器，任何实现了Iterable接口的类都可以使用增强for来遍历！ 其实增强for内部是使用迭代器完成的！也就是说，任何实现了Iterable接口的对象都可以被增强for循环遍历！这也是为什么增强for可以循环遍历集合的原因（Collection是Iterable的子接口）。 但要注意，Map并没有实现Iterable接口，所以你不能直接使用增强for来遍历它！ 123456789Map&lt;String, String&gt; map = new HashMap&lt;String,String&gt;(); map.put("1", "one"); map.put("2", "two"); map.put("3", "three"); for(String key : map.keySet()) &#123; String value = map.get(key); //循环遍历map的所有键，map.keySet()返回的是Set类型，而Set是可以被增强for遍历的。 System.out.println(key + "=" + value);&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>for循环</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[详解JDK5.0新特性自动拆装箱]]></title>
    <url>%2F2017%2F09%2F10%2F10--%E8%AF%A6%E8%A7%A3JDK5.0%E6%96%B0%E7%89%B9%E6%80%A7%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1%2F</url>
    <content type="text"><![CDATA[自动拆装箱就是8种基本类型与其对应包装器类型可以直接互换！ 注意：基本类型的数组，与包装器类型的数组不能互换！ 自动拆装箱是JDK5.0的新特性之一，这一特性可以使基本类型，与之对应的包装器类型之间直接转换，例如int的包装器类型是Integer！在JDK5.0之后，你甚至可以把int当作成Integer来使用，把Integer当成int来使用。当然，这不是100%的！ 自动拆装箱概述在JDK5.0之后，Java允许把基本类型与其对应的包装器类型之间自动相互转换。 自动装箱：Integer i = 100，把int类型直接赋值给Integer类型； 自动拆装：int a = new Integer(100)，把Integer类型直接赋值给int类型。 自动拆装箱原理其实自动拆装箱是由编译器完成的！我们写的代码，再由编译器“二次加工”，然后再编译成.class文件！那么编译器是怎么“二次加工”的呢？ Integer i = 100：编译器加工为：Integer i = Integer.valueOf(100)； int a = i：编译器加载为：int a = i.intValue()； 这也说明一个道理：JVM并不知道什么是自动拆装箱，JVM还是原来的JVM（JDK1.4之前），只是编译器在JDK5.0时“强大”了！ 自动拆装箱演变大家来看看下面代码： 12Integer i = 100;//这是自动装箱Object o = i;//这是身上转型 上面代码是没有问题的，我们是否可以修改上面代码为： 1Object o = 100; ok，这是可以的！通过编译器的处理后上面代码为： 1Object o = Integer.valueOf(100); 在来看下面代码： 12Object o = Integer.valueOf(100);int a = o;//编译失败！ 上面代码是不行的，因为o不是Integer类型，不能自动拆箱，你需要先把o转换成Integer类型后，才能赋值给int类型。 12Object o = Integer.valueOf(100);int a = (Integer)o; 自动拆装箱的误区来看下面代码： 12int[] intArr = &#123;1,2,3&#125;;Integer[] integerArr = intArr;//编译失败 上面代码无论编译通过！因为int[]是引用类型，而不是基本类型。而自动拆装箱只是在基本类型与其对应的包装器类型之间进行转换！也就是说，int[]和Integer[]是两种不同的引用类型。 你可能会认为，把上面代码修改下面的样子即可，这说明需要还是没有理解这一概念。把int[]转换成Integer[]，等同与把Integer转换成String类型一样，是不行的！所以下面代码还是编译失败。 12int[] intArr = &#123;1,2,3&#125;;Integer[] integerArr = (Integer[])intArr; 如果可以把int当成Integer来对待，那么是否可以：int a = null？当然是不行的，所以希望学员们对自动拆装箱正确理解，它不是万能的。 变态小题目来看下面代码： 1234567Integer i1 = 100;Integer i2 = 100;boolean b1 = i1 == i2;//结果为trueInteger i3 = 200;Integer i4 = 200;boolean b2 = i3 == i4;//结果为false 你可能对上面代码的结果感到费解，那么我们来打开这个疑团。第一步，我们先把上面代码通过编译器的“二次加工”处理一下： 1234567Integer i1 = Integer.valueOf(100);Integer i2 = Integer.valueOf(100);boolean b1 = i1 == i2;//结果为trueInteger i3 = Integer.valueOf(200);Integer i4 = Integer.valueOf(200);boolean b2 = i3 == i4;//结果为false 这时你应该可以看到，疑团在Integer.valueOf()方法身上。传递给这个方法100时，它返回的Integer对象是同一个对象，而传递给这个方法200时，返回的却是不同的对象。这是我们需要打开Integer的源码，查看它的valueOf()方法内容。 12345678910111213141516171819202122232425262728293031323334353637383940private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high"); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; &#125; private IntegerCache() &#123;&#125; &#125;public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); &#125; Integer类的内部缓存了-128~127之间的256个Integer对象，如果valueOf()方法需要把这个范围之内的整数转换成Integer对象时，valueOf()方法不会去new对象，而是从缓存中直接获取，这就会导致valueOf(100)两次，都是从缓存中获取的同一个Integer对象！如果valueOf()方法收到的参数不在缓存范围之内，那么valueOf()方法会new一个新对象！这就是为什么Integer.valueOf(200)两次返回的对象不同的原因了。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>拆装箱</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的coding之路开始啦]]></title>
    <url>%2F2017%2F05%2F27%2F27--%E6%88%91%E7%9A%84coding%E4%B9%8B%E8%B7%AF%E5%BC%80%E5%A7%8B%E5%95%A6%2F</url>
    <content type="text"><![CDATA[从今天起，我会把我每天的练习代码和学习到的东西写在这里，一来可以检测我是否真正理解了我所学的东西，因为只有理解了才会把他用自己的语言描述出来。二来可以把我们每天的进度记录下来，以此鞭策和励志自己！三来也方便自己日后查看自己coding之路，也算作是对自己的付出一份礼物吧！面对压力，我可以挑灯夜战、不眠不休；面对困难，我愿意迎难而上、永不退缩。我看好自己的认真，加油吧，少年！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>心得</tag>
      </tags>
  </entry>
</search>
