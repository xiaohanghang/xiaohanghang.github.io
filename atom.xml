<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>StormWangxhu&#39; s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://StormWangxhu.github.io/"/>
  <updated>2018-04-18T12:49:21.109Z</updated>
  <id>https://StormWangxhu.github.io/</id>
  
  <author>
    <name>StormWangxhu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记百度 Java 实习第二面</title>
    <link href="https://StormWangxhu.github.io/2018/04/18/%E8%AE%B0%E7%99%BE%E5%BA%A6-Java-%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%BA%8C%E9%9D%A2/"/>
    <id>https://StormWangxhu.github.io/2018/04/18/记百度-Java-实习第二面/</id>
    <published>2018-04-17T16:00:00.000Z</published>
    <updated>2018-04-18T12:49:21.109Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>我看好自己的认真！</p></blockquote><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>突如其来哦，毫无防备……</p><h2 id="面试内容"><a href="#面试内容" class="headerlink" title="面试内容"></a>面试内容</h2><p>1、HashMap的存储结构</p><p>2、HashMap扩容过程旧数据如何处理？位置还是原来位置吗？</p><p>3、HashMap对key有什么要求吗？一般用String作为key，问我能否用int或者其他Object类型</p><p>4、Object作为HashMap的key的话，对Object有什么要求吗？</p><p>5、Object若不重写hashCode()的话，hashCode()如何计算出来的？</p><p>6、hashCode()和equals()方法有什么联系？</p><p>7、若对一个类不重写，它的equals()方法是如何比较的？</p><p>8、==比较的是什么？</p><p>9、hashCode()和equals()方法有什么要求吗？</p><p>10、简单算法题：将一个二维数组顺时针旋转90度，说一下思路。</p><p>11、简单算法题：将一个int类型数字、负数逆序输出，须返回一个int类型数字。即反转</p><p>12、String能继承吗？就说到了用final修饰</p><p>13、final怎么用？分别说了修饰变量、方法、类</p><p>14、ConcurrentHashMap的分段锁原理</p><p>15、Java中有几种方式启动一个线程？（说了个start()、线程池不知道对否）</p><p>16、线程池有什么好处？</p><p>17、Java中有几种线程池？</p><p>18、TCP的三次握手</p><p>19、TCP如何保证可靠传输？</p><p>20、框架用过哪些？说刚入门Spring、经典三层MVC</p><p>21、项目</p><p>22、Servlet是线程安全的吗？（一脸懵逼）</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>完了就说，嗯好了解了，那我们今天先到这里。加油</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;我看好自己的认真！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;突如其来哦，毫无防备……&lt;/p&gt;
      
    
    </summary>
    
      <category term="总结" scheme="https://StormWangxhu.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="实习" scheme="https://StormWangxhu.github.io/tags/%E5%AE%9E%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Java 线程池的原理</title>
    <link href="https://StormWangxhu.github.io/2018/04/18/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>https://StormWangxhu.github.io/2018/04/18/Java-线程池的原理/</id>
    <published>2018-04-17T16:00:00.000Z</published>
    <updated>2018-04-18T04:11:17.260Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>我看好自己的认真！</p></blockquote><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇博文将解决三个问题：</p><ul><li>为什么要使用线程池</li><li>线程池的实现原理</li><li>如何使用线程池</li></ul><p>首先解决第一个问题，我们为什么要使用线程池？线程池，顾名思义，就是用来管理线程的创建，销毁的。具体原因可分为以下三点：</p><p>（1）、<strong>降低资源消耗</strong>：通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p><p>（2）、<strong>提高响应速度</strong>：当任务到达时，任务可以不需要等到线程创建就能立即执行。</p><p>（3）、<strong>提高线程的可管理性</strong>：线程是稀缺资源，若无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。但是，要做到合理利用线程池，必须对其实现原理了如指掌。</p><h2 id="线程池的实现原理"><a href="#线程池的实现原理" class="headerlink" title="线程池的实现原理"></a>线程池的实现原理</h2><p>当一个任务被提交到线程池后，这个任务会是怎样被处理的呢？在正式介绍之前，先来了解几个概念：</p><p>核心线程池：任务提交到首先考虑使用这个线程池中的线程。</p><p>工作队列：存储等待线程的任务的一个队列。</p><p>一般线程池：当工作队列里存储任务满时，则将任务提交到一般线程池。</p><p>下面我们通过这幅图来了解一下一个任务的处理流程：</p><p><img src="https://images2018.cnblogs.com/blog/1353941/201803/1353941-20180317112341374-408914367.png" alt="âjavaå¹¶åç¼ç¨çèºæ¯ç¬¬ä¹ç« å¾çâçå¾çæç´¢ç»æ"></p><p>​                                                                  [ 线程池的主要处理流程]</p><p>主要三个流程：</p><p>（1）、线程池判断核心线程池中线程是否都在执行任务。若不是，则创建一个新的工作线程来执行任务。若核心线程池中线程都在执行任务，则将其任务进入下一个流程。</p><p>（2）、线程池判断工作队列是否已满。未满，将新提交任务存储其中；已满，进入下一个流程。</p><p>（3）、线程池判断一般线程池中线程是否都处于工作状态。不是，创建一个新线程执行任务；是，提交给饱和策略来处理这个任务。</p><h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h2><p><img src="http://images2015.cnblogs.com/blog/449569/201707/449569-20170715144352681-264824712.png" alt="âçº¿ç¨æ± âçå¾çæç´¢ç»æ"></p><h3 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadPoolExecutor(corePoolSize,maximumPoolSize,keepAliveTime,milliseconds,runnableTaskQueue,handler);</span><br></pre></td></tr></table></figure><p>那么创建线程时的这几参数是和意义？</p><ul><li><p>corePoolSize(线程池的基本大小)：当提交一个任务到线程池时，即使还有其他空闲的核心线程，线程池会创建一个线程来执行任务，直到核心线程等于corePoolSize时，就会将新提交的任务放入队列或创建新的工作线程。我们可以通过调用线程池的prestartAllCoreThreads（)方法来提前创建并启动所有的核心线程。 </p></li><li><p>runnableTaskQueue(任务队列)：用于保存等待执行的任务的阻塞队列。可以选择ArrayBolckingQueue、LinkedBlockingQueue、SynchronousQueue、PriorityBlockingQueue等阻塞队列。 </p></li><li><p>maximumPoolSize(线程池最大数量)：如果队列已满，并且已创建的线程数小于maximumPoolSize，则线程池会创建新的线程执行任务。如果使用了无界队列，则此参数无效果。 </p></li><li><p>ThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。 </p></li><li><p>RejectedExecutionHandler(饱和策略)：如果队列已满，且已创建的线程数等于maximumPoolSize，则采取饱和策略处理新提交的任务。有以下4种策略： </p><ul><li>AbortPolicy:直接抛出异常。 </li></ul></li></ul><ul><li>CallerRunsPolicy:使用调用者线程来执行任务。 </li></ul><ul><li>DiscardOldestPolicy:丢弃队列里最近的一个任务，并执行当前任务。 </li></ul><ul><li><p>DiscardPolicy:不处理，直接丢弃任务。 </p><p>我们也可以实现RejectedExecutionHandler接口来自定义饱和策略，如记录日志或持久化存储等。 </p></li></ul><ul><li><p>keepAliveTime(线程保持活动时间)：线程池中空闲的线程存活时间。 </p></li><li><p>TimeUnit(线程保活时间的单位)：可选的单位有天、小时、分钟、毫秒、微妙和纳秒。 </p></li></ul><h3 id="向线程池提交任务"><a href="#向线程池提交任务" class="headerlink" title="向线程池提交任务"></a>向线程池提交任务</h3><p>记住两种方法：execute()和submit()方法</p><p>这两种方法都可以向线程池提交任务，但也有区别如下：</p><ul><li>execute()方法用于提交不需要返回值的任务，所以无法判断任务的执行状态。</li><li>submit()方法用于提交需要返回值的任务。线程池会返回一个Future类型的对象，通过此对象，我们可以判断任务是否执行成功，并通过get()方法阻塞当前线程直到任务完成并返回返回值。</li></ul><h3 id="关闭线程"><a href="#关闭线程" class="headerlink" title="关闭线程"></a>关闭线程</h3><p>通过调用线程池的<code>shutdown</code>或<code>shutdownNow</code>方法来关闭线程池。其原理是遍历线程池中的工作线程，然后依次调用线程的<code>interrupt</code>方法中断线程。两者的区别是shutdownNow方法会立即中断所有的工作线程，而<code>shutdown</code>方法只会中断未开始的任务线程并等待正在执行任务的线程执行完毕。可以调用<code>isShutDown</code>方法和<code>isTerminaed</code>方法来检查线程池及线程池中的工作线程关闭状态。 </p><h3 id="合理地分配线程池"><a href="#合理地分配线程池" class="headerlink" title="合理地分配线程池"></a>合理地分配线程池</h3><p>要想合理的配置线程池，就必须首先分析任务特性，可以从以下几个角度分析。 </p><ul><li>任务的性质：CPU密集型任务、IO密集型任务和混合型任务。 </li><li>任务的优先级：高、中和低。 </li><li>任务的执行时间：长、中和短。 </li><li>任务的依赖性：是否依赖其他系统资源，如数据库连接。<br>性质不同的任务可以用不同规模的线程池分开处理。CPU密集型任务应配置尽可能小的线程，如cpu个数+1个线程。而IO密集型任务应配置尽可能多的线程，如cpu数量*2个线程。因为IO密集型任务线程并不是一直在执行任务，可能被IO阻塞等，如果线程太少，则会导致无法及时处理新提交的任务。</li></ul><h3 id="线程池的监控"><a href="#线程池的监控" class="headerlink" title="线程池的监控"></a>线程池的监控</h3><p>如果在系统中大量使用线程池，则有必要对线程池进行监控，方便在出现问题时，快速定位问题。可以通过线程池提供的以下参数进行监控： </p><ul><li>taskCount：线程池需要执行的任务数量。 </li><li>completedTaskCount：线程池在运行过程中已完成的任务数量，小于或等于taskCount。 </li><li>largestPoolSize：线程池里增加创建过的最大线程数量。通过这个数据可以知道线程池是否曾经满过。 </li><li>getPoolSize：线程池的线程数量。 </li><li>getActiveCount：获取活动的线程数。<br>也可以通过继承线程池来自定义线程池，重写线程池的beforeExecute、afterExecute和terminate方法，在任务执行前、执行后和线程池关闭前执行一些代码进行监控。</li></ul><h2 id="总结小记"><a href="#总结小记" class="headerlink" title="总结小记"></a>总结小记</h2><p>主要讲解了线程池的使用原理，在概念上进行了解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;我看好自己的认真！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本篇博文将解决三个问题：&lt;/p&gt;
      
    
    </summary>
    
      <category term="Java 并发编程的艺术" scheme="https://StormWangxhu.github.io/categories/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/"/>
    
    
      <category term="ThreadPool" scheme="https://StormWangxhu.github.io/tags/ThreadPool/"/>
    
      <category term="Java线程池原理" scheme="https://StormWangxhu.github.io/tags/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>记百度 Java 实习第一面</title>
    <link href="https://StormWangxhu.github.io/2018/04/16/%E8%AE%B0%E7%99%BE%E5%BA%A6-Java-%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%9D%A2/"/>
    <id>https://StormWangxhu.github.io/2018/04/16/记百度-Java-实习第一面/</id>
    <published>2018-04-15T16:00:00.000Z</published>
    <updated>2018-04-16T09:49:10.475Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>我看好自己的认真！</p></blockquote><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>几天前，百度方面就打来了电话，和我确定了面试时间，没错，就是今天下午二点。我一点半就午休起来等待电话铃声的响起，过了两点后，还没有来，我的内心更慌了，过了十分后铃声突然响起，响了几秒钟就接了，哈哈。</p><h2 id="面试内容"><a href="#面试内容" class="headerlink" title="面试内容"></a>面试内容</h2><p>这次把面试的主要内容简单介一下，有些问题回答的不太好，需要再仔细琢磨，主要内容如下：</p><p>1、简单自我介绍，（西电大二，自学Java，想找实习，balabala）…..</p><p>2、简要介绍简历上项目：网上图书商城，主要功能有哪些？用到哪些技术栈？说到了经典MVC三层框架，简单介绍</p><p>3、看我正在学习Spring，让简要说一下spring Ioc</p><p>4、问我是否用过spring+springMVC？</p><p>5、有没有学过数据结构——&gt;引出数组和链表的区别？说到了数组和链表增删速度以及为什么？</p><p>6、给了我10亿条散乱、无序的数据，让我找出1000个最大的数，问我有什么想法吗？（傻傻的说到了排序，递归，面试官自言到：用递归吗？凉了。。。一看我胡说，就再没有问）</p><p>7、Java 递归栈最深能递归多少次（说10个数据的话，递归肯定会溢出。这个我，没说上）</p><p>8、排序（和10亿数据有关，没回答上，让我下去了解一下）</p><p>9、JVM内存区域、类加载过程</p><p>10、类卸载发生到什么时候？</p><p>11、JVM 垃圾对象回收相关（引用计数法、可达性分析算法判断对象死活；常用垃圾回收算法G1(JDK1.7以上)）</p><p>12、垃圾回收算法（标记清除，标记整理，复制算法）</p><p>13、什么时候会触发新生代、老年代垃圾回收？</p><p>14、Java 内存模型</p><p>15、锁机制：volatile（内存可见性、禁止指令重排序），sychronized（monitorenter和monitorexit）在内存方面进行解释。同一时间，两个线程访问一个被sychronized修饰的方法块，JVM是如何阻止另外一个线程访问的？（面试官说回答的差不多）</p><p>16、数据库索引，索引如何做到快速查询？（不了解）</p><p>17、HTTP协议：问到后端给前端传递一条数据，HTTP是如何进行传递的？消息体里有哪些？后端传递的数据放在了HTTP哪里？（消息体这儿答得不太好，即数据内容怎么存放的？）</p><p>18、问我大一时参加的星火杯是什么？</p><p>19、问我有没有什么展示我代码功底的：说到了Github</p><p>20、面试官问我有什么要问她的？（对，面试官是小姐姐诶），问了部门业务——大数据，部门人数—1000到2000</p><p>21、问我什么时候能去实习？</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>然后就完了，对，完了。面试官说今天就聊这儿吧。所以还会有明天吗？挂了之后就想起来怎么没有问会有面试结果通知吗，嘎嘎嘎嘎嘎嘎。。。</p><p>总体感觉回答的还可以，也有答得不好的地方，要去努力了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;我看好自己的认真！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;几天前，百度方面就打来了电话，和
      
    
    </summary>
    
      <category term="总结" scheme="https://StormWangxhu.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="实习" scheme="https://StormWangxhu.github.io/tags/%E5%AE%9E%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发机制的底层实现原理</title>
    <link href="https://StormWangxhu.github.io/2018/04/15/Java-%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://StormWangxhu.github.io/2018/04/15/Java-并发机制的底层实现原理/</id>
    <published>2018-04-14T16:00:00.000Z</published>
    <updated>2018-04-15T07:59:51.092Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;
      
    
    </summary>
    
      <category term="Java 并发编程的艺术" scheme="https://StormWangxhu.github.io/categories/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/"/>
    
    
      <category term="synchronized" scheme="https://StormWangxhu.github.io/tags/synchronized/"/>
    
      <category term="volatile" scheme="https://StormWangxhu.github.io/tags/volatile/"/>
    
      <category term="原子操作" scheme="https://StormWangxhu.github.io/tags/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发容器之看清 ConcurrentHashMap 构造</title>
    <link href="https://StormWangxhu.github.io/2018/04/15/Java-%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8B%E7%9C%8B%E6%B8%85-ConcurrentHashMap-%E6%9E%84%E9%80%A0/"/>
    <id>https://StormWangxhu.github.io/2018/04/15/Java-并发容器之看清-ConcurrentHashMap-构造/</id>
    <published>2018-04-14T16:00:00.000Z</published>
    <updated>2018-04-15T11:39:06.884Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java 中的集合框架HashMap 和 ConcurrentHashMap在我几次面试中，都问到了，可见其在考察基础知识中的重要性。今天就要看清它的庐山真面目，看看它到底是个什么鬼，为何如此受青睐。</p><h2 id="先看ConcurrentHashMap的实现原理"><a href="#先看ConcurrentHashMap的实现原理" class="headerlink" title="先看ConcurrentHashMap的实现原理"></a>先看ConcurrentHashMap的实现原理</h2><p>ConcurrentHashMap 是线程安全且高效的HashMap。我们即将知道他是如何在保证线程安全的前提下又保证高效的呢？</p><h3 id="为什么要用ConcurrentHashMap"><a href="#为什么要用ConcurrentHashMap" class="headerlink" title="为什么要用ConcurrentHashMap"></a>为什么要用ConcurrentHashMap</h3><p>在并发编程中使用HashMap可能导致程序死循环。而使用线程安全的HashTable效率又低下，基于以上两个原因，便有了ConcurrentHashMap的登场机会</p><p>在说此之前，我们不得不先来看看常用的但又线程不安全的HashMap</p><h4 id="线程不安全的HashMap"><a href="#线程不安全的HashMap" class="headerlink" title="线程不安全的HashMap"></a>线程不安全的HashMap</h4><p>在多线程环境下，使用HashMap进行put操作会引起死循环，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap。所以我们来看一段会引起死循环的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> stormwangxhu.algorithm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">new</span> Main().MapTest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MapTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> HashMap&lt;String,String&gt; map=<span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        Thread thread=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10000</span> ; i++) &#123;</span><br><span class="line">                    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            map.put(UUID.randomUUID().toString(),<span class="string">""</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,<span class="string">"FTF"</span>+i).start();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"FTF"</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap在并发执行put操作时会引起死循环，是因为多线程会导致HashMap的Entry链表形成环形数据结构，一旦形成环形数据结构，Entry的next节点永远不会为空，就会产生死循环获取Entry。</p><p>下面再看看在多线程环境下效率低下的HashTable</p><h4 id="效率低下的HashTable"><a href="#效率低下的HashTable" class="headerlink" title="效率低下的HashTable"></a>效率低下的HashTable</h4><p><code>HashTable</code>  容器使用关键字<code>sychronized</code> 来保证线程安全，但在线程竞争激烈的情况下<code>HashTable</code> 的效率就会非常低下。因为当一个线程访问<code>HashTable</code>的同步方法，其他线程也会访问<code>HashTable</code>的同步方法时，就会进入阻塞或轮询状态。若线程1使用<code>put</code>进行元素添加，线程2不但不能使用<code>put</code>方法进行添加元素，就会连<code>get</code>方法来获取元素也不能使用，所以线程竞争越激烈效率就越低！</p><p>现在来看看ConcurentHashMap是如何即保证线程安全又获得高效率呢？</p><h4 id="ConcurrentHashMap到底底层使用什么法宝呢？"><a href="#ConcurrentHashMap到底底层使用什么法宝呢？" class="headerlink" title="ConcurrentHashMap到底底层使用什么法宝呢？"></a>ConcurrentHashMap到底底层使用什么法宝呢？</h4><p>是不是很期待？厉害了！它是用的是一种<strong>锁分段技术</strong>来有效提升并发访问效率。那么问题来了，什么是锁分段技术？</p><h5 id="什么是锁分段技术"><a href="#什么是锁分段技术" class="headerlink" title="什么是锁分段技术"></a>什么是锁分段技术</h5><p><code>HashTable</code>  容器在竞争激烈的并发环境中表现出效率低下的原因是：所有访问HashTable的线程都必须竞争同一把锁，假如容器里有很多把锁，每一把锁用于锁容器其中的一部分数据，那么多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效提高并发访问效率，这就是<code>ConcurrentHashMap</code>所使用的锁分段技术。</p><p><strong>锁分段技术</strong>：首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p><p>现在知道了这个技术后，我们就应该来看看他是怎么实现的了，即他的实现原理是什么？请接着往下看：</p><h3 id="看清ConcurrentHashMap-的结构"><a href="#看清ConcurrentHashMap-的结构" class="headerlink" title="看清ConcurrentHashMap 的结构"></a>看清ConcurrentHashMap 的结构</h3><p>先来看看<code>ConcurrentHashMap</code> 的结构图：</p><p><img src="https://camo.githubusercontent.com/ff0d3c27a0cb86f251d3a01acafe668d88124273/68747470733a2f2f7777772e70726f636573736f6e2e636f6d2f63686172745f696d6167652f3538646439663238653462306664633032323139633934632e706e67" alt="ç»æå¾"></p><p>再看看ConcurrentHashMap的类图：</p><p><img src="http://ifeve.com/wp-content/uploads/2012/12/ConcurrentHashMap%E7%B1%BB%E5%9B%BE.jpg" alt="âConcurrentHashMapç±»å¾âçå¾çæç´¢ç»æ"></p><p>看完上面两幅图后，我们来进行深入剖析：</p><p><strong>ConcurrentHashMap =  Segment数组结构  +  HashEntry数组结构组成。</strong></p><ul><li>Segment数组结构扮演锁的角色。</li><li>HashEntry则用于存储键值对数据。</li></ul><p>一个ConcurrentHashMap包含一个 Segment数组结构和 HashEntry数组结构。</p><h4 id="Segment数组结构："><a href="#Segment数组结构：" class="headerlink" title="Segment数组结构："></a><strong>Segment数组结构：</strong></h4><p>它是一种可重入锁（ReentranLock），在ConcurrentHashMap里扮演者锁的角色。它和HashMap类似，是一种数据加链表结构。</p><p><img src="https://upload-images.jianshu.io/upload_images/4983431-31568b5749a41752.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/564" alt="âConcurrentHashMapç»æå¾âçå¾çæç´¢ç»æ"></p><p>在我前面的博文中，《深入理解Java虚拟机》中，关于<code>Segment</code>进行了简单的介绍，下面也回顾一下：</p><p><code>ReentranLock</code>，即可重入锁，它是<code>java.util.concurrent</code>包下的，它可以来实现同步，在基本用法上，<code>ReentranLock</code>和<code>sychronized</code>很相似，他们都具备一样的线程重入特性，只是代码写法上有点区别。</p><p><strong>ReentranLock和sychronized区别：</strong> </p><p><code>ReentranLock</code>表现为API层面的互斥锁（<code>Lock()</code>和<code>unLock()</code>方法配合<code>try/finally</code>语句块来完成），而<code>sychronized</code>表现为原生层面的互斥锁。</p><p>注意此处：我说的是原生层面，什么意思？因为Java的线程是映射到操作系统的原生线程之上的，如果要阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态切换到核心态中，因而状态转换需要耗费很多处理器的时间。所以<code>sychronized</code>是<code>Java</code>语言中的一个重量级的操作。所以应该在确实有必要的情况下在使用这种操作。</p><p>那么关于<code>ReentranLock</code>和<code>sychronized</code>在性能上谁优谁不优怎么知道呢？在多线程环境下，<code>sychronized</code>的吞吐量下降的会非常严重，而<code>ReentranLock</code>则基本保持在同一个比较稳定的水平上。在JDK1.6发布之后，两者之间在性能上基本持平了。因此虚拟机在未来的性能改进中也会更加偏向于原生的<code>sychronized</code>，所以还是提倡在<code>sychronized</code>能实现需求的情况下，优先考虑<code>sychronized</code>来进行同步。</p><p>好了，说完了两者区别后，我们继续前面的话题：</p><p>一个<code>Segment</code>里包含一个<code>HashEntry</code>数组，每一个<code>HashEntry</code>数组是一个链表结构的元素，每一个<code>Segment</code>守护者一个<code>HashEntry</code>数组里的元素。当对<code>HashEntry</code>数组进行修改时，必须先获得与它对应的<code>Segment</code>锁</p><p>上面这句话的意思可以用下面这幅图来解释：</p><p><img src="https://gss0.bdstatic.com/7LsWdDW5_xN3otebn9fN2DJv/doc/pic/item/08f790529822720e8a8f672872cb0a46f31fab9b.jpg" alt="âConcurrentHashMapç»æå¾âçå¾çæç´¢ç»æ"></p><h4 id="总结一下："><a href="#总结一下：" class="headerlink" title="总结一下："></a>总结一下：</h4><p><strong>Segment组成</strong>： 数组+链表</p><p><strong>HashEntry组成</strong>： 链表</p><p><strong>两者关系</strong>：每个segment里包含一个HashEntry数组。</p><p>再来看一下HashMap和ConcurrentHashMap在语句上的理解：HashMap它是一个数组+链表，它整个数组上有一个锁，在多线程中会存在锁资源的争夺，但是ConcurrentHashMap它的Segment他是一个数组，每个数组元素空间就是一把锁空间，这个锁空间里存放着HashEntry，而HashEntry则在锁空间里来存放键值对数组。对，就是这样。</p><h3 id="ConcurrentHashMap的初始化"><a href="#ConcurrentHashMap的初始化" class="headerlink" title="ConcurrentHashMap的初始化"></a>ConcurrentHashMap的初始化</h3><p><code>ConcurrentHashMap</code>初始化方法是通过<code>initCapacity</code>，<code>loadFactor</code>和<code>concurrencyLevel</code>等几个参数来初始化<code>segment</code>数组、段偏移量<code>segmentShift</code>、段掩码<code>segmentMask</code>和每一个<code>segment</code>里的<code>HashEntry</code>数组来实现。</p><h4 id="初始化segments数组"><a href="#初始化segments数组" class="headerlink" title="初始化segments数组"></a>初始化segments数组</h4><p>让我们来看一下segment数组的源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(concurrentLevel&gt;MAX_SEGMENT)</span><br><span class="line">  concurrentLevel = MAX_SEGMENT;</span><br><span class="line"><span class="keyword">int</span> sshift=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ssize=<span class="number">1</span>;  <span class="comment">//segment数组长度，也即为容器中锁的个数</span></span><br><span class="line"><span class="keyword">while</span>(ssize&lt;concurrencyLevel)&#123;</span><br><span class="line">  ++sshift;</span><br><span class="line">    ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">this</span>.segment = Segment.newArray(ssize);</span><br></pre></td></tr></table></figure><p> 从上面代码可知，segments数组的长度ssize是通过concurrencyLevel计算出来的。为了能通过按位与的散列算法来定位segments数组的索引，必须保证segments数组的长度是2的N次方，所以必须计算出一个大于或等于concurrencyLevel的最小的2的N次方值来作为segments的数组的长度。假如concurrencyLevel等于14，15或者16，ssize都会等于16，即容器里锁的个数也是16。</p><h4 id="初始化segmentShift和segmentMask"><a href="#初始化segmentShift和segmentMask" class="headerlink" title="初始化segmentShift和segmentMask"></a>初始化segmentShift和segmentMask</h4><p>解释一下这两个全局变量：</p><p><strong>sshift</strong>：等于ssize从1向左移位的次数。在默认情况下，concurrencyLevel=16，需要1向左移位4次，即sshift=4。</p><p><strong>segmentShift：</strong>用于定位参与散列运算的位数。  segmentShift = 32-sshift=28；因为ConcurrentHashMap里的hash()方法输出的最大数为32位。</p><p>segmentMask：是运算散列码运算的掩码。segmentMask=ssize - 1，即15，掩码的二进制各个位的值都是1。因为ssize的最大长度是65536，所以segmentShift最大值为16，segmentMask最大值为65535，对应的二进制是16位，每个位都是1。</p><h4 id="初始化每个segment"><a href="#初始化每个segment" class="headerlink" title="初始化每个segment"></a>初始化每个segment</h4><p> 输入参数initCapacity是ConcurrentHashMap的初始容量，loadFactor是每个segment的负载因子，在构造方法里需要通过这两个参数来初始化数组中的每一个segment。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(initCapacity &gt; MAXIMUM_CAPACITY)&#123;</span><br><span class="line">  initCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">  <span class="keyword">int</span> c=initialCapacity/ssize;</span><br><span class="line">    <span class="keyword">if</span>(c * ssize &lt;initCapacity )</span><br><span class="line">  ++c;</span><br><span class="line">    <span class="keyword">while</span>(cap &lt; c)</span><br><span class="line">       cap &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="keyword">this</span>.segments.length;i++)</span><br><span class="line">       <span class="keyword">this</span>.segment[i]=<span class="keyword">new</span> Segment&lt;K,V&gt;(cap,loadFactor)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中的变量cap就是segment里的HashEntry数组的长度，它等于initCapacity除以ssize的倍数c，若c大于1，就是取大于等于c的2的N次方值，所以cap不是1，就是2的N次方。</p><p>segment的容量threshold=(int) cap * loadFactor，默认情况下initCapacity=16，loadFactor=0.75,通过运算cap等于1，threshold=0。</p><h3 id="定位Segment"><a href="#定位Segment" class="headerlink" title="定位Segment"></a>定位Segment</h3><h2 id="再看ConcurrentHashMap的使用"><a href="#再看ConcurrentHashMap的使用" class="headerlink" title="再看ConcurrentHashMap的使用"></a>再看ConcurrentHashMap的使用</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Java 中的集合框架HashMap 和 ConcurrentHashMap在我几次面试中，都问到了，可见其在考察基础知识中的重要性。今天就
      
    
    </summary>
    
      <category term="Java 并发编程的艺术" scheme="https://StormWangxhu.github.io/categories/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/"/>
    
    
      <category term="分段锁技术" scheme="https://StormWangxhu.github.io/tags/%E5%88%86%E6%AE%B5%E9%94%81%E6%8A%80%E6%9C%AF/"/>
    
      <category term="synchronized" scheme="https://StormWangxhu.github.io/tags/synchronized/"/>
    
  </entry>
  
  <entry>
    <title>拿 递归 来说事儿</title>
    <link href="https://StormWangxhu.github.io/2018/04/13/%E6%8B%BF%20%E9%80%92%E5%BD%92%20%E6%9D%A5%E8%AF%B4%E4%BA%8B%E5%84%BF/"/>
    <id>https://StormWangxhu.github.io/2018/04/13/拿 递归 来说事儿/</id>
    <published>2018-04-12T16:00:00.000Z</published>
    <updated>2018-04-13T03:48:25.665Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>递归，以我目前知道的知识来说，其重要性不言而喻，它在求解最大、最小、最多、最长、最优等动态规划题中应用最为广泛吧。动态规划的精髓就是在递归和加缓存上。那么，今天就初步了解一下递归，到底递的是什么归（“鬼”）~。</p><h2 id="递归是什么"><a href="#递归是什么" class="headerlink" title="递归是什么"></a>递归是什么</h2><p>递归的定义：它是什么？</p><p>在书上其定义是这样的：通过简化问题规模来解决问题的方法称为递归。简化规模到底是怎么简化的，后文中将会说到。在数学中，递归定义是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>!=<span class="number">1</span>   (n=<span class="number">0</span>)    <span class="comment">//基本公式</span></span><br><span class="line">n!=n*(n-<span class="number">1</span>)!  (n&gt;<span class="number">0</span>)    <span class="comment">//递归公式 ，也叫一般公式</span></span><br></pre></td></tr></table></figure><p>即当n是一个大于0的整数时，我们先计算<code>(n-1)!</code> ，再将其与<code>n</code> 相乘。要计算出<code>(n-1)!</code> ，应该就再应用一次定义，以此类推。</p><p>一个递归如上面所示，有一个基本公式和一个递归公式，他们有以下的关系：</p><ul><li>每个递归定义都必须包含一个或多个基本公式。</li><li>一般公式最后必须简化为基本公式。</li><li>基本公式可结束递归。</li></ul><p>再看几个概念：</p><p><strong>递归算法：</strong> 通过将问题简化为比自身更小的形式来得到问题的解的算法称为递归算法。递归算法使用递归方法来实现。</p><p><strong>递归方法：</strong> 调用自身的方法称为递归方法。首先来一个阶乘的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fact</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (num==<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> num*fact(num-<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>那么在递归方法执行的过程中，有什么注意点呢？</p><ul><li>在逻辑上，递归方法可以无限的调用自身。</li><li>每个递归方法的调用—–也就是每一个递归调用——都有自己的代码、参数和局部变量。</li><li>在完成一个递归调用后，控制权会返回前一个调用的调用环境。当前（递归）调用必须在控制权返回上一个调用前执行完毕。前一个调用在递归调用返回后立即执行。</li></ul><p>知道了递归的这些知识后，我们便可以利用递归来解决一些问题，这些问题使用递归都有套路。也就说，递归要解决的问题，在使用递归时，有套路或者模板可循。</p><h2 id="使用递归解决问题"><a href="#使用递归解决问题" class="headerlink" title="使用递归解决问题"></a>使用递归解决问题</h2><h3 id="求数组中的最大元素"><a href="#求数组中的最大元素" class="headerlink" title="求数组中的最大元素"></a>求数组中的最大元素</h3><p>我们给定一个数组，求该数组中的最大或最小元素，那么这个问题便可以用递归来解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] list=&#123;<span class="number">11</span>,<span class="number">32</span>,<span class="number">54</span>,<span class="number">98</span>,<span class="number">45</span>&#125;;</span><br></pre></td></tr></table></figure><p>假如有以上数组，要求改数组中的最大元素。我们可以这样来考虑：在数组中元素等于1时，即为最大元素。当数组元素大小大于1时，我们先取出第一个元素，在剩余的list[1]到list[4]中进行比较，比较出最大元素，再与list[0] 进行比较，返回最大元素。依次类推。在每次使用上面的公式在子表中寻找最大元素后，下一个调用中的子表长度就会减1。最后的子表长度会变为1，即子表只包含一个元素，这个元素也就是子表中最大的元素。从此再向前，通过递归调用原路返回。</p><p>我们设计一个方法，有三个参数，第一个参数为要比较的数组，第二个参数为数组第一个元素位置参数，第三个元素为数组最后一个元素位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxNumber</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lowerIndex, <span class="keyword">int</span> upperIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max;</span><br><span class="line">        <span class="keyword">if</span> (lowerIndex == upperIndex) &#123;<span class="comment">//数组中只有一个元素，也就是最大值了</span></span><br><span class="line">            <span class="keyword">return</span> nums[lowerIndex];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            max = maxNumber(nums, lowerIndex + <span class="number">1</span>, upperIndex);<span class="comment">//递归调用</span></span><br><span class="line">            <span class="keyword">if</span> (nums[lowerIndex] &gt;= max)  <span class="comment">//寻找最大值</span></span><br><span class="line">                <span class="keyword">return</span> nums[lowerIndex];</span><br><span class="line">            <span class="keyword">return</span> max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>没错，就是上面这个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归解决数组中求最大元素。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">11</span>,<span class="number">32</span>,<span class="number">54</span>,<span class="number">98</span>,<span class="number">45</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> max = maxNumber(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">        System.out.println(max);</span><br><span class="line">        <span class="comment">//System.out.println(fact(5));</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxNumber</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lowerIndex, <span class="keyword">int</span> upperIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max;</span><br><span class="line">        <span class="keyword">if</span> (lowerIndex == upperIndex) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[lowerIndex];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            max = maxNumber(nums, lowerIndex + <span class="number">1</span>, upperIndex);</span><br><span class="line">            <span class="keyword">if</span> (nums[lowerIndex] &gt;= max)</span><br><span class="line">                <span class="keyword">return</span> nums[lowerIndex];</span><br><span class="line">            <span class="keyword">return</span> max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看一下输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">98</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;递归，以我目前知道的知识来说，其重要性不言而喻，它在求解最大、最小、最多、最长、最优等动态规划题中应用最为广泛吧。动态规划的精髓就是在递归和
      
    
    </summary>
    
      <category term="（第二部分）数据结构和设计模式" scheme="https://StormWangxhu.github.io/categories/%EF%BC%88%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="数据结构" scheme="https://StormWangxhu.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="设计模式" scheme="https://StormWangxhu.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>初解 HashMap 源码（二）</title>
    <link href="https://StormWangxhu.github.io/2018/04/11/%E5%88%9D%E8%A7%A3-HashMap-%E6%BA%90%E7%A0%81%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://StormWangxhu.github.io/2018/04/11/初解-HashMap-源码（二）/</id>
    <published>2018-04-10T16:00:00.000Z</published>
    <updated>2018-04-11T07:44:54.607Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>你的努力终将会有回报，路漫漫其修远兮，吾将上下而求索！</p></blockquote><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;你的努力终将会有回报，路漫漫其修远兮，吾将上下而求索！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;
      
    
    </summary>
    
      <category term="打怪升级之源码解析系列" scheme="https://StormWangxhu.github.io/categories/%E6%89%93%E6%80%AA%E5%8D%87%E7%BA%A7%E4%B9%8B%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="HashMap源码" scheme="https://StormWangxhu.github.io/tags/HashMap%E6%BA%90%E7%A0%81/"/>
    
      <category term="集合框架源码阅读" scheme="https://StormWangxhu.github.io/tags/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Java 开源</title>
    <link href="https://StormWangxhu.github.io/2018/04/11/Java-%E5%BC%80%E6%BA%90/"/>
    <id>https://StormWangxhu.github.io/2018/04/11/Java-开源/</id>
    <published>2018-04-10T16:00:00.000Z</published>
    <updated>2018-04-11T15:13:52.817Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="（第四部分）Java 开源" scheme="https://StormWangxhu.github.io/categories/%EF%BC%88%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86%EF%BC%89Java-%E5%BC%80%E6%BA%90/"/>
    
    
  </entry>
  
  <entry>
    <title>初解 HashMap 源码准备（一）</title>
    <link href="https://StormWangxhu.github.io/2018/04/11/%E5%88%9D%E8%A7%A3-HashMap-%E6%BA%90%E7%A0%81%E5%87%86%E5%A4%87%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://StormWangxhu.github.io/2018/04/11/初解-HashMap-源码准备（一）/</id>
    <published>2018-04-10T16:00:00.000Z</published>
    <updated>2018-04-11T07:42:31.482Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>你的努力终将会有回报，路漫漫其修远兮，吾将上下而求索！</p></blockquote><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>经过了<a href="https://stormwangxhu.github.io/2018/03/30/30--%E8%AE%B0%E5%A4%B4%E6%9D%A1Java%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%9D%A2/">头条</a> 和<a href="https://stormwangxhu.github.io/2018/04/10/%E8%AE%B0%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4-Java-%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%9D%A2/">阿里巴巴</a> 的两次面试后,虽然两次都挂在了一面,但对于大二的我也非常有收获。每次面试都对自己有了更清晰的认识，对要学的东西也变的更清楚。比如现在还停留在 Java 这门语言的层面，还有数据结构、算法、计算机原理、操作系统等知识都还没有学习，记得阿里面试官问我，还有哪些技能吗？我想了想，也只能说现在在学习语言，其他的还没有开始学习。说完后，也略觉尴尬。还有便是基础的重要性了，一面大都会问基础知识，基础知识掌握不牢固，感觉即使后面的知识学的可以，也有可能被挡在一面这道门槛上。所以下定决心回头看基础，从两次都问到的HashMap源码阅读开始。只希望我们都可以知其然，知其所以然。</p><p>本篇博客，作为初试<code>HashMap</code> 源码阅读的开端章。将介绍一下相关概念。</p><h2 id="Map相关"><a href="#Map相关" class="headerlink" title="Map相关"></a>Map相关</h2><h3 id="Map接口及其实现"><a href="#Map接口及其实现" class="headerlink" title="Map接口及其实现"></a>Map接口及其实现</h3><p><img src="https://blog.yangx.site/images/HashMap.png" alt="âHashMapå¾âçå¾çæç´¢ç»æ"></p><p>从上图可以看出，<code>HashMap</code> 它继承类<code>AbstractMap</code> ，实现了3个接口<code>Map</code> ，<code>Serializable</code> ,<code>Cloneable</code> ，我们也可以从源码中看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...暂时省略源码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们只需要知道接口它分别提供了什么功能即可：<code>Serializable</code> 接口提供序列化、<code>Cloneable</code> 提供克隆方法、<code>Map</code> 提供关于<code>Map</code> 集合一些操作的方法，如：<code>get、put</code> 方法等。其中类<code>AbstractMap</code> 它实现了一些<code>Map</code> 接口中的一些方法，自己也提供了一些方法。</p><h3 id="散列与散列码"><a href="#散列与散列码" class="headerlink" title="散列与散列码"></a>散列与散列码</h3><h3 id="hashCode-和equlas-方法解读"><a href="#hashCode-和equlas-方法解读" class="headerlink" title="hashCode()和equlas()方法解读"></a>hashCode()和equlas()方法解读</h3><h3 id="初看HashMap性能因子"><a href="#初看HashMap性能因子" class="headerlink" title="初看HashMap性能因子"></a>初看HashMap性能因子</h3><h4 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h4><p>容量：即表中的桶位数。</p><h4 id="初始容量"><a href="#初始容量" class="headerlink" title="初始容量"></a>初始容量</h4><p>初始容量：表在创建时所拥有的桶位数，HashMap和HashSet都具有允许你指定初始容量的构造器。</p><h4 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h4><p>尺寸：表中当前存储的项数。</p><h4 id="负载因子"><a href="#负载因子" class="headerlink" title="负载因子"></a>负载因子</h4><p>负载因子：记住这个公式：<strong>负载因子=尺寸/容量</strong> 。空表的负载因子为0，半满表的负载因子是0.5，以此类推。负载轻的表产生冲突的可能性小，因此对于插入和查找都是最理想的（但是会减慢使用迭代器进行遍历的过程）。HashMap和HashSet都具有允许你指定负载因子的构造器，表示当负载因子情况达到该负载因子的水平时，容器将会自动增加其容量（桶位数），实现方式是使容量大致加倍，并重新将现有对象分布到新的桶位集中（这被称为<em>再散列</em>）。</p><p>若知道将要在HashMap中存储多少项，那么创建一个具有恰当大小的初始容量将可以避免再散列的开销。</p><h3 id="数组简介"><a href="#数组简介" class="headerlink" title="数组简介"></a>数组简介</h3><p>数组？什么是数组，相信数组大家已经非常熟悉，那么在学习完了JVM运行时数据区域后，我们就应该载来认识一下数组在内存中是怎么样分配的？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>当我们<code>new</code> 一个数组时，那么在Java运行时区域的<strong>堆内存</strong>中，便会分配出一块内存，并返回该对象的引用。</p><p><img src="http://images2015.cnblogs.com/blog/879896/201605/879896-20160513152924249-1835974754.jpg" alt="img"></p><p>那么二维数组呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> [][] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][];</span><br></pre></td></tr></table></figure><p>在大一时学习C语言的二维数组时说到其实二维数组也是一维数组。到底什么意思呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">array[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">array[<span class="number">2</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br></pre></td></tr></table></figure><p>二维数组其实是这样的：</p><p><img src="http://images2015.cnblogs.com/blog/879896/201605/879896-20160513153325593-1852958590.jpg" alt="img"></p><p>在Java中，数组也是一个对象，堆内存中怎样存放对象，也就怎么样存放数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    m2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     A a = <span class="keyword">new</span> A();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看这段代码，首先执行方法<code>m1()</code> ,在上几篇博文中讲到：“虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行时都会创建一个栈帧（Stack Frame），用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。单线程下有错误时会抛出<code>StackOverFlowError</code> ，多线程下会抛出<code>OutOfMemoryError</code> 。” 详情：<a href="https://stormwangxhu.github.io/2018/04/06/%EF%BC%88%E4%BA%8C%EF%BC%89%E5%88%9D%E6%8E%A2-JVM-%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/">（二）初探JVM 内存解构</a> </p><p>现在来看看上述代码执行都发生了什么？</p><p>首先，在执行方法<code>m1</code> 时，就会在VM栈中创建一个栈帧，在局部变量表中存储变量<code>i</code> ,将其栈帧压入进栈中，然后执行<code>m2</code> 方法，又创建栈帧<code>Frame-2</code> ，栈帧<code>Frame-2</code> 被创建并<code>push</code> 到栈中，在<code>m2</code> 方法中，一个新的对象A在堆中被创建，而它的引用则被<code>put</code> 到栈帧<code>Frame-2</code> 里；</p><p><img src="http://images2015.cnblogs.com/blog/879896/201605/879896-20160513155235359-1362682773.jpg" alt="img"></p><h3 id="单向链表简介"><a href="#单向链表简介" class="headerlink" title="单向链表简介"></a>单向链表简介</h3><p><img src="http://images0.cnblogs.com/blog/641601/201508/262042454228505.png" alt="âjava åé¾è¡¨å¾çâçå¾çæç´¢ç»æ"></p><p>链表，是什么？链表是一组元素的集合，这些元素被称为节点（node），每个节点（除最后一个节点外）都包含了下一节点的地址。因此，链表中的每个节点都有两个字段：一个拿来存储相关信息，一个存储下一个节点的地址，称为链。链表中第一个节点的地址存储在一个单独的节点中，该节点称为头节点或首节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> K key;  </span><br><span class="line">    <span class="keyword">private</span> V value;  </span><br><span class="line">    <span class="keyword">private</span> Node&lt;K, V&gt; next;<span class="comment">//存放地址  </span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V value, Node&lt;K, V&gt; next)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.key = key;  </span><br><span class="line">        <span class="keyword">this</span>.value = value;  </span><br><span class="line">        <span class="keyword">this</span>.next = next;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> key;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node&lt;K, V&gt; <span class="title">getNext</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> next;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Node&lt;K, V&gt; next)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.next = next;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://my.csdn.net/uploads/201205/15/1337089390_5490.jpg" alt="âjava åé¾è¡¨å¾çâçå¾çæç´¢ç»æ"></p><h3 id="红黑树简介"><a href="#红黑树简介" class="headerlink" title="红黑树简介"></a>红黑树简介</h3><p>R-B Tree，全称是Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。</p><h4 id="红黑树特性"><a href="#红黑树特性" class="headerlink" title="红黑树特性"></a>红黑树特性</h4><p><strong>（1）每个节点或者是黑色，或者是红色。</strong><br><strong>（2）根节点是黑色。</strong><br><strong>（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]</strong><br><strong>（4）如果一个节点是红色的，则它的子节点必须是黑色的。</strong><br><strong>（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</strong></p><p>示意图如下：</p><p><img src="https://images0.cnblogs.com/i/497634/201403/251730074203156.jpg" alt="img"></p><p>红黑树的应用比较广泛，主要是用它来存储有序的数据，它的时间复杂度是O(lgn)，效率非常之高。<br>例如，Java集合中的<code>TreeSet</code> 和<code>TreeMap</code> ，C++ STL中的set、map，以及Linux虚拟内存的管理，都是通过红黑树去实现的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>主要学习了HashMap学习所需要的一些常识知识，因为在后面博文中我们会用到这些知识？HashMap内部到底有着怎么样的秘密？很期待~~~。</p><p><img src="https://4.bp.blogspot.com/-qWRZSkyBDGc/V6M41S237DI/AAAAAAAAGxQ/xKS9RMu57tAsLHPFzw7JfSTq6tLoBvIjACLcB/w1200-h630-p-k-no-nu/How%2Bdoes%2BHashMap%2Bworks%2Bin%2BJava%2B8.jpg" alt="âHashMapå¾âçå¾çæç´¢ç»æ"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;你的努力终将会有回报，路漫漫其修远兮，吾将上下而求索！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="打怪升级之源码解析系列" scheme="https://StormWangxhu.github.io/categories/%E6%89%93%E6%80%AA%E5%8D%87%E7%BA%A7%E4%B9%8B%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="HashMap源码" scheme="https://StormWangxhu.github.io/tags/HashMap%E6%BA%90%E7%A0%81/"/>
    
      <category term="集合框架源码阅读" scheme="https://StormWangxhu.github.io/tags/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>操作系统、数据库、网络</title>
    <link href="https://StormWangxhu.github.io/2018/04/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%81%E7%BD%91%E7%BB%9C/"/>
    <id>https://StormWangxhu.github.io/2018/04/11/操作系统、数据库、网络/</id>
    <published>2018-04-10T16:00:00.000Z</published>
    <updated>2018-04-11T15:14:09.665Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="（第三部分）操作系统、数据库、网络" scheme="https://StormWangxhu.github.io/categories/%EF%BC%88%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%EF%BC%89%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%81%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="操作系统" scheme="https://StormWangxhu.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="数据库" scheme="https://StormWangxhu.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="网路" scheme="https://StormWangxhu.github.io/tags/%E7%BD%91%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>Java 程序设计</title>
    <link href="https://StormWangxhu.github.io/2018/04/11/Java-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>https://StormWangxhu.github.io/2018/04/11/Java-程序设计/</id>
    <published>2018-04-10T16:00:00.000Z</published>
    <updated>2018-04-11T15:14:31.049Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="（第一部分）Java 程序设计" scheme="https://StormWangxhu.github.io/categories/%EF%BC%88%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%89Java-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>记阿里巴巴 Java 实习第一面</title>
    <link href="https://StormWangxhu.github.io/2018/04/10/%E8%AE%B0%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4-Java-%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%9D%A2/"/>
    <id>https://StormWangxhu.github.io/2018/04/10/记阿里巴巴-Java-实习第一面/</id>
    <published>2018-04-09T16:00:00.000Z</published>
    <updated>2018-04-11T03:44:40.514Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我看好自己的认真！</p></blockquote><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>炎热的下午，刚在体育课上测完了一千米，嗓子要着火了，跑完后感觉要膨胀了，又测了50、身高、肺活量、体前屈。测完后就在树荫下休息，离下课还有10分钟的时候，口袋里的手机突然想起，拿起一看，阿里巴巴集团，当时就意识到可能是要和我商量面试时间，但接了后，却和其他公司不一样，面试官直接就问我，有时间吗？我们简单面试一下。我看了看体育老师，过去请了个假，就赶紧去一边面试了，不知道为什么声音很小，我有点儿听不清，好几次就请求面试官：“不好意思呢，刚才没听清，嘻嘻~”挺尴尬的。面试了34分钟。我到现在有的问题都忘了，大体内容如下：</p><h2 id="面试内容"><a href="#面试内容" class="headerlink" title="面试内容"></a>面试内容</h2><p>1、自我介绍：balabala</p><p>2、现在都学习了些什么？balabala</p><p>3、HashMap底层实现原理，是否读过HashMap源码？</p><p>4、HashMap和ConcurrentHashMap在线程安全上有何区别？如何实现？</p><p>5、项目：小程序。问到遇到什么问题吗？在这里问了好多，还有业务逻辑，感觉答得都不是太好。</p><p>6、了解过哪些中间件？</p><p>7、Java 的特性？</p><p>8、Java 内存模型</p><p>9、JVM 类加载机制</p><p>10、双亲委派模型</p><p>11、Object都有哪些方法？</p><p>12、高并发、高并发、高并发！重要的说三遍。如何解决？答得不太好，一脸懵逼！</p><p>13、锁优化CAS</p><p>14、sychronized和volitile</p><p>15、反射的使用场景？很重要，我没怎么说上来。下来后回想感觉应该和框架（Spring）还有关系,以后学习得注意点。</p><p>16、还问了我的英语怎么样？考六级了吗</p><p>17、在Github上关注了什么开源项目了没？</p><p>18、看了我的博客（挺开心的，感觉博客搭建上还是挺好的），问我是自学吗？一般怎么学？</p><p>19、了解Linux吗？确实没咋用，就说了知道几个命令。</p><p>20、觉得自己是一个怎样的人？</p><p>21、又想起来了，还问到了异常？并解释为什么？</p><p>大概就这些吧，有些记不起来了，最后也没像头条面试官一样，问我有什么问题要问吗？就说那就今天先面试到这儿，我说了声谢谢。哦，对了，开头自我介绍前，还问我什么时候可以来实习，能实习多长时间？然后就没了，大厂面试就这样结束了。不知道结果会怎么样，以我现在的知识，估计也去不了，还得继续加油努力呢！路漫漫其修远兮，吾将上下而求索！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;我看好自己的认真！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;炎热的下午，刚在体育课上测完了一千米，嗓子
      
    
    </summary>
    
      <category term="总结" scheme="https://StormWangxhu.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="实习" scheme="https://StormWangxhu.github.io/tags/%E5%AE%9E%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>（五）再看 JVM 的类加载机制</title>
    <link href="https://StormWangxhu.github.io/2018/04/09/%EF%BC%88%E4%BA%94%EF%BC%89%E5%86%8D%E7%9C%8B-JVM-%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>https://StormWangxhu.github.io/2018/04/09/（五）再看-JVM-的类加载机制/</id>
    <published>2018-04-08T16:00:00.000Z</published>
    <updated>2018-04-11T14:59:28.782Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>你的努力终将会有回报，路漫漫其修远兮，吾将上下而求索！</p></blockquote><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在这篇中，我们再谈 JVM 的编译常量、<code>ClassLoader</code> 、和系统类加载器。通过代码实例来理解掌握三者的奥秘。请带上你的好奇心哦~</p><h2 id="编译常量和变量与初始化"><a href="#编译常量和变量与初始化" class="headerlink" title="编译常量和变量与初始化"></a>编译常量和变量与初始化</h2><p>关于static和final变量对类的初始化到底有什么影响，他们的使用也是面试中经常的考点。首先来看一道程序：</p><p><code>example1</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> stormwangxhu.example;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FianlTest</span></span>&#123;</span><br><span class="line">  <span class="comment">//x是一个编译时常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> x =<span class="number">6</span>/<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"FinalTest static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticAndFinalTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(FianlTest.x);<span class="comment">// x=2。static代码块没有执行。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>example2</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> stormwangxhu.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FianlTest2</span></span>&#123;</span><br><span class="line">  <span class="comment">//注意此处，x是编译时变量，即在运行时才能确定x的值。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> x = <span class="keyword">new</span> Random().nextInt(<span class="number">100</span>);<span class="comment">//产生一个0到99的随机数</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"FinalTest2 static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticAndFianlTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(FianlTest2.x);</span><br><span class="line">      <span class="comment">//FinalTest2 static block       先执行static代码块</span></span><br><span class="line">      <span class="comment">//43(每次执行不一样)             后执行编译变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，程序的输出是不是出乎你的意料呢，当<code>static</code>和<code>final</code> 修饰的是一个编译时常量时，那么其在初始化阶段就已经确定。所以其初始化将按顺序进行初始化。而对于编译时变量，在初始化阶段并不能确定其具体的值，所以初始化阶段会先初始化类变量，再在程序运行期间进行编译变量的执行。</p><h2 id="再看类初始化"><a href="#再看类初始化" class="headerlink" title="再看类初始化"></a>再看类初始化</h2><h3 id="初始化子类"><a href="#初始化子类" class="headerlink" title="初始化子类"></a>初始化子类</h3><p>在第一篇博文中我很清楚自己这样写道：<strong>当Java 虚拟机初始化一个类时，要求其父类必须先被初始化</strong>，但是这条规则不适用于接口。那么对于这句话我们来看一个实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> stormwangxhu.example;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a =<span class="number">3</span> ;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Parent static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b =<span class="number">4</span> ;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Child static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"StaticTest1 static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Child.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这道题的答案是多少呢？若你理解了那句话，答案会很快知晓：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StaticTest1 <span class="keyword">static</span> block</span><br><span class="line">Parent <span class="keyword">static</span> block</span><br><span class="line">Child <span class="keyword">static</span> block</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p>还有，当一个类的父类被同一个加载器加载过后，便不会再去加载这个类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> stormwangxhu.example;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a =<span class="number">3</span> ;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Parent static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b =<span class="number">4</span> ;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Child static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"StaticTest1 static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"-----------------------------------------"</span>);</span><br><span class="line">        System.out.println(Parent.a);</span><br><span class="line">        System.out.println(Child.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，这样又会输出什么呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">StaticTest1 <span class="keyword">static</span> block</span><br><span class="line">-----------------------------------------</span><br><span class="line">Parent <span class="keyword">static</span> block</span><br><span class="line"><span class="number">3</span></span><br><span class="line">Child <span class="keyword">static</span> block</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p>为什么会输出这样呢？因为同一个类加载器对加载过的父类若已经加载过，则不再进行加载。但是若是两个不同的类加载器则依旧会执行。</p><p>因此我们得出结论：程序中对子类的主动使用，会导致父类被初始化；但对父类的主动使用并不会导致子类初始化。一个最简单明了的例子就是：不可能说生成一个Object 对象就导致系统中所有子类都会被初始化。</p><h3 id="再谈类的主动使用"><a href="#再谈类的主动使用" class="headerlink" title="再谈类的主动使用"></a>再谈类的主动使用</h3><p>首先我们说明结论：<strong>只有当程序访问的静态变量或静态方法确实在当前类或当前接口中定义时，才可以认为是对类或接口的主动使用</strong>。</p><p>什么意思呢？我们来看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> stormwangxhu.example;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">  <span class="comment">//静态变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a =<span class="number">3</span> ;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Parent static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do something"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b =<span class="number">4</span> ;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Child static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticTest1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"StaticTest1 static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Child.a);</span><br><span class="line">        Child.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StaticTest1 <span class="keyword">static</span> block</span><br><span class="line">Parent <span class="keyword">static</span> block</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="keyword">do</span> something</span><br></pre></td></tr></table></figure><p>从结果可以看出，根本就没执行<code>Child</code> ，也就意外根本没有初始化。我们再来理解给出的结论，类变量<code>a</code> 它是在类中定义的，静态方法<code>doSometing()</code> 也是在父类中定义的，所以用子类打印出<code>a</code> 的值，就不是对子类的一个主动使用，而是对父类的一个<strong>主动使用</strong>。</p><h2 id="再谈类加载ClassLoader"><a href="#再谈类加载ClassLoader" class="headerlink" title="再谈类加载ClassLoader"></a>再谈类加载ClassLoader</h2><p>结论：调用ClassLoader类的loadClass方法加载一个类，并不是对类的主动使用，不会导致类的初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> stormwangxhu.example;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CL</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Class CL"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassLoader classLoader=ClassLoader.getSystemClassLoader();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; clazz=classLoader.loadClass(<span class="string">"stormwangxhu.example.CL"</span>);<span class="comment">//不会导致初始化</span></span><br><span class="line">            System.out.println(<span class="string">"------------------------------------"</span>);</span><br><span class="line">            clazz=Class.forName(<span class="string">"stormwangxhu.example.CL"</span>);<span class="comment">//反射，会导致类的初始化</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">------------------------------------</span><br><span class="line">Class CL</span><br></pre></td></tr></table></figure><p>也就是主动使用除了6种情况下会导致类的主动使用而被初始化，其他的都不会导致类的初始化。</p><h2 id="深解双亲委托机制"><a href="#深解双亲委托机制" class="headerlink" title="深解双亲委托机制"></a>深解双亲委托机制</h2><p><img src="http://blog.stormma.me/2017/11/14/%E4%B8%80%E7%82%B9%E4%B8%80%E6%BB%B4%E6%8E%A2%E7%A9%B6JVM%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/loader.png" alt="ç±»å è½½å¨çå±æ¬¡å³ç³»"></p><h3 id="根类加载器"><a href="#根类加载器" class="headerlink" title="根类加载器"></a>根类加载器</h3><p>该加载器无父类加载器，实现依赖于底层操作系统，属于虚拟机的一部分，并没有继承<code>java.lang.ClassLoader</code> 。负责加载虚拟机的核心类库，如java.lang.*等。</p><h3 id="拓展类加载器"><a href="#拓展类加载器" class="headerlink" title="拓展类加载器"></a>拓展类加载器</h3><p>加载拓展API</p><h3 id="系统类加载器"><a href="#系统类加载器" class="headerlink" title="系统类加载器"></a>系统类加载器</h3><p>加载<code>CLASSPATH</code>路径下定义的<code>Class</code>。</p><h3 id="ClassLoader加载流程"><a href="#ClassLoader加载流程" class="headerlink" title="ClassLoader加载流程"></a>ClassLoader加载流程</h3><p>所以一个程序启动时，是怎么加载的呢？我们一起来看看：</p><p>当运行一个Java程序的时候，JVM 启动，运行启动类加载器，该加载器（<code>ClassLoader</code>）加载核心的API（拓展类加载器和系统类加载器也在此时被加载），然后调用拓展类加载器加载拓展API，最后系统类加载器加载CLASSPATH目录下定义的Class。以上就是一个程序最基本的加载流程。</p><p>再看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class <span class="title">loadClass</span><span class="params">(String name ,<span class="keyword">boolean</span> resolve)</span></span>&#123;</span><br><span class="line">       <span class="comment">//首先检查该name指定的class是否被加载</span></span><br><span class="line">       Class c=findLoadedClass(name);</span><br><span class="line">       <span class="keyword">if</span> (c==<span class="keyword">null</span>)&#123;<span class="comment">//c为空，说明该类没有被加载过</span></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (parent!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                   <span class="comment">//若parent不为null，则调用parent的loadClass进行加载</span></span><br><span class="line">                   c=parent.laodClass(name,<span class="keyword">false</span>);</span><br><span class="line">               &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">//parent为null，则调用启动类加载器进行加载</span></span><br><span class="line">                   c=findBootstarpClass0(name);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;<span class="keyword">catch</span> (ClassNotFoundException e)&#123;</span><br><span class="line">               <span class="comment">//若仍然无法加载成功，则调用自身的findClass进行加载</span></span><br><span class="line">               c=findClass(name);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (resolve)&#123;</span><br><span class="line">           resolveClass(c);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> c;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>以上可以看出一个类的加载使用了双亲委托模式。</p><h3 id="为什么要使用双亲委托模型"><a href="#为什么要使用双亲委托模型" class="headerlink" title="为什么要使用双亲委托模型"></a>为什么要使用双亲委托模型</h3><p><strong>我们为什么要使用双亲委托模型呢</strong>？记得阿里第一面就问我，我当时表达不出来。</p><p>原因一：可以<strong>避免重复加载</strong>，当父类已经加载了该类的时候，就没有必要子<code>ClassLoader</code> 再加载一次</p><p>原因二：考虑到<strong>安全因素</strong>，若不使用这种委托模式，那么可以随时用自定义得<code>String</code> 来动态替代<code>Java</code>核心<code>API</code> 中定义的类型，这样会存在非常大的隐患，而父类委托的方式就可以避免这种情况，因为<code>String</code> 已经在启动时被加载，所以， 用户自定义是无法加载一个自定义的<code>ClassLoader</code></p><h3 id="ClassLoader一些重要方法"><a href="#ClassLoader一些重要方法" class="headerlink" title="ClassLoader一些重要方法"></a>ClassLoader一些重要方法</h3><h4 id="loadClass方法"><a href="#loadClass方法" class="headerlink" title="loadClass方法"></a>loadClass方法</h4><p><code>ClassLoader.loadClass()</code> 是<code>ClassLoader</code> 的入口点。定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Class <span class="title">loadClass</span><span class="params">(String name,<span class="keyword">boolean</span> resolve)</span></span>;</span><br></pre></td></tr></table></figure><p>1、<code>name</code> 是JVM需要的类的名称，如：<code>java.lang.Object</code> 。</p><p>2、<code>resolve</code> 参数告诉方法是否需要解析类。在准备执行该类前，应该考虑解析。注意：并不总是需要解析，如果JVM只需要知道该类是否存在或找出该类的超类，那就不需要解析。</p><h4 id="findClass方法"><a href="#findClass方法" class="headerlink" title="findClass方法"></a>findClass方法</h4><p><code>loadClass</code> 默认实现调用这个新方法。<code>findClass</code>的用途包含<code>ClassLoader</code> 的所有特殊代码，而不须复制其他代码（例如：当专门的方法失败时，调用系统的<code>ClassLoader</code>）</p><p>目的是：从本地文件系统使用实现的类加载器加载一个类。为了创建自己的类加载器，应该拓展<code>ClassLoader</code>类，这是一个抽象类。可以创建一个<code>FileClassLoader extends ClassLoader</code>，然后覆盖<code>ClassLoader</code>中的<code>findClass(String name)</code>方法，这个方法通过类名得到一个<code>Class</code>对象。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">findClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">byte</span>[] date =loadClassData(name);</span><br><span class="line">  <span class="keyword">return</span> defineClass(name,data,<span class="number">0</span>,data.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="defineClass方法"><a href="#defineClass方法" class="headerlink" title="defineClass方法"></a>defineClass方法</h4><p><code>defineClass</code>方法接受由原始字节组成的数组，并把它转换成<code>Class</code>对象。原始数组包含从文件系统或网络装入的数据。<code>defineClass</code>管理JVM的许多复杂的实现层面——它把字节码分析成运行时数据结构。检验有效行等。因为<code>defineClass</code>方法被标记为<code>final</code>，所以不能覆盖它。</p><h4 id="forName方法"><a href="#forName方法" class="headerlink" title="forName方法"></a>forName方法</h4><p>Class类中有一个静态方forName，这个方法和ClassLoader中的loadClass方法目的一样，都是用来加载class的，但是两者在作用上有所区别。</p><p><strong>先来看看看forName()方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"something"</span>);</span><br></pre></td></tr></table></figure><p> 或者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader c1 =Thread.currentThread().getContextClassLoader();</span><br><span class="line">Class clazz= c1.loadClass(<span class="string">"something"</span>);</span><br></pre></td></tr></table></figure><p><code>Class.forName()</code>调用<code>Class.forName(name,initialize,loader);</code> 也就是<code>Class.forName(&quot;something&quot;)</code> 等同于<code>Class.forName(&quot;something&quot;,true,CALLCLASS.class.getClassLoader());</code> 。</p><p>解释：</p><p>第二个参数”true”，用于设置加载类时是否连接该类，即加载中的连接阶段，true就连接，否则就不连接。</p><p><strong>再看看loadClass()方法：</strong>        </p><p>loadClass方法定义是protected，也就是说，该方法是被保护的，而用户使用的方法是一个参数，一个参数的loadClass方法实际上就时调用了两个参数，第二个参数默认是false。因此，在这里可以看出通过loadClass加载类实际上就是加载的时候并不对该类解析  因此不会初始化该类。而Class的forName方法则相反，使用forName加载的时候就会将Class进行解析和初始化。</p><h2 id="你知道JVM-使用什么字符吗？"><a href="#你知道JVM-使用什么字符吗？" class="headerlink" title="你知道JVM 使用什么字符吗？"></a>你知道JVM 使用什么字符吗？</h2><p>答案是：Unicode characters</p><p>java开发者必须牢记：在java中字符只以一种形式存在，那就是Unicode（不选则任何特定的编码，直接使用它们在字符集中的编号，这就是统一的唯一的方式）。</p><p>那么“在java中”到底是指哪里呢？是指在JVM中、在内存中、在我们写的代码里声明的每一个char、String类型的变量中。</p><p>JVM 这种的约定使得一个字符分为两部分：JVM 内部和OS 的文件系统。在JVM 内部，统一使用Unicode表示，当这个字符被从JVM 内部移动到外部（即保存为文件系统中的一个文件内容时），就进行了编码转换，使用了具体的编码方案。因此可以说，所有的编码转换只发生在边界的地方，JVM 和 OS的交界处，也就是各种输入/输出流（或者Reader，Writer类）起作用的地方。</p><p>Windows中默认字符是GBK，在面向字符流时，Reader和Writer只会使用这个默认的编码来转换，而不能为一个Reader和Writer指定转换时使用的编码。这意外着，若使用中文版Windows系统，其中存放了一个UTF-8编码的文件，当采用Reader类读入的时候，他还会使用GBK来转换，转换后内容当然不对！所以在需要GBK以外的编码时，就必须采用编码转换：一个字符与字节之间的转换。因此I/O系统中能够指定转换编码的地方，也就是字符和字节转换的地方。那就是InputStreamReader 和OutputStreamWriter。这两个类是字节流和字符流之间的适配器，他们承担着编码转换的地方。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;你的努力终将会有回报，路漫漫其修远兮，吾将上下而求索！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="深入理解Java虚拟机" scheme="https://StormWangxhu.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM 类加载机制" scheme="https://StormWangxhu.github.io/tags/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    
      <category term="ClassLoader" scheme="https://StormWangxhu.github.io/tags/ClassLoader/"/>
    
  </entry>
  
  <entry>
    <title>（四）初探 JVM 垃圾收集器和内存分配策略</title>
    <link href="https://StormWangxhu.github.io/2018/04/08/%EF%BC%88%E5%9B%9B%EF%BC%89%E5%88%9D%E6%8E%A2-JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
    <id>https://StormWangxhu.github.io/2018/04/08/（四）初探-JVM-垃圾收集器和内存分配策略/</id>
    <published>2018-04-07T16:00:00.000Z</published>
    <updated>2018-04-08T07:26:17.573Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>你的努力终将会有回报，路漫漫其修远兮，吾将上下而求索！</p></blockquote><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>Java 与 C++ 之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人想出来。</p></blockquote><p>本篇博文主要输出JVM的常见垃圾回收算法（也就是面试官长问到的GC），以及在 JVM 虚拟机中，JVM 是如何判断对象的有效性、对象在内存中是按照什么规则存放的，请带上你的好奇心慢慢往下读。</p><p>在JVM内存区域中，属于线程私有的程序计数器、虚拟机栈和本地方法栈这个3个区域随着线程而生而死。栈中的栈帧随着方法的进入和退出而有条不紊的执行着出栈和入栈操作。每一个栈帧要分配多少内存基本在类结构基本确定下来时已经确定。因此这几个区域的内存分配和回收都具有确定性，无需过多考虑回收问题，因为方法或者线程结束时，内存自然就跟着回收了。</p><p><img src="http://p0c736231.bkt.clouddn.com/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="img"></p><p>其实，我们关心的是JVM 中的线程共享数据区：<strong>Java 堆和方法区</strong>。这部分的内存分配和回收都是动态的，而垃圾收集器所关注的就是这部分内存。那么在这两个区域中，JVM 是如何进行内存分配和回收的呢？我也很好奇~。</p><p>我们先看堆中，再看方法区！</p><p>我们知道，在Java堆中，存放着Java世界几乎所有的对象实例，垃圾回收器在对堆进行回收之前，第一件事情就是需要知道这些对象“死”还是“活”着，如何知道，JVM 使用引用计数法、可达性分析算法进行判断。</p><h2 id="看”堆”中判断对象生死法宝"><a href="#看”堆”中判断对象生死法宝" class="headerlink" title="看”堆”中判断对象生死法宝"></a>看”堆”中判断对象生死法宝</h2><p>首先，无论是现在要说的引用计数算法，还是后文的可达性分析算法，都和对象的引用有关，该算法的目标对象就是引用。说该算法前，就不得不说引用了。</p><h3 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h3><p>其实，判定对象的存活都与引用有关，在Jdk 1.2 之后，Java对引用扩充如下：分位强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）。这4种引用强度依次逐渐减弱。</p><ul><li>强引用：程序代码中普遍存在的引用，只要该引用存在，垃圾收集器永远不会回收掉被引用的对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj=<span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><ul><li><p>软引用：描述有用但非必需的对象。对于软引用关联着的对象，在系统将要发生OOM异常之前，将会把这些对象列进回收范围之中进行第二次回收，如果这次回收后还没有足够的内存，才会抛出OOM异常。</p></li><li><p>弱引用：是用来描述非必须对象的，强度比软引用更弱，被弱引用关联的对象只能生存到下一次GC发生之前。当垃圾回收器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</p></li><li><p>虚引用：也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</p></li></ul><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>什么是引用计数法？很多人这样说到：每一个对象中都添加一个引用计数器，当该引用被一个地方引用一次，就+1；引用失效时，就-1。当计数器为0时，说明该对象不可能再被使用。</p><p>客观说，引用计数算法，实现简单、效率高，大部分情况下很不错，如微软COM技术等在应用。但<strong>Java虚拟机里却没有选用该算法</strong>，最主要原因是：很难解决对象之间相互循环引用问题。即两个引用引用着对方的实例对象。</p><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>主流程序语言：Java、C# 都使用可达性分析算法来判断对象是否存活。这就很牛逼了，到底是什么样的算法，竟然被Java用来判断对象是否存活了。</p><p>可达性分析算法基本思路：通过一系列的称为<code>GC Roots</code> 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为<code>引用链</code> （Reference Chain）,当一个对象到<code>GC Roots</code> 没有任何引用链相连（即GC Roots到这个对象不可达）时，则证明此对象是不可用的；</p><p><img src="http://geosmart.github.io/2016/03/09/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95.png" alt="å¯è¾¾æ§åæç®æ³"></p><p>从下图来看：对象object5,6,7虽然相互关联，但是他们到<code>GC Roots</code>是不可达的，所以它们将会被判定为是可回收对象。</p><p><img src="http://s1.51cto.com/wyfs01/M01/0F/53/wKioOVG_-z-B00S8AABbPmAldC8690.jpg" alt="img"></p><p>那么，可作为GC Roots对象有哪些？一般从栈和方法区去思考：</p><ul><li>栈：</li><li><ul><li>虚拟机栈（栈帧中的本地变量表）中引用对象。</li><li>本地方法栈中JNI（一般来说的Native方法）引用的对象。</li></ul></li><li>方法区：</li><li><ul><li>类静态属性引用的对象。</li><li>常量引用的对象。</li></ul></li></ul><p>再来对比看一下，熟记他们。下图所示：</p><p><img src="http://p0c736231.bkt.clouddn.com/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="img"></p><p>以上就是<strong>堆中关于JVM判断对象是否存活的两个算法</strong>，和我说一遍：<strong>引用计数算法——可达性分析算法</strong>。</p><h2 id="再看”方法区”垃圾收集"><a href="#再看”方法区”垃圾收集" class="headerlink" title="再看”方法区”垃圾收集"></a>再看”方法区”垃圾收集</h2><p>方法区中垃圾回收对象主要为两个：废弃常量和无用的类。</p><p>废弃常量与堆中回收对象非常类似（简单）。但判断是否无用类即比较苛刻。</p><p>判定一个类是否是无用的类条件相对苛刻：</p><ul><li>该类所有实例都已被回收，即Java堆中不存在该类的任何实例；</li><li>加载该类的<code>ClassLoader</code>已经被回收；</li><li>该类对应的<code>java.lang.Class</code>对象没有在任何地方被引用，无法在任何地方通过反射访问该方法。</li></ul><p>在方法区中进行垃圾收集的性价比一般比较低；而在Heap中，尤其是在新生代，常规应用进行一次垃圾收集一般回收70%~95%的空间，而永久代的垃圾收集效率远低于此；</p><h2 id="常见GC算法你了解吗"><a href="#常见GC算法你了解吗" class="headerlink" title="常见GC算法你了解吗"></a>常见GC算法你了解吗</h2><p>垃圾收集算法实现设计大量细节，各个平台操作虚拟机内存方法不一样，所以只说算法思想。</p><h3 id="标记-清除-算法"><a href="#标记-清除-算法" class="headerlink" title="标记-清除 算法"></a>标记-清除 算法</h3><p>如同其名字一样，该算法（最基础收集算法）分两步：标记——&gt;清除。</p><p><strong>标记：</strong>标记的是什么？其实标记的是所有需要回收对象。</p><p><strong>清除：</strong>清除什么？清除上一步被标记的需要回收对象。</p><p><img src="http://geosmart.github.io/2016/03/09/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="æ è®°-æ¸é¤ç®æ³ç¤ºæå¾"></p><p>从上图可以看出：被标记的对象被清除了。但也发现了两个不足：效率问题、空间问题。</p><p><strong>效率问题：</strong>标记、清除连个过程效率都不高。</p><p><strong>空间问题</strong>：清除后产生大量不连续内存碎片。如若分配较大对象时，则无法找到足够连续内存而不得不提前触发另外一次垃圾回收动作。</p><h3 id="复制-算法"><a href="#复制-算法" class="headerlink" title="复制 算法"></a>复制 算法</h3><p>为了<strong>解决 标记-清除 算法带来的效率问题，复制算法应用而生</strong>。</p><p><strong>算法思想</strong>：将可用内存按容量划分为大小相等两块，每次只使用其中一块。</p><p><strong>复制</strong>：复制什么？一块内存用完后，复制其中存活对象到另一块。复制存活~复制存活~复制存活~</p><p><img src="http://geosmart.github.io/2016/03/09/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="å¤å¶ç®æ³ç¤ºæå¾"></p><ul><li>优点：每次对整个半区进行回收，内存分配时不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效；</li><li>不足：提高效率的代价是将内存缩小到原来的一半。</li></ul><p>现代商业虚拟机都采用这种收集算法来回收新生代。HotSpot虚拟机将内存划分为<code>Eden</code> 和2个<code>Survivor</code> 空间，比例8:1:1。每次只是用<code>Eden</code> 和一个<code>Survivor</code> 空间。回收时，将<code>Eden</code> 和<code>Survivor</code> 中还存活对象复制到另外一块<code>Survivor</code> 空间中。当<code>Survivor</code> 空间不足时，需要依赖其他内存（老年代）进行<code>分配担保（Handle Promotion）</code>，让对象进入老年代。分配担保机制后文中会说到。</p><h3 id="标记-整理-算法"><a href="#标记-整理-算法" class="headerlink" title="标记-整理 算法"></a>标记-整理 算法</h3><p>标记整理算法，也是一样，分2个过程。标记——整理</p><p><strong>标记：</strong>标记什么？标记需要被回收对象。</p><p><strong>整理：</strong>此处不像清除，将其清除掉，而是让所有存活对象都向一端移动，然后清理掉端边界以外内存。</p><p><img src="http://geosmart.github.io/2016/03/09/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png" alt="æ è®°-æ´çç®æ³"></p><p>所以，标记清除算法和标记整理算法可以比较吗？试试：</p><p><img src="http://geosmart.github.io/2016/03/09/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/mark_sweep_vs_mark_compact.png" alt="mark_sweep_vs_mark_compact"></p><h3 id="分代收集-算法"><a href="#分代收集-算法" class="headerlink" title="分代收集 算法"></a>分代收集 算法</h3><p>分代收集算法并没有什么心思想，只是根据对向存活周期不同，将内存划分为几块。一般讲 Java 堆分为新生代和老年代。</p><p>新生代和老年代有什么特点呢？   新生代：对象大批会死去，少量存活。   老年代：对象存活率高。因此对于新生代和老年代特点可采用不同回收算法。</p><p><strong>新生代</strong>：复制算法。<strong>复制少量存活对象</strong></p><p><strong>老年代</strong>：标记-清理 或 标记-整理 算法。<strong>标记需回收对象。</strong></p><hr><p>如果你有耐心读到此处，恭喜你，已经从理论层面了解了3个垃圾回收算法。我们一起回顾一下其名称：</p><p>标记-清除 算法，复制 算法，标记-整理 算法。</p><p>那么接下来，在知道了垃圾回收算法后，就要<strong>从应用层面去了解垃圾回收算法的应用</strong> （垃圾回收器）。所以，一起看看常见垃圾收集器有什么？:kissing:</p><h2 id="常见垃圾收集器异同你说上来吗"><a href="#常见垃圾收集器异同你说上来吗" class="headerlink" title="常见垃圾收集器异同你说上来吗"></a>常见垃圾收集器异同你说上来吗</h2><blockquote><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。此次讨论Jdk 7之后 HotSpot 虚拟机包含的几个收集器。</p></blockquote><p><img src="http://p0c736231.bkt.clouddn.com/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.gif" alt="img"></p><h3 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h3><ul><li><p>新生代收集器，使用停止复制算法，使用一个线程进行GC，串行，其它工作线程暂停。</p></li><li><p>使用-XX:+UseSerialGC可以使用Serial+Serial Old模式运行进行内存回收（这也是虚拟机在Client模式下运行的默认值）</p><p>​</p><p><img src="http://p0c736231.bkt.clouddn.com/Serial.png" alt="img"></p><p>​</p></li></ul><h3 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h3><ul><li>新生代收集器，使用停止复制算法，Serial收集器的多线程版，用多个线程进行GC，并行，其它工作线程暂停，关注缩短垃圾收集时间。</li><li>使用-XX:+UseParNewGC开关来控制使用ParNew+Serial Old收集器组合收集内存；使用-XX:ParallelGCThreads来设置执行内存回收的线程数。</li></ul><p><img src="http://p0c736231.bkt.clouddn.com/ParNew.png" alt="img"></p><h3 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h3><ul><li>新生代收集器，使用停止复制算法，关注CPU吞吐量，即运行用户代码的时间/总时间，<br>比如：JVM运行100分钟，其中运行用户代码99分钟，垃圾收集1分钟，则吞吐量是99%，</li><li>这种收集器能最高效率的利用CPU，适合运行后台运算（关注缩短垃圾收集时间的收集器，如CMS，等待时间很少，所以适 合用户交互，提高用户体验）。</li><li>使用-XX:+UseParallelGC开关控制使用Parallel Scavenge+Serial Old收集器组合回收垃圾（这也是在Server模式下的默认值）；</li><li>使用-XX:GCTimeRatio来设置用户执行时间占总时间的比例，默认99，即1%的时间用来进行垃圾回收。</li><li>使用-XX:MaxGCPauseMillis设置GC的最大停顿时间（这个参数只对Parallel Scavenge有效），</li><li>用开关参数-XX:+UseAdaptiveSizePolicy可以进行动态控制，如自动调整Eden/Survivor比例，老年代对象年龄，新生代大小等，这个参数在ParNew下没有。</li></ul><h3 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h3><ul><li>老年代收集器，单线程收集器，串行，</li><li>使用标记整理（整理的方法是Sweep（清理）和Compact（压缩），清理是将废弃的对象干掉，只留幸存的对象，压缩是将移动对象，将空间填满保证内存分为2块，一块全是对象，一块空闲）算法，</li><li>使用单线程进行GC，其它工作线程暂停（注意，在老年代中进行标记整理算法清理，也需要暂停其它线程），</li><li>在JDK1.5之前，Serial Old收集器与ParallelScavenge搭配使用。</li></ul><p><img src="http://p0c736231.bkt.clouddn.com/Serial%20Old.png" alt="img"></p><h3 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h3><p><img src="http://p0c736231.bkt.clouddn.com/CMS.png" alt="img"></p><ul><li>老年代收集器，致力于获取最短回收停顿时间（即缩短垃圾回收的时间），使用标记清除算法，多线程，优点是并发收集（用户线程可以和GC线程同时工作），停顿小。</li><li>使用-XX:+UseConcMarkSweepGC进行ParNew+CMS+Serial Old进行内存回收，</li><li>优先使用ParNew+CMS，当用户线程内存不足时，采用备用方案Serial Old收集。</li><li>CMS收集的执行过程是：初始标记(CMS-initial-mark) -&gt; 并发标记(CMS-concurrent-mark) –&gt;预清理(CMS-concurrent-preclean)–&gt;可控预清理(CMS-concurrent-abortable-preclean)-&gt; 重新标记(CMS-remark) -&gt; 并发清除(CMS-concurrent-sweep) -&gt;并发重设状态等待下次CMS的触发(CMS-concurrent-reset)</li><li>在CMS清理过程中，只有初始标记和重新标记需要短暂停顿，并发标记和并发清除都不需要暂停用户线程，因此效率很高，很适合高交互的场合。</li><li>CMS也有缺点，它需要消耗额外的CPU和内存资源，在CPU和内存资源紧张，CPU较少时，会加重系统负担（CMS默认启动线程数为(CPU数量+3)/4）。</li><li>在并发收集过程中，用户线程仍然在运行，仍然产生内存垃圾，所以可能产生“浮动垃圾”，本次无法清理，只能下一次Full GC才清理，因此在GC期间，需要预留足够的内存给用户线程使用。</li><li>使用CMS的收集器并不是老年代满了才触发Full GC，而是在使用了一大半（默认68%，即2/3，使用-XX:CMSInitiatingOccupancyFraction来设置）的时候就要进行Full GC，如果用户线程消耗内存不是特别大，可以适当调高-XX:CMSInitiatingOccupancyFraction以降低GC次数，提高性能，如果预留的用户线程内存不够，则会触发Concurrent Mode Failure，此时，将触发备用方案：使用Serial Old 收集器进行收集，但这样停顿时间就长了，因此-XX:CMSInitiatingOccupancyFraction不宜设的过大。</li><li>CMS采用的是标记清除算法，会导致内存碎片的产生，可以使用-XX：+UseCMSCompactAtFullCollection来设置是否在Full GC之后进行碎片整理，用-XX：CMSFullGCsBeforeCompaction来设置在执行多少次不压缩的Full GC之后，来一次带压缩的Full GC。</li></ul><h3 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h3><p>G1 收集器是一款面向服务器端应用的垃圾收集器，计划未来替代CMS收集器。相比其他GC收集器，G1 具备如下特点：</p><ul><li><p>并行与并发：能充分利用多CPU、多核环境下的硬件优势； 可以并行来缩短”Stop The World”停顿时间； 也可以并发让垃圾收集与用户程序同时进行；</p></li><li><p>​分代收集：收集范围包括新生代和老年代 ， 能独立管理整个GC堆（新生代和老年代），而不需要与其他收集器搭配；能够采用不同方式处理不同时期的对象； 虽然保留分代概念，但Java堆的内存布局有很大差别； 将整个堆划分为多个大小相等的独立区域（Region）； 新生代和老年代不再是物理隔离，它们都是一部分Region（不需要连续）的集合。</p></li><li><p>空间整合：结合多种垃圾收集算法，空间整合，不产生碎片。从整体看，是基于标记-整理算法；</p><p>​ 从局部（两个Region间）看，是基于复制算法； 这是一种类似火车算法的实现； 都不会产生内存碎片，有利于长时间运行；</p></li><li><p>​可预测的停顿：低停顿的同时实现高吞吐量， G1除了追求低停顿处，还能建立可预测的停顿时间模型； 可以明确指定M毫秒时间片内，垃圾收集消耗的时间不超过N毫秒；</p><p>​</p></li></ul><p>G1  收集器运作大致可划分为如下几个步骤：</p><ul><li>初始标记</li><li>并发标记</li><li>最终标记</li><li>筛选回收</li></ul><p><strong>应用场景</strong>：面向服务端应用，针对具有大内存、多处理器的机器；最主要的应用是为需要低GC延迟，并具有大堆的应用程序提供解决方案；如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒；</p><p>在下面的情况时，使用G1可能比CMS好：<br>​ （1）、超过50％的Java堆被活动数据占用；<br>​ （2）、对象分配频率或年代提升频率变化很大；<br>​ （3）、GC停顿时间过长（长于0.5至1秒）。<br>​ 是否一定采用G1呢？也未必：<br>​ 如果现在采用的收集器没有出现问题，不用急着去选择G1；如果应用程序追求低停顿，可以尝试选择G1； 是否代替CMS需要实际场景测试才知道。</p><h2 id="内存分配与回收策略你知道吗"><a href="#内存分配与回收策略你知道吗" class="headerlink" title="内存分配与回收策略你知道吗"></a>内存分配与回收策略你知道吗</h2><p>Java 体系中所提倡的自动内存管理最终可以总结为自动化解决两个问题：</p><blockquote><p>给对象分配内存以及回收分配给对象的内存。</p></blockquote><p>内存回收上面已经讲述，下面一起看看关于对象分配内存的那点事儿。</p><p>对象的内存分配，大方向说，就是往堆上分配，对象主要分配到1新生代的Eden区上，若启动本地线程分配缓冲，将按线程优先在TLAB 上分配。少数情况下也可能会直接分配到老年代中。</p><h3 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h3><p>大多数情况下，对象在新生代Eden区中分配。当Eden区中没有足够空间进行分配时，虚拟机将进行一次Minor GC。</p><p>此处，我们先来了解一下<strong>常说的 Minor GC 和 Full GC 有什么不一样吗</strong>？</p><ul><li>新生代GC （Minor GC：速度快）：指发生在新生代的垃圾收集动作，因Java 对象大多数都具备招生夕灭特性，所以Minor GC 会非常频繁，一般回收速度也比较快。</li><li>老年代GC （Major GC/Full GC：速度慢）：指发生在老年代的GC ，出现了 Major GC，经常会伴随至少一次的Minor GC（但非绝对），Major GC 速度一般比Minor GC 慢10倍以上。</li></ul><h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>大对象，大对象，什么标准才是大对象？大对象是指：需要大量连续内存空间的Java对象。最典型大对象是：很长的字符串和数组。大对象对虚拟机来说是一个坏消息，因为出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够连续空间“安置”他们。</p><h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h3><p>虚拟机给每个对象定义了一个对象年龄计数器。那么对象的年龄是怎么计算的呢？</p><p>计算方法：对象在Eden 出生并经过第一次Minor GC后仍然存活，并且能被Survivor 容纳的话，并被移动到Survivor 空间中，则对象年龄设置为1.对象每在Survivor “熬过” 一次Minor GC，年龄+1岁，当他年龄增加到一定程度（默认15岁），就会晋升到老年代中。</p><h3 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h3><p><strong>如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄</strong>。关于这句话的理解，请多读两遍就理解了~~~。</p><h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC,尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>哇哦，读到此处，是不是有点儿心累，其实我也心累，但相比于此处你获得的知识，是不是感觉一下又阳光明媚了。我们在此处再闭眼回想一下，我们学到的东西：</p><p><strong>（1）理论层面：</strong></p><p>判断对象死活算法：引用计数算法——-可达性分析算法。</p><p>垃圾收集算法：标记-清除 算法、复制 算法、标记-整理 算法。</p><p><strong>（2）应用层面：</strong></p><p>垃圾收集器：balabalabala~~~~。相信你已经知道了。</p><p><strong>（3）对象进入内寸分配策略：</strong></p><ul><li>首先：Eden区优先</li></ul><ul><li>然后：大对象去哪儿？——<strong>直接</strong>进入老年代。</li></ul><ul><li>最后：长期存活对象去哪儿？——先长大到默认年龄15岁，再进入老年代。</li></ul><p>到此，我们的学习就结束了，在博文中出现的错误或疑问，欢迎和我交流。</p><p><a href="https://github.com/StormWangxhu" target="_blank" rel="noopener">GitHub</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;你的努力终将会有回报，路漫漫其修远兮，吾将上下而求索！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;block
      
    
    </summary>
    
      <category term="深入理解Java虚拟机" scheme="https://StormWangxhu.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="GC" scheme="https://StormWangxhu.github.io/tags/GC/"/>
    
      <category term="JVM 垃圾收集器" scheme="https://StormWangxhu.github.io/tags/JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    
      <category term="内存分配策略" scheme="https://StormWangxhu.github.io/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>（三）初探 Java 的内存模型</title>
    <link href="https://StormWangxhu.github.io/2018/04/07/%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%9D%E6%8E%A2-Java-%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>https://StormWangxhu.github.io/2018/04/07/（三）初探-Java-的内存模型/</id>
    <published>2018-04-06T16:00:00.000Z</published>
    <updated>2018-04-09T04:01:28.015Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>你的努力终将会有回报，路漫漫其修远兮，吾将上下而求索！</p></blockquote><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇博文中叙述了JVM的内存区域，而与之相似的是Java内存模型。<strong>其实JVM与JMM两者之间并不是同一个层次的划分，这两者基本是没有关系的。</strong></p><p>但硬要说出点关系，则从变量、主内存、工作内存定义看，对应关系如下：</p><p>主内存 ——-&gt; Java堆中对象实例数据部分</p><p>工作内存 ——–&gt; 虚拟机栈中部分区域</p><p>从更低层次说，对应关系如下：</p><p>主内存 ——-&gt; 物理硬件内存</p><p>工作内存 ——–&gt; 优先存储于寄存器和高速缓存中（程序运行时主要访问读写的是工作内存）</p><h2 id="计算机硬件效率与一致性"><a href="#计算机硬件效率与一致性" class="headerlink" title="计算机硬件效率与一致性"></a>计算机硬件效率与一致性</h2><p><img src="http://upload-images.jianshu.io/upload_images/3769423-0b6cb32614fa53de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="âæ·±å¥çè§£javaèææºå¤çå¨ï¼é«éç¼å­âçå¾çæç´¢ç»æ"></p><p>​                                 处理器、高速缓存、主内存之间关系</p><h2 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h2><p>Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model,JMM）来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。在此之前，主流程序语言（如C/C++等）直接使用<strong>物理硬件和操作系统的内存模型</strong>，因此，会由于不同平台上内存模型的差异，有可能导致程序在一套平台上并发完全正常，而在另外一套平台上并发访问却经常出错，因此在某些场景就必须针对不同的平台来编写程序。</p><p>定义Java内存模型并非一件容易的事情，这个模型必须定义得足够严谨，才能让Java的并发内存访问操作不会产生歧义；但是，也必须定义得足够宽松，使得虚拟机的实现有足够的自由空间去利用硬件的各种特性（寄存器、高速缓存和指令集中某些特有的指令）来获取更好的执行速度。经过长时间的验证和修补，在JDK 1.5（实现了JSR-133[2]）发布后，Java内存模型已经成熟和完善起来了。</p><h3 id="主内存和工作内存"><a href="#主内存和工作内存" class="headerlink" title="主内存和工作内存"></a>主内存和工作内存</h3><p>Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量（Variables）与Java编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。为了获得较好的执行效能，Java内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器进行调整代码执行顺序这类优化措施。</p><p>Java内存模型规定了<strong>所有的变量都存储在主内存</strong>（Main Memory）中（此处的主内存与介绍物理硬件时的主内存名字一样，两者也可以互相类比，但此处仅是虚拟机内存的一部分）。每条线程还有自己的工作内存（Working Memory，可与前面讲的处理器高速缓存类比），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的交互关系如图所示：</p><p><img src="http://img.blog.csdn.net/20151107223240673" alt="âæ·±å¥çè§£javaèææºç¬¬12ç« å¾çâçå¾çæç´¢ç»æ"></p><p>​                                           线程、主内存、工作内存三者的交互关系</p><h3 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h3><p>关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了以下8种操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许有例外，这个问题后文会讲）。</p><ul><li>lock（锁定）：作用于<strong>主内存</strong>的变量，它把一个变量标识为一条线程独占的状态。</li><li>unlock（解锁）：作用于<strong>主内存</strong>的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li><li>read（读取）：作用于<strong>主内存</strong>的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li><li>load（载入）：作用于<strong>工作内存</strong>的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li><li>use（使用）：作用于<strong>工作内存</strong>的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</li><li>assign（赋值）：作用于<strong>工作内存</strong>的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li><li>store（存储）：作用于<strong>工作内存</strong>的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。</li><li>write（写入）：作用于<strong>主内存</strong>的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</li></ul><p>如果要把一个变量从主内存复制到工作内存，那就要顺序地执行read和load操作。</p><p>如果要把变量从工作内存同步回主内存，就要顺序地执行store和write操作。</p><p>注意，Java内存模型只要求上述两个操作必须按顺序执行，而没有保证是连续执行。也就是说，read与load之间、store与write之间是可插入其他指令的，如对主内存中的变量a、b进行访问时，一种可能出现顺序是read a、read b、load b、load a。除此之外，Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则：</p><ul><li>不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。</li><li>不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li><li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。</li><li>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说，就是对一个变量实施use、store操作之前，必须先执行过了assign和load操作。</li><li>一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。</li><li>如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。</li><li>如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量。</li><li>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）。</li></ul><p>这8种内存访问操作以及上述规则限定，再加上稍后介绍的对volatile的一些特殊规定，就已经完全确定了Java程序中哪些内存访问操作在并发下是安全的。由于这种定义相当严谨但又十分烦琐，实践起来很麻烦，所以在后文将介绍这种定义的一个等效判断原则——先行发生原则，用来确定一个访问在并发环境下是否安全。</p><p><em>注：</em><br>基于理解难度和严谨性考虑，最新的JSR-133文档中，已经放弃采用这8种操作去定义Java内存模型的访问协议了（仅是描述方式改变了，Java内存模型并没有改变）。</p><h3 id="对于volatile型变量的特殊规则"><a href="#对于volatile型变量的特殊规则" class="headerlink" title="对于volatile型变量的特殊规则"></a>对于volatile型变量的特殊规则</h3><p>关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制，但是它并不容易完全被正确、完整地理解，以至于许多程序员都习惯不去使用它，遇到需要处理多线程数据竞争问题的时候一律使用</p><p>synchronized来进行同步。了解volatile变量的语义对后面了解多线程操作的其他特性很有意义，在本节中我们将多花费一些时间去弄清楚volatile的语义到底是什么。</p><p>Java内存模型对volatile专门定义了一些特殊的访问规则，在介绍这些比较拗口的规则定义之前，先用不那么正式但通俗易懂的语言来介绍一下这个关键字的作用。</p><p>当一个变量定义为volatile之后，它将具备<strong>两种特性</strong> （可见性、禁止指令重排序）。</p><p>（1）、保证此变量对所有线程的可见性。</p><p>这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量不能做到这一点，普通变量的值在线程间传递均需要通过主内存来完成，例如，线程A修改一个普通变量的值，然后向主内存进行回写，另外一条线程B在线程A回写完成了之后再从主内存进行读取操作，新变量值才会对线程B可见。</p><p>关于volatile变量的可见性，经常会被开发人员误解，认为以下描述成立：“volatile变量对所有线程是立即可见的，对volatile变量所有的写操作都能立刻反应到其他线程之中，换句话说，volatile变量在各个线程中是一致的，所以基于volatile变量的运算在并发下是安全的”。这句话的论据部分并没有错，但是其论据并不能得出“基于volatile变量的运算在并发下是安全的”这个结论。volatile变量在各个线程的工作内存中不存在一致性问题（在各个线程的工作内存中，volatile变量也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题），但是Java里面的运算并非原子操作，导致volatile变量的运算在并发下一样是不安全的，我们可以通过一段简单的演示来说明原因。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> race = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        race++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREADS_COUNT = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[THREADS_COUNT];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREADS_COUNT; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                        increase();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有累加线程都结束</span></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">1</span>)</span><br><span class="line">            Thread.yield();</span><br><span class="line"></span><br><span class="line">        System.out.println(race);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码发起了20个线程，每个线程对race变量进行10000次自增操作，如果这段代码能够正确并发的话，最后输出的结果应该是200000。读者运行完这段代码之后，并不会获得期望的结果，而且会发现每次运行程序，输出的结果都不一样，都是一个小于200000的数字，这是为什么呢？</p><p>问题就出现在自增运算<code>race++</code> 之中，我们用Javap反编译这段代码后会得到代码，发现只有一行代码的<code>increase（）</code> 方法在Class文件中是由4条字节码指令构成的（return指令不是由race++产生的，这条指令可以不计算），从字节码层面上很容易就分析出并发失败的原因了：当<code>getstatic</code> 指令把race的值取到操作栈顶时，volatile关键字保证了race的值在此时是正确的，但是在执行iconst_1、iadd这些指令的时候，其他线程可能已经把race的值加大了，而在操作栈顶的值就变成了过期的数据，所以<code>putstatic</code> 指令执行后就可能把较小的race值同步回主内存之中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> increase（）；</span><br><span class="line">Code：</span><br><span class="line">Stack=<span class="number">2</span>，Locals=<span class="number">0</span>，Args_size=<span class="number">0</span></span><br><span class="line">0：getstatic#13；//Field race：I</span><br><span class="line"><span class="number">3</span>：iconst_1</span><br><span class="line"><span class="number">4</span>：iadd</span><br><span class="line">5：putstatic#13；//Field race：I</span><br><span class="line"><span class="number">8</span>：<span class="keyword">return</span></span><br><span class="line">LineNumberTable：</span><br><span class="line">line <span class="number">14</span>：<span class="number">0</span></span><br><span class="line">line <span class="number">15</span>：<span class="number">8</span></span><br></pre></td></tr></table></figure><p>客观地说，笔者在此使用字节码来分析并发问题，仍然是不严谨的，因为即使编译出来只有一条字节码指令，也并不意味执行这条指令就是一个原子操作。一条字节码指令在解释执行时，解释器将要运行许多行代码才能实现它的语义，如果是编译执行，一条字节码指令也可能转化成若干条本地机器码指令，此处使用-XX：+PrintAssembly参数输出反汇编来分析会更加严谨一些，但考虑到读者阅读的方便，并且字节码已经能说明问题，所以此处使用字节码来分析。</p><p>由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁（使用synchronized或java.util.concurrent中的原子类）来保证原子性。</p><ul><li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li><li>变量不需要与其他的状态变量共同参与不变约束。</li></ul><p>而在像如下的代码清单所示的这类场景就很适合使用volatile变量来控制并发，当shutdown（）方法被调用时，能保证所有线程中执行的doWork（）方法都立即停下来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> shutdownRequested；</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> shutdown（）&#123;</span><br><span class="line">    shutdownRequested=<span class="keyword">true</span>；</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> doWork（）&#123;</span><br><span class="line">    <span class="keyword">while</span>（！shutdownRequested）&#123;</span><br><span class="line">        <span class="comment">//do stuff</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://pic4.zhimg.com/80/v2-632a9436e9758d3e4f012dd3affcb477_hd.jpg" alt="img"></p><p><em>注</em>：上面这段话到底怎样理解呢？我是这样理解的：其实，Java 内存模型通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖于主内存作为传递媒介方式实现可见性。即volitile关键字保证可见性是通过以主内存为媒介进行传递的。</p><p>（2）、禁止指令重排序优化。</p><p>普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。因为在一个线程的方法执行过程中无法感知到这点，这也就是Java内存模型中描述的所谓的“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics）。</p><p>上面的描述仍然不太容易理解，我们还是继续通过一个例子来看看为何指令重排序会干扰程序的并发执行，演示程序如代码清单:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Map configOptions；</span><br><span class="line"><span class="keyword">char</span>[]configText；</span><br><span class="line"><span class="comment">//此变量必须定义为volatile</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> initialized=<span class="keyword">false</span>；</span><br><span class="line"><span class="comment">//假设以下代码在线程A中执行</span></span><br><span class="line"><span class="comment">//模拟读取配置信息，当读取完成后将initialized设置为true以通知其他线程配置可用</span></span><br><span class="line">configOptions=<span class="keyword">new</span> HashMap（）；</span><br><span class="line">configText=readConfigFile（fileName）；</span><br><span class="line">processConfigOptions（configText,configOptions）；</span><br><span class="line">initialized=<span class="keyword">true</span>；</span><br><span class="line"><span class="comment">//假设以下代码在线程B中执行</span></span><br><span class="line"><span class="comment">//等待initialized为true，代表线程A已经把配置信息初始化完成</span></span><br><span class="line"><span class="keyword">while</span>（！initialized）&#123;</span><br><span class="line">    sleep（）；</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用线程A中初始化好的配置信息</span></span><br><span class="line">doSomethingWithConfig（）；</span><br></pre></td></tr></table></figure><p>上述程序是一段伪代码，其中描述的场景十分常见，只是我们在处理配置文件时一般不会出现并发而已。如果定义<code>initialized</code> 变量时没有使用volatile修饰，就可能会<strong>由于指令重排序的优化</strong>，导致位于线程A中最后一句的代码<code>initialized=true”</code> <strong>被提前执行</strong>（这里虽然使用Java作为伪代码，但所指的重排序优化是机器级的优化操作，提前执行是指这句话对应的汇编代码被提前执行），这样在线程B中使用配置信息的代码就可能出现错误，而volatile关键字则可以避免此类情况的发生。</p><p>指令重排序是并发编程中最容易让开发人员产生疑惑的地方，除了上面伪代码的例子之外，笔者再举一个可以实际操作运行的例子来<strong>分析volatile关键字是如何禁止指令重排序优化的</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            Singleton.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后，这段代码对instance变量赋值部分如代码清单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x01a3de0f</span>：mov$<span class="number">0x3375cdb0</span>，%esi         ；……beb0cd75 <span class="number">33</span></span><br><span class="line">                                        ；&#123;oop（<span class="string">'Singleton'</span>）&#125;</span><br><span class="line"><span class="number">0x01a3de14</span>：mov%eax，<span class="number">0x150</span>（%esi）      ；……<span class="number">89865001</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0x01a3de1a</span>：shr$<span class="number">0x9</span>，%esi                ；……c1ee09</span><br><span class="line"><span class="number">0x01a3de1d</span>：movb$<span class="number">0x0</span>，<span class="number">0x1104800</span>（%esi）    ；……c6860048 <span class="number">100100</span></span><br><span class="line"><span class="number">0x01a3de24</span>：lock addl$<span class="number">0x0</span>，（%esp）        ；……f0830424 <span class="number">00</span></span><br><span class="line">                                        ；*putstatic instance</span><br><span class="line">                                        ；-</span><br><span class="line">Singleton：getInstance@<span class="number">24</span></span><br></pre></td></tr></table></figure><p>通过对比就会发现，关键变化在于有volatile修饰的变量，赋值后（前面mov%eax，0x150（%esi）这句便是赋值操作）多执行了一个<code>lock addl ＄0x0，（%esp）</code> 操作，这个操作相当于一个<strong>内存屏障</strong>（Memory Barrier或Memory Fence，指重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；但如果有两个或更多CPU访问同一块内存，且其中有一个在观测另一个，就需要内存屏障来保证一致性了。这句指令中的<code>addl ＄0x0，（%esp）</code> （把ESP寄存器的值加0）显然是一个空操作（采用这个空操作而不是空操作指令nop是因为IA32手册规定<code>lock</code> 前缀不允许配合nop指令使用），关键在于lock前缀，查询IA32手册，它的作用是所以通过这样一个空操作，可让前面volatile变量的修改对其他CPU立即可见。</p><p>那为何说它禁止指令重排序呢？从硬件架构上讲，指令重排序是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理。但并不是说指令任意重排，CPU需要能正确处理指令依赖情况以保障程序能得出正确的执行结果。譬如指令1把地址A中的值加10，指令2把地址A中的值乘以2，指令3把地址B中的值减去3，这时指令1和指令2是有依赖的，它们之间的顺序不能重排——（A+10）<em>2与A</em>2+10显然不相等，但指令3可以重排到指令1、2之前或者中间，只要保证CPU执行后面依赖到A、B值的操作时能获取到正确的A和B值即可。所以在本内CPU中，重排序看起来依然是有序的。因此，<code>lock addl＄0x0，（%esp）</code> 指令把修改同步到内存时，意味着所有之前的操作都已经执行完成，这样便形成了“指令重排序无法越过内存屏障”的效果。</p><p>解决了volatile的语义问题，再来看看在众多保障并发安全的工具中选用volatile的意义——它能让我们的代码比使用其他的同步工具更快吗？在某些情况下，volatile的同步机制的性能确实要优于锁（使用synchronized关键字或java.util.concurrent包里面的锁），但是由于虚拟机对锁实行的许多消除和优化，使得我们很难量化地认为volatile就会比synchronized快多少。</p><p>如果让volatile自己与自己比较，那可以确定一个原则：volatile变量读操作的性能消耗与普通变量几乎没有什么差别，但是<strong>写操作则可能会慢</strong>一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。不过即便如此，大多数场景下volatile的总开销仍然要比锁低，<strong>我们在volatile与锁之中选择的唯一依据仅仅是volatile的语义能否满足使用场景的需求</strong>。</p><p><em>注</em>：上面这段话又怎样理解？volitile关键字它也有使用场景，它的读操作相比于普通变量无区别。但写操作会慢，因为它需要插入许多内存屏障禁止指令重排序。</p><p><em>注：</em><br>volatile屏蔽指令重排序的语义在JDK 1.5中才被完全修复，此前的JDK中即使将变量声明为volatile也仍然不能完全避免重排序所导致的问题（主要是volatile变量前后的代码仍然存在重排序问题），这点也是在JDK 1.5之前的Java中无法安全地使用DCL（双锁检测）来实现单例模式的原因。</p><h3 id="对于-long-和-double-型变量的特殊规则"><a href="#对于-long-和-double-型变量的特殊规则" class="headerlink" title="对于 long 和 double 型变量的特殊规则"></a>对于 long 和 double 型变量的特殊规则</h3><p>Java 内存模型对64位数据类型（long 和 double） ：允许虚拟机将没有被volitile关键字修饰的64位数据类型读写操作分两次32位操作来进行。这就是所谓的long和double的<strong>非原子性协定</strong> 。</p><h3 id="再看-Java-内存模型的3个特征"><a href="#再看-Java-内存模型的3个特征" class="headerlink" title="再看 Java 内存模型的3个特征"></a>再看 Java 内存模型的3个特征</h3><ul><li>原子性</li><li>可见性</li><li>有序性</li></ul><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>Java 内存模型中尽管虚拟机未把lock和unlock操作直接开放给用户使用，但是却提供更高层次字节码指令monitorenter 和 monitorexit 来隐式使用，这两个字节码指令反应到java代码就是—–synchronized关键字，因此在synchronized块之间的操作也具有原子性。</p><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>什么是可见性？即一个线程修改了共享变量值，其他线程能够立即得知这个修改。</p><p>如何实现？当然是通过<code>volitile</code> 关键字保证新值能立即同步到主内存，以及每次使用前立即从主内存刷新。这也是<code>volitile</code> 变量与普通变量的区别所在！</p><p>还有2个关键字能实现可见性：<code>synchronized</code>  和 <code>final</code>  。</p><p>实现机制又是怎样的？简单总结：</p><p>（1） <code>synchronized</code> （同步块的可见性）：对一个变量进行unlock（多线程操作共享变量，每个线程须lock，unlock该变量。）操作之前，必须先把此变量同步回主内存中（执行<code>store</code> 、<code>write</code> 操作）。</p><p>（2） <code>final</code>  ：被<code>final</code>  关键字修饰的字段在构造器中一旦初始化完成，且没有把    <code>this</code> 引用传递出去，那么其他线程就能看见<code>final</code> 字段的值。</p><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>Java 内存模型有序性 在前面讲解volitile关键字已详细讲解。Java 中天然的有序性可以总结为一句话：如果在本地线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。</p><p>前半句指：线程内表现为串行的语义。后半句指：”指令重排序“现象和”工作内存和主内存同步延迟“现象。</p><p>Java 语言用volitile和synchronized两个关键字保证线程之间操作有序性。volitile 关键字本身就包含了禁止指令重排序语义，而synchronized则是由“一个变量在同一时刻只允许一条线程对其进行lock操作”这条规则获得。</p><p>介绍完3种特性后是不是发现，synchronized关键字是“万能”的。但是越“万能”的并发控制，通常会伴随着越大的性能影响。在后续博文会说。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>前面说了这么多，就以下内容：</p><p>1、Java 内存模型是怎样的一个工作原理？</p><p>2、内存间是怎么样交互进行信息传递的？</p><p>3、<code>volitile</code> 关键字到底是如何保证一个共享变量的可见性、又如何做到禁止指令重排序，从而保证代码在多线程条件下顺序执行？</p><p>基于以上三个问题，我们做了长篇幅的解释，大体原理可说明说下：<br>1、Java 内存模型原理：</p><p><img src="http://img.blog.csdn.net/20151107223240673" alt="âæ·±å¥çè§£javaèææºç¬¬12ç« å¾çâçå¾çæç´¢ç»æ"></p><p>2、共享变量通过以主内存作为媒介，在多线程间进行交互。</p><p>3、 （1） 保证可见性：<code>lock</code> 前缀，将<strong>使得本CPU的Cache（高速缓存）写入了内存，该写入动作也会引起别的CPU或者别的内核 无效化 （Invalidate）其Cache，这种操作相当于对Cache中的变量做了一次前面介绍Java内存模式中所说的“store和write”操作</strong>。</p><p>（2）、禁止指令重排序：增加内存屏障。（<code>lock前缀</code> ）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;你的努力终将会有回报，路漫漫其修远兮，吾将上下而求索！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上一篇
      
    
    </summary>
    
      <category term="深入理解Java虚拟机" scheme="https://StormWangxhu.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="Java 内存模型" scheme="https://StormWangxhu.github.io/tags/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>（二）初探 JVM 的内存结构</title>
    <link href="https://StormWangxhu.github.io/2018/04/06/%EF%BC%88%E4%BA%8C%EF%BC%89%E5%88%9D%E6%8E%A2-JVM-%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    <id>https://StormWangxhu.github.io/2018/04/06/（二）初探-JVM-的内存结构/</id>
    <published>2018-04-05T16:00:00.000Z</published>
    <updated>2018-04-11T07:04:33.613Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>@Date:2018/04/05</p><p>@Author: StormWangxhu</p></blockquote><hr><blockquote><p>你的努力终将会有回报，路漫漫其修远兮，吾将上下而求索！</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人想出来。</p></blockquote><p>本文也将参考周志明老师的书《深入理解Java虚拟机》，在概念上初探JVM的内存结构的各个区域，讲解这些区域的作用、服务对象以及其中可能产生的问题，这是翻越虚拟机内存管理这堵围墙的第一步。</p><h2 id="得到"><a href="#得到" class="headerlink" title="得到"></a>得到</h2><p>首先先仰起头来整体看一下JVM内存结构的宏观图：</p><p><img src="http://p0c736231.bkt.clouddn.com/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="img"></p><p><img src="http://blog.stormma.me/2017/11/15/%E4%B8%80%E7%82%B9%E4%B8%80%E6%BB%B4%E6%8E%A2%E7%A9%B6JVM%E4%B9%8B%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/jvm_memo_area.png" alt="å¢åçä¸ç"></p><p>然后再看以线程私有和共享区分:</p><p><img src="http://blog.stormma.me/2017/11/15/%E4%B8%80%E7%82%B9%E4%B8%80%E6%BB%B4%E6%8E%A2%E7%A9%B6JVM%E4%B9%8B%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/jvm_thread.png" alt="img"></p><p>完了就具体来看看各个内存区域的作用。</p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序技术器（Program Counter Register）是一块较小的内存空间，他可以看做是当前线程所执行的字节码的行号指示器。</p><p>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各个线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><p>程序计数器不同场景下记录的命令：</p><ul><li>线程执行Java方法时：记录正在执行虚拟机字节码指令地址。</li></ul><ul><li>线程执行Native方法：计数器值为空（Undefined）。</li></ul><p>此内存区域是唯一一个在Java虚拟机规范中没有规定任何<code>OutOfMemoryError</code>                                                                   情况的区域。</p><h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p>与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。</p><p>虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行时都会创建一个栈帧（Stack Frame），用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。单线程下有错误时会抛出<code>StackOverFlowError</code> ，多线程下会抛出<code>OutOfMemoryError</code> 。</p><p>那么栈帧所存储的局部变量表、操作数栈、动态链接、方法出口信息等具体是什么意思：</p><ul><li>局部变量表: 局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量，其中存放的数据的类型是编译期可知的各种基本数据类型、对象引用(reference)和(returnAddress)类型（它指向了一条字节码指令的地址）。局部变量表所需的内存空间在编译期间完成计算的，即在Java程序被编译成Class文件时，就确定了所需分配的最大局部变量表的容量。当进入一个方法时，这个方法需要在栈中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</li><li>操作数栈: 操作数栈又常被称为操作栈，操作数栈的最大深度也是在编译的时候就确定了。32位数据类型所占的栈容量为1, 64位数据类型所占的栈容量为2。当一个方法开始执行时，它的操作栈是空的，在方法的执行过程中，会有各种字节码指令（比如：加操作、赋值元算等）向操作栈中写入和提取内容，也就是入栈和出栈操作。Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈。因此我们也称Java虚拟机是基于栈的，这点不同于Android虚拟机，Android虚拟机是基于寄存器的。基于栈的指令集最主要的优点是可移植性强，主要的缺点是执行速度相对会慢些；而由于寄存器由硬件直接提供，所以基于寄存器指令集最主要的优点是执行速度快，主要的缺点是可移植性差</li><li>动态链接: 每个栈帧都包含一个指向运行时常量池（在方法区中，后面介绍）中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。<code>Class</code> 文件的常量池中存在有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用，一部分会在类加载阶段或第一次使用的时候转化为直接引用（如 <code>final、static</code>  域等），称为静态解析，另一部分将在每一次的运行期间转化为直接引用，这部分称为动态连接。</li><li>方法返回地址: 当一个方法被执行后，有两种方式退出该方法：执行引擎遇到了任意一个方法返回的字节码指令或遇到了异常，并且该异常没有在方法体内得到处理。无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行。方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者的PC计数器的值就可以作为返回地址，栈帧中很可能保存了这个计数器值，而方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息。方法退出的过程实际上等同于把当前栈帧出站，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，如果有返回值，则把它压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令。</li></ul><p>在Java虚拟机规范中，对这个区域规定了两种异常情况：若线程请求栈深度大于虚拟机所允许的深度，将抛出<code>StackOverFlowError</code> ；若虚拟机可以动态拓展，若拓展时无法申请到足够的内存，就会抛出<code>OutOfMemoryError</code> 异常。</p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈（Native Method Stack）与虚拟机所发挥的作用是非常相似的，他们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。</p><p>与虚拟机栈一样，本地方法栈也会抛出<code>StackOverFlowError</code> 和<code>OutOfMemoryError</code> 异常。</p><h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><p>Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块区域，由虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。但随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配。标量替换优化技术将会导致一些微妙的变化发生，所有对象都分配到堆上也渐渐变的不是那么”绝对“了。</p><p>Java堆是垃圾收集器管理的主要区域，很多时候也被叫做Java“GC堆”（Garbage Collected Heap）。</p><p>从内存回角度来看，由于现在收集器基本采用分代收集算法，所以Java堆又细分为：新生代、老年代。</p><p>再细致一点有：Eden空间、From Survivor空间、To Survivor空间等。</p><p>从内存分配角度来看，线程共享的Java堆可划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer,TLAB）。不过无论如何划分，无论哪个区域，存储的都是对象实例，进一步划分目的是为了更好回收内存，或更快分配内存。具体分配我在后面文章再具体详说。</p><p>Java虚拟机规范规定：Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，如我们磁盘空间一样。</p><p><strong>Meta-Area</strong></p><p>这块区域也是线程共享的区域，它主要存储jvm加载类的类信息，类变量，常量(这个在meta-area的常量区)，即时编译器编译后的代码等数据。</p><p><em>运行时常量区</em></p><p>这个区域是Meta-Area的一部分，用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p><p>来看一个实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这段代码会涉及Vm Stack、Java Heap、Meta-Area三个最重要的内存区域。</p><p>结合我们前面的例子，因为<code>test()</code>方法涉及到Vm Stack区，我想你应该明白，obj会存放在局部变量表中，<code>new Object()</code>，我们前面说过我们大部分的对象都会存储在Java Heap这个区域，所以，Java Heap存储了这个实例对象！那么你会很好奇，Meta-Area为啥会涉及到呢？</p><p>我们知道Meta-Area存储了类的信息，类变量常量等等东西！因为我们实例化<code>Object</code>对应的时候，要用到<code>Object</code>这个类的信息，所以它会访问Meta-Area的<code>Object.class</code>这个Class对象来获得一些实例化对象需要的东西。</p><p>对了，作为补充，我想你还需要知道, obj引用怎么你能访问到Java Heap区的那个实例化对象</p><p>有两种方式，一种使用过句柄指针(学过c/c++对这些概念应该会很熟悉)</p><blockquote><p>下图来自《深入理解Java虚拟机》一书。</p></blockquote><p><img src="http://blog.stormma.me/2017/11/15/%E4%B8%80%E7%82%B9%E4%B8%80%E6%BB%B4%E6%8E%A2%E7%A9%B6JVM%E4%B9%8B%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/java_handle.png" alt="å¥æè®¿é®"></p><p>还有一种就是通过指针直接访问:</p><p><img src="http://blog.stormma.me/2017/11/15/%E4%B8%80%E7%82%B9%E4%B8%80%E6%BB%B4%E6%8E%A2%E7%A9%B6JVM%E4%B9%8B%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/no_handle.png" alt="ç´æ¥æéè®¿é®"></p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区与Java堆一样，是各个线程共享的内存区域，他用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机把Java堆描述为堆逻辑的一部分，但是它有一个别名，叫做Non-Heap（非堆），目的该是与Java堆区分开来。</p><p>方法区，很多人又愿意叫做“永久代”，Java虚拟机对方法区的限制非常宽松，除了和Java堆一样，不需要连续的内存和可以选择固定大小或者可拓展外，还可以选择不实现垃圾收集。相对而言，垃圾收集在这块区域是比较少出现，但并非数据进入方法区就如永久代名字一样“永久”存在了。</p><p>Java虚拟机规范，当方法区无法满足内存分配需求时，将抛出<code>OutOfMemoyError</code> 异常。</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载进入方法区的运行时常量池中存放。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>依旧来总结一下这方面的面试题：</p><h3 id="JVM运行内存分类"><a href="#JVM运行内存分类" class="headerlink" title="JVM运行内存分类"></a>JVM运行内存分类</h3><ul><li>程序计数器：当前线程所执行的字节码的行号指示器，用于记录下一条要运行的指令，线程私有</li></ul><p>注：如果正在执行的是Native方法，计数器值则为空</p><ul><li>Java虚拟栈：存放基本数据类型、对象的引用、方法出口等，线程私有</li></ul><ul><li>Native方法栈：和虚拟栈相似，只不过它服务于Native方法，线程私有</li></ul><ul><li>Java堆：java内存最大的一块，所有对象实例、数组都存放在java堆，GC回收的地方，线程共享</li></ul><ul><li>方法区：存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码数据等。（即永久带），回收目标主要是常量池的回收和类型的卸载，各线程共享</li></ul><h3 id="Java内存堆栈的区别"><a href="#Java内存堆栈的区别" class="headerlink" title="Java内存堆栈的区别"></a>Java内存堆栈的区别</h3><ul><li>栈内存用来存储基本类型的变量和对象的引用变量，堆内存用来存储Java中的对象，无论是<strong>成员变量</strong>，局部变量，还是类变量，它们指向的对象都存储在堆内存中</li></ul><ul><li>栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存，堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问</li></ul><ul><li>如果栈内存没有可用的空间存储方法调用和局部变量，JVM会抛出java.lang.StackOverFlowError，如果是堆内存没有可用的空间存储生成的对象，JVM会抛出java.lang.OutOfMemoryError</li></ul><ul><li>栈的内存要远远小于堆内存，如果你使用递归的话，那么你的栈很快就会充满，-Xss选项设置栈内存的大小。-Xms选项可以设置堆的开始时的大小。</li></ul><h3 id="Java的四个引用"><a href="#Java的四个引用" class="headerlink" title="Java的四个引用"></a>Java的四个引用</h3><ul><li><p>强引用（StrongReference）</p><p>强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题</p></li></ul><ul><li><p>软引用（SoftReference）</p><p>​如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，软引用可以和一个引              用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中</p></li><li><p>弱引用（WeakReference）</p><p>​弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它          所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。<br>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中</p></li><li><p>虚引用（PhantomReference）</p><p>虚引用在任何时候都可能被垃圾回收器回收，主要用来<strong>跟踪对象被垃圾回收器回收的活动，被回收时会收到一个系统通知</strong>。虚引用与软引用和弱引用的一个区别在于：虚引用<strong>必须</strong>和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中</p></li></ul><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p><img src="http://p0c736231.bkt.clouddn.com/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="img"></p><blockquote><p>图来自bryan学长总结，其中Java内存模型应改为JVM内存区域。已向博主反应！</p></blockquote><p>概念上初探JVM的内存结构的各个区域，本文达到了开头所说的目的。如若有什么错误或疑问，欢迎指正！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;@Date:2018/04/05&lt;/p&gt;
&lt;p&gt;@Author: StormWangxhu&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;你的努力终将会有回报，路漫漫其修远兮，吾将上下而求索！&lt;/p&gt;
&lt;/block
      
    
    </summary>
    
      <category term="深入理解Java虚拟机" scheme="https://StormWangxhu.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM 内存结构" scheme="https://StormWangxhu.github.io/tags/JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>（一）一道题看清 JVM 的类加载机制</title>
    <link href="https://StormWangxhu.github.io/2018/04/05/%EF%BC%88%E4%B8%80%EF%BC%89%E4%B8%80%E9%81%93%E9%A2%98%E7%9C%8B%E6%B8%85-JVM-%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>https://StormWangxhu.github.io/2018/04/05/（一）一道题看清-JVM-的类加载机制/</id>
    <published>2018-04-04T16:00:00.000Z</published>
    <updated>2018-04-09T15:49:05.065Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>你的努力终将会有回报，路漫漫其修远兮，吾将上下而求索！</p></blockquote><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先，我说的是一道题要看清JVM的类加载机制，所以，我们得先有题呀，一起来看一道经典的面试题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        value1++;</span><br><span class="line">        value2++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//注意此处位置</span></span><br><span class="line">        Singleton singleton = Singleton.getInstance();</span><br><span class="line">        System.out.println(<span class="string">"Singleton1 value1:"</span> + singleton.value1);</span><br><span class="line">        System.out.println(<span class="string">"Singleton1 value2:"</span> + singleton.value2);</span><br><span class="line"></span><br><span class="line">        Singleton2 singleton2 = Singleton2.getInstance2();</span><br><span class="line">        System.out.println(<span class="string">"Singleton2 value1:"</span> + singleton2.value1);</span><br><span class="line">        System.out.println(<span class="string">"Singleton2 value2:"</span> + singleton2.value2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value2 = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//注意此处位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton2 singleton2 = <span class="keyword">new</span> Singleton2();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        value1++;</span><br><span class="line">        value2++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title">getInstance2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题，看似没有什么差别，但其实，差之毫厘谬以千里，结果会完全不同，但结果究竟是怎么样的呢？我现在还暂时不能告诉你，除非你自己在编译器上运行一下。跟着我一起来看看JVM的类加载机制吧，看完后，你一定会自己说出正确的答案，而且理解其所以然，真真的一道题看清JVM的来世今生！来吧！</p><h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>虚拟机把描述类的数据文件（字节码）加载到内存，并对数据进行验证、准备、解析以及类初始化，最终形成可以被虚拟机直接使用的java类型（java.lang.Class对象）</p><h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p>关于类的生命周期，请记住这句话：加载–&gt;连接–&gt;初始化。</p><p>一个类从出生到卸载完会经历以下的生命周期：<img src="http://blog.stormma.me/2017/11/14/%E4%B8%80%E7%82%B9%E4%B8%80%E6%BB%B4%E6%8E%A2%E7%A9%B6JVM%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/classonload.png" alt="ç±»ççå½å¨æ"></p><p>类从被加载到虚拟机内存中开始，到卸载为止，整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）、卸载（UnLoading）7个阶段。其中，验证、准备、解析三个阶段又统称为连接（Linking）。可总结为：加载、连接、初始化！</p><p>下面看看这7个过程中（5个阶段）虚拟机进行了哪些动作？</p><h4 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h4><p>通过一个类的全限定名来获取定义此类的二进制字节流，将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。在内存中(方法区)生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口；</p><p><strong>上面这句话是什么意思呢？其实很简单，就是将一个<code>.class</code> 文件通过类加载器，加载到内存中，在方法区保存其类的数据结构，然后在堆中创建该类的对象。该对象又作为访问方法区中该类数据结构（即各种数据）的访问入口。即访问入口是该对象。</strong></p><p><strong>即：查找并加载类的二进制数据文件。</strong></p><h4 id="连接阶段"><a href="#连接阶段" class="headerlink" title="连接阶段"></a>连接阶段</h4><ul><li><p>验证：</p><p>为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，文件格式验证、元数据验证、字节码验证、符号引用验证</p><p><strong>即：确保被加载类的正确性</strong></p></li><li><p>准备：</p><p>正式为类变量（即static修饰的变量，包括静态代码块）分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配</p><p><strong>即：为类的静态变量分配内存，并将其初始化为默认值</strong></p></li><li><p>解析：</p><p>虚拟机将常量池内的符号引用替换为直接引用的过程。<strong>符号引用是二进制数据中引用，直接引用相当于运行期间的指针，指向方法区内存位置。</strong></p><p><strong>即：把类的符号引用转换为直接引用</strong></p></li></ul><h4 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h4><p>类初始化阶段是类加载过程的最后一步。前面的类加载过程中，除了在加载阶段用户可以使用自定义的类加载器参与外，其余动作完全由虚拟机主导和控制！初始化阶段就是执行类构造器<clint>()方法的过程。到了初始化阶段，才真正开始执行类中定义的Java代码（或者说是字节码）！</clint></p><p>静态变量初始化有两种路径：</p><p>（1）、在静态变量声明处初始化。</p><p>（2）、在静态代码块中初始化。</p><h4 id="使用阶段"><a href="#使用阶段" class="headerlink" title="使用阶段"></a>使用阶段</h4><p>开始使用类。</p><h4 id="卸载阶段"><a href="#卸载阶段" class="headerlink" title="卸载阶段"></a>卸载阶段</h4><p>使用完后，卸载类。</p><h3 id="关于类加载"><a href="#关于类加载" class="headerlink" title="关于类加载"></a>关于类加载</h3><p>加载主要是将<code>.class</code> 文件（并不一定是.class。可以是ZIP包，网络中获取）中的二进制字节流读入到JVM中。 其中获取<code>.class</code> 文件主要有以下几种方式：</p><ul><li>ZIP</li><li>jar（这也是为什么我们在开发中可以使用别人的jar包原因，也是常见加载<code>.class</code> 文件方式）</li><li>网络下载</li></ul><h4 id="类加载需要完成的三件事情："><a href="#类加载需要完成的三件事情：" class="headerlink" title="类加载需要完成的三件事情："></a>类加载需要完成的三件事情：</h4><p>在加载阶段，JVM需要完成3件事：经历过程如下： 即获取字节流——&gt;方法区——-&gt;Java堆中。</p><ul><li>通过类的全限定名获取该类的<strong>二进制字节流</strong>（即包名+类名）； </li></ul><ul><li>将字节流所代表的静态存储结构转化为<strong>方法区</strong>的运行时数据结构（即将类的数据结构存储于方法区中）； </li></ul><ul><li>在<strong>堆</strong>中生成一个该类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li></ul><p><em>注</em>：何时会触发类的加载过程，Java虚拟机规范中并没有进行强制约束，而是交给虚拟机的具体实现来自由把握。即然知道了类加载需要完成三件事情，接下来就得知道类加载器是干什么的了。</p><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>虚拟机设计团队把类的加载阶段中的“通过一个类的全限定名来获取此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己去决定如何获取所需要的类而实现这个动作的模块称为“类加载器”。</p><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类的加载阶段。对于任意一个类，都需要由<strong>加载它的类加载器</strong>和这个<strong>类本身</strong>一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。更通俗的说，也就是：即使两个类来源于同一个<code>Class</code>文件，只要加载它们的类加载器不同，那这两个类就必定不相等。这里的“相等”包括了代表类的<code>Class</code>对象的<code>equals()</code>、<code>isAssignableFrom()</code>、<code>isInstance()</code>等方法的返回结果，也包括了使用<code>instanceof</code>关键字对对象所属关系的判定结果。</p><p>下面我们用代码来解释一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> stormwangxhu.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> stormwangxhu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/04/06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassLoader myClassLoader = <span class="keyword">new</span> ClassLoader() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String filename = name.substring(name.lastIndexOf(<span class="string">"."</span>) + <span class="number">1</span>) + <span class="string">".class"</span>;</span><br><span class="line">                    InputStream inputStream = getClass().getResourceAsStream(filename);</span><br><span class="line">                    <span class="keyword">if</span> (inputStream == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[inputStream.available()];</span><br><span class="line">                    inputStream.read(bytes);</span><br><span class="line">                    <span class="keyword">return</span> defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object object=myClassLoader.loadClass(<span class="string">"stormwangxhu.example.ClassLoaderTest"</span>).newInstance();</span><br><span class="line">            System.out.println(object.getClass());<span class="comment">//class stormwangxhu.example.ClassLoaderTest</span></span><br><span class="line">            System.out.println(object <span class="keyword">instanceof</span> stormwangxhu.example.ClassLoaderTest);<span class="comment">//false</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们解释一下上述结果产生的原因：</p><p>因为虚拟机种存在了两个ClassLoaderTest的类，一个由<strong>系统应用程序类加载器</strong>加载的，另外一个是由我们<strong>自定义的类加载器加载</strong>的，虽然都来自同一个Class文件，但依然是两个独立的类，做对象所属类型检查时结果自然返回false。</p><p>若从JVM的角度来看，类加载器可以分为：</p><ul><li>启动类加载器(<code>Bootstrap ClassLoader</code>，它负责加载存放在<code>$JAVA_HOME/jre/lib</code>下，或被<code>-Xbootclasspath</code>参数指定的路径中的，并且能被虚拟机识别的类库（如 rt.jar）。启动类加载器是无法被Java程序直接引用的。很容易可以验证，执行<code>System.out.println(String.class.getClassLoader())</code>打印结果为<code>null</code>)</li><li>扩展类加载器(<code>Extension ClassLoader</code>, 该加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现，它负责加载<code>$JAVA_HOME/jre/lib/ext</code>目录中，或者由<code>java.ext.dirs</code>系统变量指定的路径中的所有类库(如<code>javax.*</code>开头的类)，开发者可以直接使用扩展类加载器。在jdk1.9中类加载器有所变化！1.9中jdk.internal.loader.ClassLoaders$PlatformClassLoader，称为平台类加载器)</li><li>应用程序加载器（系统应用程序类加载器）(Application ClassLoader，该类加载器由<code>sun.misc.Launcher$AppClassLoader</code>来实现，它负责加载用户类路径<code>ClassPath</code>所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。注意在jdk1.9中，应用程序加载器由jdk.internal.loader.ClassLoaders$AppClassLoader实现)</li></ul><p>我们的应用程序都是由这3种类加载器相互配合进行加载的，若有必要，可以加入我们自己定义的类加载器。其中 启动类加载器是由C++语言编写的，其他两个由Java编写。</p><p>这些类加载器之间的关系又引出双亲委托机制。</p><p>借此机会，我们来看看什么是双亲委托机制！</p><h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>类加载器之间的关系如图所示：</p><p><img src="http://blog.stormma.me/2017/11/14/%E4%B8%80%E7%82%B9%E4%B8%80%E6%BB%B4%E6%8E%A2%E7%A9%B6JVM%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/loader.png" alt="ç±»å è½½å¨çå±æ¬¡å³ç³»"></p><p>上图所展示的类加载器之间的层次关系，称为类加载器的双亲委派模型。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承关系来实现，而是都使用组合关系来复用父加载器代码。该模型在JDK1.2期间被引入并广泛应用于之后几乎所有的Java程序中，但它并不是一个强制性的约束模型，而是Java设计者们推荐给开发者的一种类的加载器实现方式。</p><p>双亲委派模型工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p><p>使用双亲委派模型来组织类加载器之间的关系，有一个很明显的好处，就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，这对于保证Java程序的稳定运作很重要。例如：类<code>java.lang.Object</code>类存放在<code>$JAVA_HOME/jre/lib</code>下的<code>rt.jar</code>之中，因此无论是哪个类加载器要加载此类，最终都会委派给启动类加载器进行加载，这便保证了<code>Object</code>类在程序中的各种类加载器中都是同一个类。相反：若没有使用双亲委派魔性，由各个类加载器自行去加载的话，若用户自己编写了一个称为<code>java.lang.Object</code>的类，并放在程序的<code>ClassPath</code>中，那系统中将会出现多个不同的<code>Object</code>类，Java类型体系中最基础的行为也无法得到保证，应用程序也将会一片混乱。</p><p>此处，我们看看<code>ClassLoader</code> 这个抽象类的双亲委派机制的实现了！该代码都集中在<code>java.lang.ClassLoader</code> 的<code>loadClass</code> 方法之中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded，首先，检查请求的类是否已经被加载过了</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123; </span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123; <span class="comment">// 若父加载器抛出ClassNotFoundException，说明父类加载器无法完成加载该类请求</span></span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found </span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123; </span><br><span class="line">                    <span class="comment">// 在父类加载器无法加载的时候，</span></span><br><span class="line">                    <span class="comment">// 再调用自身的findClass来进行类的加载</span></span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对照我们上面的测试代码自定义的那个类加载器，如果是实现<code>findClass()</code>而没有实现<code>loadClass()</code>方法，那么加载时候先开始判断它的父类加载器(自定义类加载器的上一级是应用程序类加载器，然后根据双亲委托机制一步一步进行判断加载。最后加载都不成功就会调用<code>findClass()</code>方法来加载，jdk1.2之后官方不提倡实现<code>loadClass()</code>！上面的例子，为了测试两个Class对象不相等，强制实现了<code>loadClass()</code>，因为如果只实现<code>findClass()</code>, 就会被应用类加载器所加载。</p><p><strong>注：</strong>一般由启动类加载器加载的对象以返回<code>null</code> 来表示该类是由根类加载器加载的。若非根类，则会打印出相关信息。</p><h3 id="关于验证"><a href="#关于验证" class="headerlink" title="关于验证"></a>关于验证</h3><p>验证是连接阶段的第一步，主要确保加载进来的字节流符合JVM规范。虚拟机如果不检查输入的字节流，对齐完全信任的话，很可能会因为载入了有害的字节流而导致系统崩溃，所以验证是虚拟机对自身保护的一项重要工作。<br>验证阶段会完成以下4个阶段的检验动作：</p><ul><li>文件格式验证 ：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的三个验证都是基于方法区的存储结构进行的。</li></ul><ul><li>元数据验证(是否符合Java语言规范) ：对类的元数据信息进行语义校验（其实就是对类中的各数据类型进行语法校验），保证不存在不符合Java语法规范的元数据信息。</li></ul><ul><li>字节码验证（确定程序语义合法，符合逻辑） ：该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。</li></ul><ul><li><p>符号引用验证（确保下一步的解析能正常执行）：这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，后面会有讲解），主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。</p><p>​</p></li></ul><h3 id="关于准备"><a href="#关于准备" class="headerlink" title="关于准备"></a>关于准备</h3><p>准备阶段是正式为类变量分配内存并设置初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这个阶段有两个容易混淆的概念，首先，进行内存分配的仅包括<strong>类变量(被static修饰的变量)</strong>，不包括实例变量，实例变量是在对象实例化的时候分配在Java堆中的。其次这里所说的初始值“通常情况”下是数据类型的零值。</p><p>那么问题来了，到底是什么意思呢？其实就是类变量系统为其设置的默认值，而不是程序员通过代码的初始值。</p><blockquote><p>假如我们定义了一个类变量<code>public static int value = 123;</code></p></blockquote><p>那么，变量<code>value</code> 在准备阶段过后的初始值为0而不是123，因为这时候尚未开始执行任何Java方法，而把<code>value</code> 赋值为123的<code>putstatic</code> 指令是在程序被编译后，存放于类构造器<code>&lt;clinit&gt;()</code> 方法之中，所以把<code>value</code> 赋值为123的动作将在初始化阶段才会执行。</p><p>若有个多个静态变量，则依次按顺序分配空间并赋值。</p><p>关于各种类型的初始值：</p><p><img src="http://blog.stormma.me/2017/11/14/%E4%B8%80%E7%82%B9%E4%B8%80%E6%BB%B4%E6%8E%A2%E7%A9%B6JVM%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/reference.jpg" alt="ç±»ååå§å¼"></p><p>上面说到，在”在通常情况”下初始值为零值，那么相对来说就会有一些“特殊情况”：若类字段的字段属性表中存在<code>ConstantValue</code> 属性，那么在准备阶段变量<code>value</code> 就会被初始化为<code>ConstantValue</code> 属性所指定的值，假设上面类变量定义为：</p><blockquote><p>public static final int value=123;</p></blockquote><p>编译时Javac将会为<code>value</code> 生成<code>ConstantValue</code> 属性，在准备阶段虚拟机就会根据<code>ConstantValue</code> 的设置<code>value</code> 赋值为123。</p><h3 id="关于解析"><a href="#关于解析" class="headerlink" title="关于解析"></a>关于解析</h3><p>解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程。在Class类文件结构一文中已经比较过了符号引用和直接引用的区别和关联，这里不再赘述。前面说解析阶段可能开始于初始化之前，也可能在初始化之后开始，虚拟机会根据需要来判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析（初始化之前），还是等到一个符号引用将要被使用前才去解析它（初始化之后）。</p><ul><li>类或接口的解析：判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析。</li><li>字段解析：对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束。</li></ul><p>对于解析和验证这一块，和读懂Class文件有着密不可分的关系，所以这一块的补充知识会在读懂Class文件字节码之后进行讲解！</p><h3 id="关于初始化"><a href="#关于初始化" class="headerlink" title="关于初始化"></a>关于初始化</h3><p>初始化是类加载过程的最后一步，到了此阶段，才真正开始执行类中定义的Java程序代码。在准备阶段，类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序指定的主观计划去初始化类变量和其他资源。</p><p>或者可以从另一个角度来表达：初始化阶段是执行类构造器<clinit>()方法的过程。</clinit></p><ol><li><clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中(static{})的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句中可以赋值，但是不能访问。</clinit></li><li><clinit>()方法与实例构造器<clinit>()方法（类的构造函数）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的<clinit>()方法执行之前，父类的<clinit>()方法已经执行完毕。因此，在虚拟机中第一个被执行的<clinit>()方法的类肯定是<code>java.lang.Object</code>。</clinit></clinit></clinit></clinit></clinit></li><li><clinit>()方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成()方法。</clinit></li><li>接口中不能使用静态语句块，但仍然有类变量（final static）初始化的赋值操作，因此接口与类一样会生成<clinit>()方法。但是接口鱼类不同的是：执行接口的()方法不需要先执行父接口的<clinit>()方法，只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法。</clinit></clinit></clinit></li><li>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。如果在一个类的<clinit>()方法中有耗时很长的操作，那就可能造成多个线程阻塞，在实际应用中这种阻塞往往是很隐蔽的。</clinit></clinit></clinit></clinit></li></ol><p><em>注：</em>上面说了这么多，我们脑海中必须有个概念，类变量从加载到初始化被赋值了几次？读到这里，我们应该清楚的认识到，至此，类变量已经被赋值也只能被赋值两次了。</p><p>第一次是：连接阶段的准备，赋予类变量系统初始值。  第二次：初始化阶段，赋予程序员给其赋的值。</p><p>这里我们再说一下类变量初始化，类变量初始化时按其顺序执行，什么意思呢？看一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> stormwangxhu.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">staticTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        a=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        a=<span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"a = "</span>+a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码输出结果会是什么呢？1 ？2？还是6。如果你毅然而然的回答了6，那么恭喜你，你真的很6，答案就是6。其原因就是类变量在准备阶段被赋予初始值后，在初始化阶段按其顺序依次向下执行。</p><h4 id="类的初始化步骤"><a href="#类的初始化步骤" class="headerlink" title="类的初始化步骤"></a>类的初始化步骤</h4><ul><li>假如这个类还没有被加载和连接，那就先进行加载和连接。</li><li>假如类存在志杰的父类，且这个父类还没有被初始化，那就先初始化直接的父类。</li><li>假如类中存在初始化语句，那就依次执行这些初始化语句。</li></ul><p>那么Java程序对类的使用主要有两种方式，对类的<strong>主动使用</strong>和<strong>被动使用</strong>。除了以下几种Java程序主动使用类时需要进行初始化，其余都为被动使用，不会导致类的初始化。</p><h4 id="类得初始化时机（主动使用6种）"><a href="#类得初始化时机（主动使用6种）" class="headerlink" title="类得初始化时机（主动使用6种）"></a>类得初始化时机（主动使用6种）</h4><ul><li>使用new 创建类的实例； </li></ul><ul><li>读取或设置类静态字段的时候（但被final修饰的字段，在编译器时就被放入常量池的静态字段除外static final）。</li></ul><ul><li>调用类的静态方法。</li></ul><ul><li>反射 Class.forName(“xxxx”)。 </li></ul><ul><li>初始化一个类的子类。 有父类，先初始化父类（注：1. 接口除外，父接口在调用的时候才会被初始化；2.子类引用父类静态字段，只会引发父类初始化）； </li></ul><p><em>注</em>：当Java 虚拟机初始化一个类时，要求其父类必须先被初始化，但是这条规则不适用于接口。</p><p>（1）、在初始化一个类时，并不会 先初始化它所实现得接口。</p><p>（2）、在初始化一个接口时，并不会初始化它的父接口。</p><p>因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定接口的静态变量时，才会导致该接口的初始化。</p><ul><li>被标明为启动类的类（即包含main()方法的类）要初始化； </li></ul><ul><li>当使用JDK1.7的动态语言支持时，如果一个java.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li></ul><p>以上情况称为对一个类进行<strong>主动引用</strong>，且有且只要以上几种情况（主动使用）需要对类进行初始化。</p><p>此处，是时候去解释我们的那道经典面试题了!</p><h2 id="面试题答案解析"><a href="#面试题答案解析" class="headerlink" title="面试题答案解析"></a>面试题答案解析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        value1++;</span><br><span class="line">        value2++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton singleton = Singleton.getInstance();</span><br><span class="line">        System.out.println(<span class="string">"Singleton1 value1:"</span> + singleton.value1);</span><br><span class="line">        System.out.println(<span class="string">"Singleton1 value2:"</span> + singleton.value2);</span><br><span class="line"></span><br><span class="line">        Singleton2 singleton2 = Singleton2.getInstance2();</span><br><span class="line">        System.out.println(<span class="string">"Singleton2 value1:"</span> + singleton2.value1);</span><br><span class="line">        System.out.println(<span class="string">"Singleton2 value2:"</span> + singleton2.value2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton2 singleton2 = <span class="keyword">new</span> Singleton2();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        value1++;</span><br><span class="line">        value2++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title">getInstance2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Singleton输出结果：1 0</strong> </p><p>原因：</p><blockquote><p>1 、首先执行main中的Singleton singleton = Singleton.getInstance();<br>2、 类的加载：加载类Singleton<br>3、 类的验证<br>4 、类的准备：为静态变量分配内存，设置默认值。这里为singleton(引用类型)设置为null,value1,value2（基本数据类型）设置默认值0<br>5、 类的初始化（按照赋值语句进行修改）：<br>执行private static Singleton singleton = new Singleton();<br>执行Singleton的构造器：value1++;value2++; 此时value1，value2均等于1<br>执行<br><code>public static int value1;</code><br><code>public static int value2 = 0;</code><br>此时value1=1，value2=0</p></blockquote><p><strong>Singleton2输出结果：1  1</strong> </p><p>原因：</p><blockquote><p>1、 首先执行main中的Singleton2 singleton2 = Singleton2.getInstance2();<br>2、 类的加载：加载类Singleton2<br>3、 类的验证<br>4、 类的准备：为静态变量分配内存，设置默认值。这里为value1,value2（基本数据类型）设置默认值0,singleton2(引用类型)设置为null,<br>5、 类的初始化（按照赋值语句进行修改）：<br>执行<br><code>public static int value2 = 0;</code><br>此时value2=0(value1不变，依然是0);<br>执行<br><code>private static Singleton singleton = new Singleton();</code><br>执行Singleton2的构造器：value1++;value2++;<br>此时value1，value2均等于1,即为最后结果</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面说了这么多，如果你有耐心一句一句读完，相信你已经对JVM类加载机制有了一定的认识，那么在面试中，此处有什么考点呢？继续看总结。</p><h3 id="JVM类加载机制常见面试问题"><a href="#JVM类加载机制常见面试问题" class="headerlink" title="JVM类加载机制常见面试问题"></a>JVM类加载机制常见面试问题</h3><h4 id="类的生命周期-1"><a href="#类的生命周期-1" class="headerlink" title="类的生命周期"></a>类的生命周期</h4><p>加载—&gt;连接—&gt;初始化—&gt;使用—&gt;卸载</p><h3 id="Java类加载器"><a href="#Java类加载器" class="headerlink" title="Java类加载器"></a>Java类加载器</h3><p>启动类加载器（C++）—&gt;拓展类加载器（Java）—&gt;应用程序类加载器（Java）—&gt;自定义类加载器</p><p>他们之间的关系为：<strong>双亲委托模型</strong></p><h3 id="双亲委派模型-1"><a href="#双亲委派模型-1" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><h4 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h4><ul><li>首先会先查找当前ClassLoader是否加载过此类，有就返回；</li></ul><ul><li>如果没有，查询父ClassLoader是否已经加载过此类，如果已经加载过,就直接返回Parent加载的类；</li></ul><ul><li>如果整个类加载器体系上的ClassLoader都没有加载过，才由当前ClassLoader加载(调用findClass)，整个过程类似循环链表一样。</li></ul><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li>共享功能，一些Framework层级的类一旦被顶层的ClassLoader加载过就缓存在内存里面，以后任何地方用到都不需要重新加载。</li><li>隔离功能，保证java/Android核心类库的纯净和安全，防止恶意加载。</li></ul><h4 id="打破双亲委托模型"><a href="#打破双亲委托模型" class="headerlink" title="打破双亲委托模型"></a>打破双亲委托模型</h4><ul><li>双亲委派模型的逻辑都在<code>loadClass()</code>中，重写<code>loadClass()</code>，一般是重写<code>findClass()</code>的</li><li>系统自带的三个类加载器都加载特定目录下的类，如果我们自己的类加载器放在一个特殊的目录，那么系统的加载器就无法加载，也就是最终还是由我们自己的加载器加载</li></ul><h4 id="自定义类加载器方法"><a href="#自定义类加载器方法" class="headerlink" title="自定义类加载器方法"></a>自定义类加载器方法</h4><ul><li><code>loadClass(String name,boolean resolve)</code>：根据指定的二进制名称加载类</li></ul><ul><li><code>findClass(String name)</code>： 根据二进制名称来查找类</li></ul><ul><li>直接使用或继承已有的ClassLoader实现：<code>java.net.URLClassLoader</code>、<code>java.security.SecureClassLoader</code>、 <code>java.rmi.server.RMIClassLoader</code></li></ul><ul><li><p>在调用<code>loadClass()</code>，会先根据委派模型在父加载器中加载，如果加载失败，则会调用自己的findClass方法来完成加载</p><p>​</p></li></ul><h3 id="引起类加载操作的五个行为"><a href="#引起类加载操作的五个行为" class="headerlink" title="引起类加载操作的五个行为"></a>引起类加载操作的五个行为</h3><ul><li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令</li></ul><ul><li>反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化</li></ul><ul><li>子类初始化的时候，如果其父类还没初始化，则需先触发其父类的初始化</li></ul><ul><li>虚拟机执行主类的时候(有 main(string[] args))</li></ul><ul><li>JDK1.7 动态语言支持</li></ul><h3 id="Java对象创建时机"><a href="#Java对象创建时机" class="headerlink" title="Java对象创建时机"></a>Java对象创建时机</h3><ul><li>使用new关键字创建对象</li><li>使用Class类的newInstance方法(反射机制)</li><li>使用Constructor类的newInstance方法(反射机制)</li><li>使用Clone方法创建对象</li><li>使用(反)序列化机制创建对象</li></ul><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>JVM的类加载机制，要我来说，也可能有的地方讲的不太正确，如若有疑问或建议，还请各位大佬私信：<a href="https://www.nowcoder.com/profile/3510461" target="_blank" rel="noopener">牛客用户（StormWangxhu)</a>。  </p><p><img src="https://gw.alicdn.com/bao/uploaded/i1/TB18TCMMpXXXXbKXVXXXXXXXXXX_!!0-item_pic.jpg_b.jpg" alt="img"></p><p>再次特意推荐大家去读周志明老师的《深入理解Java虚拟机》，确实不错。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;你的努力终将会有回报，路漫漫其修远兮，吾将上下而求索！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="深入理解Java虚拟机" scheme="https://StormWangxhu.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM 类加载机制" scheme="https://StormWangxhu.github.io/tags/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    
      <category term="ClassLoader" scheme="https://StormWangxhu.github.io/tags/ClassLoader/"/>
    
  </entry>
  
  <entry>
    <title>记头条 Java 实习第一面</title>
    <link href="https://StormWangxhu.github.io/2018/03/30/30--%E8%AE%B0%E5%A4%B4%E6%9D%A1Java%E5%AE%9E%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%9D%A2/"/>
    <id>https://StormWangxhu.github.io/2018/03/30/30--记头条Java实习第一面/</id>
    <published>2018-03-29T16:00:00.000Z</published>
    <updated>2018-04-11T03:04:56.957Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我看好自己的认真！</p></blockquote><p>人生第一次想要在暑假找一个实习来进行锻炼，奈何心有余力不足，技术学的不扎实，在头条第一面，没考算法的前提下，我顺利的挂了，说起来也是心酸。只好再去学了，我知道面试官只是安慰我，说我还有机会，但我也不会气馁！加油吧，少年！</p><p>1.自我介绍</p><p>2.HTTP POST GET 区别(不错)</p><p>3.端口的作用(可以)</p><p>4.HashMap的实现原理(答得不错)，数据量大的时候查询是否影响效率，查询一个元素的时间复杂度(不行)</p><p>5.数据库MySQL索引(不行)</p><p>6.前后端数据如何传递</p><p>7.Ajax(说了了解过)</p><p>8.栈中查找最小元素以及栈结构(不行)</p><p>9.冒泡排序时间复杂度(不行)</p><p>10.问到了项目图书商城实现了哪些功能，怎么想到要做这个项目的。</p><p>11例题，实现一个函数，将一个Map分割出来。</p><p>面试总结:基础知识，如常见数据结构知识不够完备，基础知识不扎实。虽然第一面挂了，但是明白了要学习的方面。面试官说，头条里语言不管是哪一门都可以，一些常见的基础知识得掌握，评论我有短期目标，也有长期目标挺不错的。</p><hr><h2 id="HTTP-中GET-POST请求的区别"><a href="#HTTP-中GET-POST请求的区别" class="headerlink" title="HTTP 中GET POST请求的区别"></a>HTTP 中GET POST请求的区别</h2><p>①get请求用来从服务器上获得资源，而post是用来向服务器提交数据；</p><p>②get将表单中数据按照name=value的形式，添加到action 所指向的URL 后面，并且两者使用”?”连接，而各个变量之间使用”&amp;”连接；post是将表单中的数据放在HTTP协议的请求头或消息体中，传递到action所指向URL；</p><p>③get传输的数据要受到URL长度限制（1024字节即256个字符）；而post可以传输大量的数据，上传文件通常要使用post方式；</p><p>④使用get时参数会显示在地址栏上，如果这些数据不是敏感数据，那么可以使用get；对于敏感数据还是应用使用post；</p><p>⑤get使用MIME类型application/x-www-form-urlencoded的URL编码（也叫百分号编码）文本的格式传递参数，保证被传送的参数由遵循规范的文本组成，例如一个空格的编码是”%20”。</p><p>补充：GET方式提交表单的典型应用是搜索引擎。GET方式就是被设计为查询用的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;我看好自己的认真！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;人生第一次想要在暑假找一个实习来进行锻炼，奈何心有余力不足，技术学的不扎实，在头条第一面，没考算法的前提下，我顺利的挂了，说起来也是心酸。只好再去学了，我知道面试官只是安慰我，说我还有机
      
    
    </summary>
    
      <category term="总结" scheme="https://StormWangxhu.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="实习" scheme="https://StormWangxhu.github.io/tags/%E5%AE%9E%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>初识 Spring AOP</title>
    <link href="https://StormWangxhu.github.io/2018/03/19/19--%E5%88%9D%E8%AF%86-Spring-AOP/"/>
    <id>https://StormWangxhu.github.io/2018/03/19/19--初识-Spring-AOP/</id>
    <published>2018-03-18T16:00:00.000Z</published>
    <updated>2018-03-19T14:33:49.270Z</updated>
    
    <content type="html"><![CDATA[<p>今天初步学习一下Spring。</p><h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><ul><li>Spring AOP—&gt;XML—&gt;Pointcut expression</li><li>Spring AOP—&gt;注解方式—&gt;Pointcut expression</li></ul><p>主要学习一下注解方式。</p><h3 id="主要注解"><a href="#主要注解" class="headerlink" title="主要注解"></a>主要注解</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天初步学习一下Spring。&lt;/p&gt;
&lt;h2 id=&quot;Spring-AOP&quot;&gt;&lt;a href=&quot;#Spring-AOP&quot; class=&quot;headerlink&quot; title=&quot;Spring AOP&quot;&gt;&lt;/a&gt;Spring AOP&lt;/h2&gt;&lt;h3 id=&quot;使用方式&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="Spring" scheme="https://StormWangxhu.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="https://StormWangxhu.github.io/tags/Spring/"/>
    
      <category term="AOP" scheme="https://StormWangxhu.github.io/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb 请求（request）和响应（response）</title>
    <link href="https://StormWangxhu.github.io/2018/03/01/01--JavaWeb-%E8%AF%B7%E6%B1%82%EF%BC%88request%EF%BC%89%E5%92%8C%E5%93%8D%E5%BA%94%EF%BC%88response%EF%BC%89/"/>
    <id>https://StormWangxhu.github.io/2018/03/01/01--JavaWeb-请求（request）和响应（response）/</id>
    <published>2018-02-28T16:00:00.000Z</published>
    <updated>2018-03-17T06:29:49.582Z</updated>
    
    <content type="html"><![CDATA[<p>今天来看看关于JavaWeb中关于和<strong>请求和响应</strong>的知识！</p><h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><h3 id="Response概述"><a href="#Response概述" class="headerlink" title="Response概述"></a>Response概述</h3><p>response是Servlet.service方法的一个参数，类型 为javax.servlet.http.HttpServletResponse。在客户端发出每个请求时，服务器都会创建一个response对象，并传入给Servlet.service()方法。response对象是用来对客户端进行响应的，这说明在service()方法中使用response对象可以完成对客户端的响应工作。</p><p>response对象的功能分为以下四种：</p><ul><li>设置响应头信息；</li></ul><ul><li>发送状态码；</li></ul><ul><li>设置响应正文；</li></ul><ul><li>重定向；</li></ul><h3 id="Response响应正文"><a href="#Response响应正文" class="headerlink" title="Response响应正文"></a>Response响应正文</h3><p>response是响应对象，向客户端输出响应正文（响应体）可以使用response的响应流，repsonse一共提供了两个响应流对象：</p><ul><li>PrintWriter out = response.getWriter()：获取字符流；</li></ul><ul><li><p>ServletOutputStream out = response.getOutputStream()：获取字节流；</p><p>当然，如果响应正文内容为字符，那么使用response.getWriter()，如果响应内容是字节，例如下载时，那么可以使用response.getOutputStream()。</p></li></ul><p>注意，在一个请求中，不能同时使用这两个流！也就是说，要么你使用repsonse.getWriter()，要么使用response.getOutputStream()，但不能同时使用这两个流。不然会抛出<a href="http://java.sun.com/j2se/1.5/docs/api/java/lang/IllegalStateException.html" target="_blank" rel="noopener">IllegalStateException</a>异常。</p><h4 id="字符响应流"><a href="#字符响应流" class="headerlink" title="字符响应流"></a>字符响应流</h4><ul><li>字符编码</li></ul><p>在使用response.getWriter()时需要注意默认字符编码为ISO-8859-1，如果希望设置字符流的字符编码为utf-8，可以使用response.setCharaceterEncoding(“utf-8”)来设置。这样可以保证输出给客户端的字符都是使用UTF-8编码的！</p><p>但客户端浏览器并不知道响应数据是什么编码的！如果希望通知客户端使用UTF-8来解读响应数据，那么还是使用response.setContentType(“text/html;charset=utf-8”)方法比较好，因为这个方法不只会调用response.setCharaceterEncoding(“utf-8”)，还会设置content-type响应头，客户端浏览器会使用content-type头来解读响应数据。</p><ul><li>缓冲区</li></ul><p>response.getWriter()是PrintWriter类型，所以它有缓冲区，缓冲区的默认大小为8KB。也就是说，在响应数据没有输出8KB之前，数据都是存放在缓冲区中，而不会立刻发送到客户端。当Servlet执行结束后，服务器才会去刷新流，使缓冲区中的数据发送到客户端。</p><p>如果希望响应数据马上发送给客户端：</p><ul><li><ul><li>向流中写入大于8KB的数据；</li></ul></li></ul><ul><li><ul><li>调用response.flushBuffer()方法来手动刷新缓冲区；</li></ul></li></ul><h3 id="设置响应头信息"><a href="#设置响应头信息" class="headerlink" title="设置响应头信息"></a>设置响应头信息</h3><p>可以使用response对象的setHeader()方法来设置响应头！使用该方法设置的响应头最终会发送给客户端浏览器！</p><ul><li>response.setHeader(“content-type”, “text/html;charset=utf-8”)：设置content-type响应头，该头的作用是告诉浏览器响应内容为html类型，编码为utf-8。而且同时会设置response的字符流编码为utf-8，即response.setCharaceterEncoding(“utf-8”)；</li></ul><ul><li>response.setHeader(“Refresh”,”5; URL=<a href="http://www.baidu.com&quot;)：5秒后自动跳转到百度主页。" target="_blank" rel="noopener">http://www.baidu.com&quot;)：5秒后自动跳转到百度主页。</a></li></ul><h3 id="设置状态码及其他方法"><a href="#设置状态码及其他方法" class="headerlink" title="设置状态码及其他方法"></a>设置状态码及其他方法</h3><ul><li>response.setContentType(“text/html;charset=utf-8”)：等同与调用response.setHeader(“content-type”, “text/html;charset=utf-8”)；</li></ul><ul><li>response.setCharacterEncoding(“utf-8”)：设置字符响应流的字符编码为utf-8； </li></ul><ul><li>response.setStatus(200)：设置状态码；</li></ul><ul><li>response.sendError(404, “您要查找的资源不存在”)：当发送错误状态码时，Tomcat会跳转到固定的错误页面去，但可以显示错误信息。</li></ul><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><h4 id="什么是重定向"><a href="#什么是重定向" class="headerlink" title="什么是重定向"></a>什么是重定向</h4><p>当你访问<a href="http://www.sun.com时，你会发现浏览器地址栏中的URL会变成http://www.oracle.com/us/sun/index.htm，这就是重定向了。重定向是服务器通知浏览器去访问另一个地址，即再发出另一个请求。" target="_blank" rel="noopener">http://www.sun.com时，你会发现浏览器地址栏中的URL会变成http://www.oracle.com/us/sun/index.htm，这就是重定向了。重定向是服务器通知浏览器去访问另一个地址，即再发出另一个请求。</a></p><p><img src="//img-blog.csdn.net/20180317133703765?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L1N0b3JtV2FuZ3hodQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><h4 id="完成重定向"><a href="#完成重定向" class="headerlink" title="完成重定向"></a>完成重定向</h4><p>响应码为200表示响应成功，而响应码为302表示重定向。所以完成重定向的第一步就是设置响应码为302。因为重定向是通知浏览器再第二个请求，所以浏览器需要知道第二个请求的URL，所以完成重定向的第二步是设置Location头，指定第二个请求的URL地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">response.setStatus(<span class="number">302</span>);<span class="comment">//设置响应码为302，表示重定向</span></span><br><span class="line">response.setHeader(<span class="string">"Location"</span>, <span class="string">"http://www.baidu.com"</span>);<span class="comment">//设置新请求的URL</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的作用是：当访问AServlet后，会通知浏览器重定向到传智主页。客户端浏览器解析到响应码为302后，就知道服务器让它重定向，所以它会马上获取响应头Location，然发出第二个请求。</p><h4 id="便捷的重定向方式"><a href="#便捷的重定向方式" class="headerlink" title="便捷的重定向方式"></a>便捷的重定向方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">response.sendRedirect(<span class="string">"http://www.itcast.cn"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>response.sendRedirect()方法会设置响应头为302，以设置Location响应头。如果要重定向的URL是在同一个服务器内，那么可以使用相对路径，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">response.sendRedirect(<span class="string">"/hello/BServlet"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重定向的URL地址为：<a href="http://localhost:8080/hello/BServlet。" target="_blank" rel="noopener">http://localhost:8080/hello/BServlet。</a></p><h4 id="重定向小结"><a href="#重定向小结" class="headerlink" title="重定向小结"></a>重定向小结</h4><ul><li>重定向是两次请求；</li></ul><ul><li>重定向的URL可以是其他应用，不局限于当前应用；</li></ul><ul><li>重定向的响应头为302，并且必须要有Location响应头；</li></ul><ul><li>重定向就不要再使用response.getWriter()或response.getOutputStream()输出数据，不然可能会出现异常；</li></ul><h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><h3 id="Request概述"><a href="#Request概述" class="headerlink" title="Request概述"></a>Request概述</h3><p>request是Servlet.service()方法的一个参数，类型为javax.servlet.http.HttpServletRequest。在客户端发出每个请求时，服务器都会创建一个request对象，并把请求数据封装到request中，然后在调用Servlet.service()方法时传递给service()方法，这说明在service()方法中可以通过request对象来获取请求数据。</p><p>request的功能可以分为以下几种：</p><ul><li>封装了请求头数据；</li></ul><ul><li>封装了请求正文数据，如果是GET请求，那么就没有正文；</li></ul><ul><li>request是一个域对象，可以把它当成Map来添加获取数据；</li></ul><ul><li>request提供了请求转发和请求包含功能。</li></ul><h3 id="Request域方法"><a href="#Request域方法" class="headerlink" title="Request域方法"></a>Request域方法</h3><p>request是域对象！在JavaWeb中一共四个域对象，其中ServletContext就是域对象，它在整个应用中只创建一个ServletContext对象。request其中一个，request可以在一个请求中共享数据。一个请求会创建一个request对象，如果在一个请求中经历了多个Servlet，那么多个Servlet就可以使用request来共享数据。现在我们还不知道如何在一个请求中经历之个Servlet，后面在学习请求转发和请求包含后就知道了。下面是request的域方法：</p><ul><li>void setAttribute(String name, Object value)：用来存储一个对象，也可以称之为存储一个域属性，例如：servletContext.setAttribute(“xxx”, “XXX”)，在request中保存了一个域属性，域属性名称为xxx，域属性的值为XXX。请注意，如果多次调用该方法，并且使用相同的name，那么会覆盖上一次的值，这一特性与Map相同；</li></ul><ul><li>Object getAttribute(String name)：用来获取request中的数据，当前在获取之前需要先去存储才行，例如：String value = (String)request.getAttribute(“xxx”);，获取名为xxx的域属性；</li></ul><ul><li>void removeAttribute(String name)：用来移除request中的域属性，如果参数name指定的域属性不存在，那么本方法什么都不做；</li></ul><ul><li>Enumeration getAttributeNames()：获取所有域属性的名称；</li></ul><h3 id="Resquest域获取请求头数据"><a href="#Resquest域获取请求头数据" class="headerlink" title="Resquest域获取请求头数据"></a>Resquest域获取请求头数据</h3><p>request与请求头相关的方法有：</p><ul><li>String getHeader(String name)：获取指定名称的请求头；</li></ul><ul><li>Enumeration getHeaderNames()：获取所有请求头名称；</li></ul><ul><li>int getIntHeader(String name)：获取值为int类型的请求头。</li></ul><h3 id="Request获取请求相关的其他方法"><a href="#Request获取请求相关的其他方法" class="headerlink" title="Request获取请求相关的其他方法"></a>Request获取请求相关的其他方法</h3><p>equest中还提供了与请求相关的其他方法，有些方法是为了我们更加便捷的方法请求头数据而设计，有些是与请求URL相关的方法。</p><p>l int getContentLength()：获取请求体的字节数，GET请求没有请求体，没有请求体返回-1；</p><p>l String getContentType()：获取请求类型，如果请求是GET，那么这个方法返回null；如果是POST请求，那么默认为application/x-www-form-urlencoded，表示请求体内容使用了URL编码；</p><p>l String getMethod()：返回请求方法，例如：GET</p><p>l Locale getLocale()：返回当前客户端浏览器的Locale。java.util.Locale表示国家和言语，这个东西在国际化中很有用；</p><p>l String getCharacterEncoding()：获取请求编码，如果没有setCharacterEncoding()，那么返回null，表示使用ISO-8859-1编码；</p><p>l void setCharacterEncoding(String code)：设置请求编码，只对请求体有效！注意，对于GET而言，没有请求体！！！所以此方法只能对POST请求中的参数有效！</p><ul><li>String getContextPath()：返回上下文路径，例如：/hello</li></ul><ul><li>String getQueryString()：返回请求URL中的参数，例如：name=zhangSan</li></ul><ul><li>String getRequestURI()：返回请求URI路径，例如：/hello/oneServlet</li></ul><ul><li>StringBuffer getRequestURL()：返回请求URL路径，例如：<a href="http://localhost/hello/oneServlet，即返回除了参数以外的路径信息；" target="_blank" rel="noopener">http://localhost/hello/oneServlet，即返回除了参数以外的路径信息；</a></li></ul><ul><li>String getServletPath()：返回Servlet路径，例如：/oneServlet</li></ul><ul><li>String getRemoteAddr()：返回当前客户端的IP地址；</li></ul><ul><li>String getRemoteHost()：返回当前客户端的主机名，但这个方法的实现还是获取IP地址；</li></ul><ul><li>String getScheme()：返回请求协议，例如：http；</li></ul><ul><li>String getServerName()：返回主机名，例如：localhost</li></ul><ul><li>int getServerPort()：返回服务器端口号，例如：8080</li></ul><p><img src="//img-blog.csdn.net/20180317134717324?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L1N0b3JtV2FuZ3hodQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"request.getContentLength(): "</span> + request.getContentLength());</span><br><span class="line">System.out.println(<span class="string">"request.getContentType(): "</span> + request.getContentType());</span><br><span class="line">System.out.println(<span class="string">"request.getContextPath(): "</span> + request.getContextPath());</span><br><span class="line">System.out.println(<span class="string">"request.getMethod(): "</span> + request.getMethod());</span><br><span class="line">System.out.println(<span class="string">"request.getLocale(): "</span> + request.getLocale());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"request.getQueryString(): "</span> + request.getQueryString());</span><br><span class="line">System.out.println(<span class="string">"request.getRequestURI(): "</span> + request.getRequestURI());</span><br><span class="line">System.out.println(<span class="string">"request.getRequestURL(): "</span> + request.getRequestURL());</span><br><span class="line">System.out.println(<span class="string">"request.getServletPath(): "</span> + request.getServletPath());</span><br><span class="line">System.out.println(<span class="string">"request.getRemoteAddr(): "</span> + request.getRemoteAddr());</span><br><span class="line">System.out.println(<span class="string">"request.getRemoteHost(): "</span> + request.getRemoteHost());</span><br><span class="line">System.out.println(<span class="string">"request.getRemotePort(): "</span> + request.getRemotePort());</span><br><span class="line">System.out.println(<span class="string">"request.getScheme(): "</span> + request.getScheme());</span><br><span class="line">System.out.println(<span class="string">"request.getServerName(): "</span> + request.getServerName());</span><br><span class="line">System.out.println(<span class="string">"request.getServerPort(): "</span> + request.getServerPort());</span><br></pre></td></tr></table></figure><h4 id="案例：4-1-案例：request-getRemoteAddr-：封IP"><a href="#案例：4-1-案例：request-getRemoteAddr-：封IP" class="headerlink" title="案例：4.1　案例：request.getRemoteAddr()：封IP"></a>案例：4.1　案例：request.getRemoteAddr()：封IP</h4><p>可以使用request.getRemoteAddr()方法获取客户端的IP地址，然后判断IP是否为禁用IP。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String ip = request.getRemoteAddr();</span><br><span class="line">System.out.println(ip);</span><br><span class="line"><span class="keyword">if</span>(ip.equals(<span class="string">"127.0.0.1"</span>)) &#123;</span><br><span class="line">response. getWriter().print(<span class="string">"您的IP已被禁止！"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">response.getWriter().print(<span class="string">"Hello!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Request获取请求参数"><a href="#Request获取请求参数" class="headerlink" title="Request获取请求参数"></a>Request获取请求参数</h3><p>最为常见的客户端传递参数方式有两种：</p><ul><li>浏览器地址栏直接输入：一定是GET请求；</li></ul><ul><li>超链接：一定是GET请求；</li></ul><ul><li><p>表单：可以是GET，也可以是POST，这取决与<form>的method属性值；</form></p><h4 id="GET请求和POST请求的区别："><a href="#GET请求和POST请求的区别：" class="headerlink" title="GET请求和POST请求的区别："></a>GET请求和POST请求的区别：</h4></li><li><p>GET请求：</p></li></ul><p>** 请求参数会在浏览器的地址栏中显示，所以不安全；</p><p>** 请求参数长度限制长度在1K之内；</p><p>** GET请求没有请求体，无法通过request.setCharacterEncoding()来设置参数的编码；</p><ul><li>POST请求：</li></ul><p>** 请求参数不会显示浏览器的地址栏，相对安全；</p><p>** 请求参数长度没有限制；</p><p>下面是使用request获取请求参数的API：</p><ul><li><p>String getParameter(String name)：通过指定名称获取参数值；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> doGet[点击超链接是GET请求，所以会执行doGet()方法](HttpServletRequest request, HttpServletResponse response)</span><br><span class="line"><span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">String v1 = request.getParameter(<span class="string">"p1"</span>);</span><br><span class="line">String v2 = request.getParameter(<span class="string">"p2"</span>);</span><br><span class="line">System.out.println(<span class="string">"p1="</span> + v1);</span><br><span class="line">System.out.println(<span class="string">"p2="</span> + v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> doPost[提交表单是POST请求，所以会调用doPost()方法](HttpServletRequest request, HttpServletResponse response)</span><br><span class="line"><span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">String v1 = request.getParameter(<span class="string">"p1"</span>);</span><br><span class="line">String v2 = request.getParameter(<span class="string">"p2"</span>);</span><br><span class="line">System.out.println(<span class="string">"p1="</span> + v1);</span><br><span class="line">System.out.println(<span class="string">"p2="</span> + v2);</span><br></pre></td></tr></table></figure></li><li><p>String[] getParameterValues(String name)：当多个参数名称相同时，可以使用方法来获取；</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href="/hello/ParamServlet?name=zhangSan&amp;name=liSi[多个名为name的参数]"&gt;超链接&lt;/a&gt;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">String[] names = request.getParameterValues(<span class="string">"name"</span>);<span class="comment">//获取所有名为name的参数值</span></span><br><span class="line">System.out.println(Arrays.toString(names));<span class="comment">//打印数组，输出结果为：[zhangSan, liSi]]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Enumeration getParameterNames()：获取所有参数的名字。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   &lt;form action=<span class="string">"/hello/ParamServlet"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">   参数<span class="number">1</span>：&lt;input type=<span class="string">"text"</span> name=<span class="string">"p1"</span>/&gt;&lt;br/&gt;</span><br><span class="line">   参数<span class="number">2</span>：&lt;input type=<span class="string">"text"</span> name=<span class="string">"p2"</span>/&gt;&lt;br/&gt;</span><br><span class="line">   &lt;input type=<span class="string">"submit"</span> value=<span class="string">"提交"</span>/&gt;</span><br><span class="line">   &lt;/form&gt;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">Enumeration names = request.getParameterNames()[获取所有参数名称，输出结果为：p1和p2];</span><br><span class="line"><span class="keyword">while</span>(names.hasMoreElements()) &#123;</span><br><span class="line">System.out.println(names.nextElement());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Map getParameterMap()：获取所有参数封装到Map中，其中key为参数名，value为参数值，因为一个参数名称可能有多个值，所以参数值是String[]，而不是String。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href="/day05_1/ParamServlet?p1=v1&amp;p1=vv1&amp;p2=v2&amp;p2=vv2"&gt;超链接&lt;/a&gt;</span><br><span class="line">Map&lt;String,String[]&gt; paramMap = request.getParameterMap();</span><br><span class="line"><span class="keyword">for</span>(String name : paramMap.keySet()) &#123;</span><br><span class="line">String[] values = paramMap.get(name);</span><br><span class="line">System.out.println(name + <span class="string">": "</span> + Arrays.toString(values));</span><br><span class="line">&#125;</span><br><span class="line">p2: [v2, vv2]</span><br><span class="line">p1: [v1, vv1]</span><br></pre></td></tr></table></figure><h3 id="请求转发和请求包含"><a href="#请求转发和请求包含" class="headerlink" title="请求转发和请求包含"></a>请求转发和请求包含</h3><p>无论是请求转发还是请求包含，都表示由多个Servlet共同来处理一个请求。例如Servlet1来处理请求，然后Servlet1又转发给Servlet2来继续处理这个请求。</p><h4 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h4><p>在AServlet中，把请求转发到BServlet：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"AServlet"</span>);</span><br><span class="line">RequestDispatcher rd = request.getRequestDispatcher(<span class="string">"/BServlet"</span>);<span class="comment">//获取“调度器”，其中参数为BServlet绑定的URL，即BServlet的&lt;url-pattern&gt;值。]</span></span><br><span class="line">rd.forward(request, response)<span class="comment">//调用“调度器”的转发方法，该方法等同与告诉服务器，去调用BServlet的service()方法一样。];</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"BServlet"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Aservlet</span><br><span class="line">BServlet</span><br></pre></td></tr></table></figure><h4 id="请求包含"><a href="#请求包含" class="headerlink" title="请求包含"></a>请求包含</h4><p>在AServlet中，把请求包含到BServlet：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"AServlet"</span>);</span><br><span class="line">RequestDispatcher rd = request.getRequestDispatcher(<span class="string">"/BServlet"</span>);</span><br><span class="line">rd.include[请求包含](request, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"BServlet"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Aservlet</span><br><span class="line">BServlet</span><br></pre></td></tr></table></figure><h4 id="请求转发和请求包含比较"><a href="#请求转发和请求包含比较" class="headerlink" title="请求转发和请求包含比较"></a>请求转发和请求包含比较</h4><ul><li>如果在AServlet中请求转发到BServlet，那么在AServlet中就不允许再输出响应体，即不能再使用response.getWriter()和response.getOutputStream()向客户端输出，这一工作应该由BServlet来完成；如果是使用请求包含，那么没有这个限制；</li></ul><ul><li>请求转发虽然不能输出响应体，但还是可以设置响应头的，例如：response.setContentType(”text/html;charset=utf-8”);</li></ul><ul><li>请求包含大多是应用在JSP页面中，完成多页面的合并；</li></ul><ul><li>请求请求大多是应用在Servlet中，转发目标大多是JSP页面；</li></ul><p><img src="//img-blog.csdn.net/20180317140245809?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L1N0b3JtV2FuZ3hodQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><h4 id="请求转发与重定向比较"><a href="#请求转发与重定向比较" class="headerlink" title="请求转发与重定向比较"></a>请求转发与重定向比较</h4><ul><li>请求转发是一个请求，而重定向是两个请求；</li></ul><ul><li>请求转发后浏览器地址栏不会有变化，而重定向会有变化，因为重定向是两个请求；</li></ul><ul><li>请求转发的目标只能是本应用中的资源，重定向的目标可以是其他应用；</li></ul><ul><li>请求转发对AServlet和BServlet的请求方法是相同的，即要么都是GET，要么都是POST，因为请求转发是一个请求；</li></ul><ul><li>重定向的第二个请求一定是GET</li></ul><h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><h3 id="与路径相关的操作"><a href="#与路径相关的操作" class="headerlink" title="与路径相关的操作"></a>与路径相关的操作</h3><ul><li>超链接</li></ul><ul><li>表单</li></ul><ul><li>转发</li></ul><ul><li>包含</li></ul><ul><li>重定向</li></ul><ul><li><url-pattern></url-pattern></li></ul><ul><li>ServletContext获取资源</li></ul><ul><li>Class获取资源</li></ul><ul><li>ClassLoader获取资源</li></ul><h3 id="客户端路径"><a href="#客户端路径" class="headerlink" title="客户端路径"></a>客户端路径</h3><p>超链接、表单、重定向都是客户端路径，客户端路径可以分为三种方式：</p><ul><li>绝对路径；</li></ul><ul><li>以“/”开头的相对路径；</li></ul><ul><li>不以“/”开头的相对路径；</li></ul><p>例如：<a href="http://localhost:8080/hello1/pages/a.html中的超链接和表单如下：" target="_blank" rel="noopener">http://localhost:8080/hello1/pages/a.html中的超链接和表单如下：</a></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">绝对路径：&lt;a href="http://localhost:8080/hello2/index.html"&gt;链接1&lt;/a&gt;</span><br><span class="line">客户端路径：&lt;a href="/hello3/pages/index.html"&gt;链接2&lt;/a&gt;</span><br><span class="line">相对路径：&lt;a href="index.html"&gt;链接3&lt;/a&gt;</span><br><span class="line">&lt;hr/&gt;</span><br><span class="line">绝对路径：</span><br><span class="line">&lt;form action=<span class="string">"http://localhost:8080/hello2/index.html"</span>&gt;</span><br><span class="line">  &lt;input type=<span class="string">"submit"</span> value=<span class="string">"表单1"</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">客户端路径：</span><br><span class="line">&lt;form action=<span class="string">"/hello2/index.html"</span>&gt;</span><br><span class="line">  &lt;input type=<span class="string">"submit"</span> value=<span class="string">"表单2"</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">相对路径：</span><br><span class="line">&lt;form action=<span class="string">"index.html"</span>&gt;</span><br><span class="line">  &lt;input type=<span class="string">"submit"</span> value=<span class="string">"表单3"</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><ul><li>链接1和表单1：没什么可说的，它使用绝对路径；</li></ul><ul><li>链接2和表单2：以“/”开头，相对主机，与当前a.html的主机相同，即最终访问的页面为<a href="http://localhost:8080/hello2/index.html；" target="_blank" rel="noopener">http://localhost:8080/hello2/index.html；</a></li></ul><ul><li>链接3和表单3：不以“/”开头，相对当前页面的路径，即a.html所有路径，即最终访问的路径为：<a href="http://localhost:8080/hello1/pages/index.html；" target="_blank" rel="noopener">http://localhost:8080/hello1/pages/index.html；</a></li></ul><p>重定向1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">response.sendRedirect(<span class="string">"/hello/index.html"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设访问AServlet的路径为：<a href="http://localhost:8080/hello/servlet/AServlet" target="_blank" rel="noopener">http://localhost:8080/hello/servlet/AServlet</a></p><p>因为路径以“/”开头，所以相对当前主机，即<a href="http://localhost:8080/hello/index.html。" target="_blank" rel="noopener">http://localhost:8080/hello/index.html。</a></p><p>重定向2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">response.sendRedirect(<span class="string">"index.html"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设访问AServlet的路径为：<a href="http://localhost:8080/hello/servlet/AServlet" target="_blank" rel="noopener">http://localhost:8080/hello/servlet/AServlet</a></p><p>因为路径不以“/”开头，所以相对当前路径，即<a href="http://localhost:8080/hello/servlet/index.html" target="_blank" rel="noopener">http://localhost:8080/hello/servlet/index.html</a></p><h5 id="建议使用“-”"><a href="#建议使用“-”" class="headerlink" title="建议使用“/”"></a>建议使用“/”</h5><p>强烈建议使用“/”开头的路径，这说明在页面中的超链接和表单都要以“/”开头，后面是当前应用的名称，再是访问路径：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/hello/servlet/AServlet"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/hello/b.html"</span>&gt;</span>链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中/hello是当前应用名称，这也说明如果将来修改了应用名称，那么页面中的所有路径也要修改，这一点确实是个问题。这一问题的处理方案会在学习了JSP之后讲解！在Servlet中的重定向也建议使用“/”开头。同理，也要给出应用的名称！例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.sendRedirect(<span class="string">"/hello/BServlet"</span>);</span><br></pre></td></tr></table></figure><p>其中/hello是当前应用名，如果将来修改了应用名称，那么也要修改所有重定向的路径，这一问题的处理方案是使用request.getContextPath()来获取应用名称。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.sendRedirect(request.getContextPath() + <span class="string">"/BServlet"</span>);</span><br></pre></td></tr></table></figure><h3 id="服务器端路径"><a href="#服务器端路径" class="headerlink" title="服务器端路径"></a>服务器端路径</h3><p>服务器端路径必须是相对路径，不能是绝对路径。但相对路径有两种形式：</p><ul><li>以“/”开头；</li></ul><ul><li><p>不以“/”开头；</p><p>其中请求转发、请求包含都是服务器端路径，服务器端路径与客户端路径的区别是：</p></li><li><p>客户端路径以“/”开头：相对当前主机；</p></li></ul><ul><li><p>服务器端路径以“/”开头：相对当前应用；</p><p>转发1：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">request.getRequestDispatcher(<span class="string">"/BServlet"</span>).forward(request, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设访问AServlet的路径为：<a href="http://localhost:8080/hello/servlet/AServlet" target="_blank" rel="noopener">http://localhost:8080/hello/servlet/AServlet</a></p><p>因为路径以“/”开头，所以相对当前应用，即<a href="http://localhost:8080/hello/BServlet。" target="_blank" rel="noopener">http://localhost:8080/hello/BServlet。</a></p><p>转发2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">request.getRequestDispatcher(<span class="string">"BServlet"</span>).forward(request, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设访问AServlet的路径为：<a href="http://localhost:8080/hello/servlet/AServlet" target="_blank" rel="noopener">http://localhost:8080/hello/servlet/AServlet</a></p><p>因为路径不以“/”开头，所以相对当前应用，即<a href="http://localhost:8080/hello/servlet/BServlet。" target="_blank" rel="noopener">http://localhost:8080/hello/servlet/BServlet。</a></p><h3 id="路径-1"><a href="#路径-1" class="headerlink" title="路径"></a><url-pattern>路径</url-pattern></h3><p><url-pattern>必须使用“/”开头，并且相对的是当前应用.</url-pattern></p><h3 id="ServletContext获取资源"><a href="#ServletContext获取资源" class="headerlink" title="ServletContext获取资源"></a>ServletContext获取资源</h3><h3 id="Class-获取资源必须是相对路径，可以“-”开头，也可以不使用“-”开头，但无论是否使用“-”开头都是相对当前应用路径。"><a href="#Class-获取资源必须是相对路径，可以“-”开头，也可以不使用“-”开头，但无论是否使用“-”开头都是相对当前应用路径。" class="headerlink" title="Class 获取资源必须是相对路径，可以“/”开头，也可以不使用“/”开头，但无论是否使用“/”开头都是相对当前应用路径。"></a>Class 获取资源必须是相对路径，可以“/”开头，也可以不使用“/”开头，但无论是否使用“/”开头都是相对当前应用路径。</h3><p>例如在AServlet中获取资源，AServlet的路径路径为：<a href="http://localhost:8080/hello/servlet/AServlet：" target="_blank" rel="noopener">http://localhost:8080/hello/servlet/AServlet：</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">String path1 = <span class="keyword">this</span>.getServletContext().getRealPath(<span class="string">"a.txt"</span>);</span><br><span class="line">String path2 = <span class="keyword">this</span>.getServletContext().getRealPath(<span class="string">"/a.txt"</span>);</span><br><span class="line">System.out.println(path1);</span><br><span class="line">System.out.println(path2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>path1和path2是相同的结果：<a href="http://localhost:8080/hello/a.txt" target="_blank" rel="noopener">http://localhost:8080/hello/a.txt</a></p><h3 id="Class获取资源"><a href="#Class获取资源" class="headerlink" title="Class获取资源"></a>Class获取资源</h3><p>Class获取资源也必须是相对路径，可以“/”开头，也可以不使用“/”开头。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">InputStream in = Demo.class.getResourceAsStream(<span class="string">"/a.txt"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">InputStream in = Demo.class.getResourceAsStream(<span class="string">"a.txt"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中fun1()方法获取资源时以“/”开头，那么相对的是当前类路径，即/hello/WEB-INF/classes/a.txt文件；其中fun2()方法获取资源时没有以“/”开头，那么相对当前Demo.class所在路径，因为Demo类在cn.itcast包下，所以资源路径为：/hello/WEB-INF/classes/cn/itcast/a.txt。</p><h3 id="ClassLoader获取资源"><a href="#ClassLoader获取资源" class="headerlink" title="ClassLoader获取资源"></a>ClassLoader获取资源</h3><p>ClassLoader获取资源也必须是相对路径，可以“/”开头，也可以不使用“/”开头。但无论是否以“/”开头，资源都是相对当前类路径.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">InputStream in = Demo.class.getClassLoader().getResourceAsStream(<span class="string">"/a.txt"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">InputStream in = Demo.class.getClassLoader().getResourceAsStream(<span class="string">"a.txt"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fun1()和fun2()方法的资源都是相对类路径，即classes目录，即/hello/WEB-INF/classes/a.txt</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h3 id="请求编码"><a href="#请求编码" class="headerlink" title="请求编码"></a>请求编码</h3><h4 id="直接在地址栏中给出中文"><a href="#直接在地址栏中给出中文" class="headerlink" title="直接在地址栏中给出中文"></a>直接在地址栏中给出中文</h4><p>请求数据是由客户端浏览器发送服务器的，请求数据的编码是由浏览器决定的。例如在浏览器地址栏中给出：<a href="http://localhost:8080/hello/AServlet?name=传智，那么其中“传智”是什么编码的呢？不同浏览器使用不同的编码，所以这是不确定的！" target="_blank" rel="noopener">http://localhost:8080/hello/AServlet?name=传智，那么其中“传智”是什么编码的呢？不同浏览器使用不同的编码，所以这是不确定的！</a></p><ul><li>IE：使用GB2312；</li></ul><ul><li>FireFox：使用GB2312；</li></ul><ul><li>Chrome：使用UTF-8；</li></ul><p>通常没有哪个应用要求用户在浏览器地址栏中输入请求数据的，所以大家只需了解一下即可。</p><h4 id="在页面中发出请求"><a href="#在页面中发出请求" class="headerlink" title="在页面中发出请求"></a>在页面中发出请求</h4><p>通常向服务器发送请求数据都需要先请求一个页面，然后用户在页面中输入数据。页面中有超链接和表单，通过超链接和表单就可以向服务器发送数据了。因为页面是服务器发送到客户端浏览器的，所以这个页面本身的编码由服务器决定。而用户在页面中输入的数据也是由页面本身的编码决定的。</p><p>index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>index.html<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"content-type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span>[这就相当于给客户端发送了响应头content-type，指定当前页面的编码为utf-8]</span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/hello/servlet/AServlet"</span>&gt;</span></span><br><span class="line">  名称:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/hello/servlet/AServlet?name=传智"</span>&gt;</span>链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当用户在index.html页面中输入数据时，都是UTF-8列表的。因为这个页面本身就是UTF-8编码的！</p><p><strong>页面的编译就是页面中输入数据的编码。</strong></p><h4 id="GET请求解读编码"><a href="#GET请求解读编码" class="headerlink" title="GET请求解读编码"></a>GET请求解读编码</h4><p>当客户端通过GET请求发送数据给服务器时，使用request.getParameter()获取的数据是被服务器误认为ISO-8859-1编码的，也就是说客户端发送过来的数据无论是UTF-8还是GBK，服务器都认为是ISO-8859-1，这就说明我们需要在使用request.getParameter()获取数据后，再转发成正确的编码。</p><p>例如客户端以UTF-8发送的数据，使用如下转码方式：</p><p>String name = request.getParameter(“name”);</p><p>name = new String(name.getBytes(“iso-8859-1”), “utf-8”);</p><h4 id="POST请求解读编码"><a href="#POST请求解读编码" class="headerlink" title="POST请求解读编码"></a>POST请求解读编码</h4><p>　　当客户端通过POST请求发送数据给服务器时，可以在使用request.getParameter()获取请求参数之前先通过request.setCharacterEncoding()来指定编码，然后再使用reuqest.getParameter()方法来获取请求参数，那么就是用指定的编码来读取了。</p><p>也就是说，如果是POST请求，服务器可以指定编码！但如果没有指定编码，那么默认还是使用ISO-8859-1来解读。</p><p>request.setCharacterEncoding(“utf-8”);</p><p>String name = request.getParameter(“name”);</p><h3 id="响应编码"><a href="#响应编码" class="headerlink" title="响应编码"></a>响应编码</h3><p>响应：服务器发送给客户端数据！响应是由response对象来完成，如果响应的数据不是字符数据，那么就无需去考虑编码问题。当然，如果响应的数据是字符数据，那么就一定要考虑编码的问题了。</p><p>response.getWriter().print(“传智”);</p><p>上面代码因为没有设置repsonse.getWriter()字符流的编码，所以服务器使用默认的编码（ISO-8859-1）来处理，因为ISO-8859-1不支持中文，所以一定会出现编码的。</p><p>所以在使用response.getWriter()发送数据之前，一定要设置response.getWriter()的编码，这需要使用response.setCharacterEncoding()方法：</p><p>response.setCharacterEncoding(“utf-8”);</p><p>response.getWriter().print(“传智”);</p><p>上面代码因为在使用response.getWriter()输出之前已经设置了编码，所以输出的数据为utf-8编码。但是，因为没有告诉浏览器使用什么编码来读取响应数据，所以很可能浏览器会出现错误的解读，那么还是会出现乱码的。当然，通常浏览器都支持来设置当前页面的编码，如果用户在看到编码时，去设置浏览器的编码，如果设置的正确那么乱码就会消失。但是我们不能让用户总去自己设置编码，而且应该直接通知浏览器，服务器发送过来的数据是什么编码，这样浏览器就直接使用服务器告诉他的编码来解读！这需要使用content-type响应头。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(“text/html;charset=utf-8”);</span><br><span class="line">response.getWriter().print(“传智”);</span><br></pre></td></tr></table></figure><p>　　上面代码使用setContentType()方法设置了响应头content-type编码为utf-8，这不只是在响应中添加了响应头，还等于调用了一次response.setCharacterEncoding(“utf-8”)，也就是说，通过我们只需要调用一次response.setContentType(“text/html;charset=utf-8”)即可，而无需再去调用response.setCharacterEncoding(“utf-8”)了。</p><p> 在静态页面中，使用<meta>来设置content-type响应头，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"content-type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="URL编码"><a href="#URL编码" class="headerlink" title="URL编码"></a>URL编码</h3><p>通过页面传输数据给服务器时，如果包含了一些特殊字符是无法发送的。这时就需要先把要发送的数据转换成URL编码格式，再发送给服务器。</p><p>其实需要我们自己动手给数据转换成URL编码的只有GET超链接，因为表单发送数据会默认使用URL编码，也就是说，不用我们自己来编码。</p><p>例如：“传智”这两个字通过URL编码后得到的是：“%E4%BC%A0%E6%99%BA”。URL编码是先需要把“传智”转换成字节，例如我们现在使用UTF-8把“传智”转换成字符，得到的结果是：“[-28, -68, -96, -26, -103, -70]”，然后再把所有负数加上256，得到[228, 188, 160, 230, 153, 186]，再把每个int值转换成16进制，得到[E4, BC, A0, E6, 99, BA]，最后再每个16进制的整数前面加上“%”。</p><p>通过URL编码，把“传智”转换成了“%E4%BC%A0%E6%99%BA”，然后发送给服务器！服务器会自动识别出数据是使用URL编码过的，然后会自动把数据转换回来。</p><p> 当然，在页面中我们不需要自己去通过上面的过程把“传智”转换成“%E4%BC%A0%E6%99%BA”，而是使用Javascript来完成即可。当后面我们学习了JSP后，就不用再使用Javascript了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  function _go() &#123;</span></span><br><span class="line"><span class="undefined">  location = "/day05_2/AServlet?name=" + encodeURIComponent("传智+播客");</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:_go();"</span>&gt;</span>链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因为URL默认只支持ISO-8859-1，这说明在URL中出现中文和一些特殊字符可能无法发送到服务器。所以我们需要对包含中文或特殊字符的URL进行URL编码。</p><p>服务器会自动识别数据是否使用了URL编码，如果使用了服务器会自动把数据解码，无需我们自己动手解码。</p><hr><p>本博客：参考传智播客。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天来看看关于JavaWeb中关于和&lt;strong&gt;请求和响应&lt;/strong&gt;的知识！&lt;/p&gt;
&lt;h2 id=&quot;Response&quot;&gt;&lt;a href=&quot;#Response&quot; class=&quot;headerlink&quot; title=&quot;Response&quot;&gt;&lt;/a&gt;Response&lt;/
      
    
    </summary>
    
      <category term="JavaWeb核心篇" scheme="https://StormWangxhu.github.io/categories/JavaWeb%E6%A0%B8%E5%BF%83%E7%AF%87/"/>
    
    
      <category term="JavaWeb" scheme="https://StormWangxhu.github.io/tags/JavaWeb/"/>
    
      <category term="Request" scheme="https://StormWangxhu.github.io/tags/Request/"/>
    
      <category term="Response" scheme="https://StormWangxhu.github.io/tags/Response/"/>
    
  </entry>
  
</feed>
