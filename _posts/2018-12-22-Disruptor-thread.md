---
layout:     post
title:      Disruptor thread分析
date:       2018-12-18 11:55:00
summary:    why Disruptor so quick
categories: jekyll pixyll
---


###锁的缺点

想象有两个线程尝试修改同一个变量value：

![](/images/1545447242.jpg)

修改的情况：
* 线程1先到达：1. 变量value的值变为“blah”  2.然后当线程2到达时，变量value的值变为“blahy”
* 线程2先到达：1. 变量value的值变为“fluffy” 2. 然后当线程1到达时，值变为“blah”
* 线程1与线程2交互： 1.线程2得到值“fluff”，然后赋值给本地变量myValue 2.线程1改变value的值为“blah” 3.然后线程2 醒来并把变量value的值改为“fluffy”。

> 情况三显然是唯一一个错误的，其他两种情况主要是看你的意图和想要达到的效果，线程2可能不关心变量value的值是多少，主要的是在字符串后面加一个y，在这种前提下，情况1、2都是正确的。  但是如果线程2想把值设置为“fluffy”，有几种情况解决：

* 悲观锁：只要线程2一获得Entry的互斥锁，它就会阻击其他线程去改变它，然后它可以随意的做它要做的事情，设置值，然后做其他的事情。但是非常的消耗性能，因为其他线程在系统各处徘徊着准备获得锁然后又阻塞，线程越多，系统的响应性能就会越慢。

* 乐观锁：在这种情况下，当线程2需要去写Entry时才会锁定它，它需要先检查Entry自上次读过后是否已经被修改了，如果线程1在线程2读完并把值改为“blah”，线程2读到了新值，线程2不会把“fluffy”写到Entry里并把线程1所写的数据覆盖，线程2会重试(重新读取新的值，与旧值比较，如果相等则在变量的值后面附加上“y”)，
